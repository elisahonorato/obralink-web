"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@sentry";
exports.ids = ["vendor-chunks/@sentry"];
exports.modules = {

/***/ "(ssr)/./node_modules/@sentry/core/esm/constants.js":
/*!****************************************************!*\
  !*** ./node_modules/@sentry/core/esm/constants.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_ENVIRONMENT: () => (/* binding */ DEFAULT_ENVIRONMENT)\n/* harmony export */ });\nconst DEFAULT_ENVIRONMENT = \"production\";\n //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2VzbS9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE1BQU1BLHNCQUFzQjtBQUVHLENBQy9CLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL29icmFsaW5rLXdlYi8uL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvZXNtL2NvbnN0YW50cy5qcz8yZTdmIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IERFRkFVTFRfRU5WSVJPTk1FTlQgPSAncHJvZHVjdGlvbic7XG5cbmV4cG9ydCB7IERFRkFVTFRfRU5WSVJPTk1FTlQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJERUZBVUxUX0VOVklST05NRU5UIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/core/esm/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sentry/core/esm/debug-build.js":
/*!******************************************************!*\
  !*** ./node_modules/@sentry/core/esm/debug-build.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEBUG_BUILD: () => (/* binding */ DEBUG_BUILD)\n/* harmony export */ });\n/**\n * This serves as a build time flag that will be true by default, but false in non-debug builds or if users replace `__SENTRY_DEBUG__` in their generated code.\n *\n * ATTENTION: This constant must never cross package boundaries (i.e. be exported) to guarantee that it can be used for tree shaking.\n */ const DEBUG_BUILD = typeof __SENTRY_DEBUG__ === \"undefined\" || __SENTRY_DEBUG__;\n //# sourceMappingURL=debug-build.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2VzbS9kZWJ1Zy1idWlsZC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7Ozs7Q0FJQyxHQUNELE1BQU1BLGNBQWUsT0FBT0MscUJBQXFCLGVBQWVBO0FBRXpDLENBQ3ZCLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL29icmFsaW5rLXdlYi8uL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvZXNtL2RlYnVnLWJ1aWxkLmpzPzA3ZWYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUaGlzIHNlcnZlcyBhcyBhIGJ1aWxkIHRpbWUgZmxhZyB0aGF0IHdpbGwgYmUgdHJ1ZSBieSBkZWZhdWx0LCBidXQgZmFsc2UgaW4gbm9uLWRlYnVnIGJ1aWxkcyBvciBpZiB1c2VycyByZXBsYWNlIGBfX1NFTlRSWV9ERUJVR19fYCBpbiB0aGVpciBnZW5lcmF0ZWQgY29kZS5cbiAqXG4gKiBBVFRFTlRJT046IFRoaXMgY29uc3RhbnQgbXVzdCBuZXZlciBjcm9zcyBwYWNrYWdlIGJvdW5kYXJpZXMgKGkuZS4gYmUgZXhwb3J0ZWQpIHRvIGd1YXJhbnRlZSB0aGF0IGl0IGNhbiBiZSB1c2VkIGZvciB0cmVlIHNoYWtpbmcuXG4gKi9cbmNvbnN0IERFQlVHX0JVSUxEID0gKHR5cGVvZiBfX1NFTlRSWV9ERUJVR19fID09PSAndW5kZWZpbmVkJyB8fCBfX1NFTlRSWV9ERUJVR19fKTtcblxuZXhwb3J0IHsgREVCVUdfQlVJTEQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlYnVnLWJ1aWxkLmpzLm1hcFxuIl0sIm5hbWVzIjpbIkRFQlVHX0JVSUxEIiwiX19TRU5UUllfREVCVUdfXyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/core/esm/debug-build.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sentry/core/esm/eventProcessors.js":
/*!**********************************************************!*\
  !*** ./node_modules/@sentry/core/esm/eventProcessors.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addGlobalEventProcessor: () => (/* binding */ addGlobalEventProcessor),\n/* harmony export */   getGlobalEventProcessors: () => (/* binding */ getGlobalEventProcessors),\n/* harmony export */   notifyEventProcessors: () => (/* binding */ notifyEventProcessors)\n/* harmony export */ });\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sentry/utils */ \"(ssr)/./node_modules/@sentry/utils/esm/worldwide.js\");\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @sentry/utils */ \"(ssr)/./node_modules/@sentry/utils/esm/syncpromise.js\");\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @sentry/utils */ \"(ssr)/./node_modules/@sentry/utils/esm/logger.js\");\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @sentry/utils */ \"(ssr)/./node_modules/@sentry/utils/esm/is.js\");\n/* harmony import */ var _debug_build_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./debug-build.js */ \"(ssr)/./node_modules/@sentry/core/esm/debug-build.js\");\n\n\n/**\n * Returns the global event processors.\n * @deprecated Global event processors will be removed in v8.\n */ function getGlobalEventProcessors() {\n    return (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_0__.getGlobalSingleton)(\"globalEventProcessors\", ()=>[]);\n}\n/**\n * Add a EventProcessor to be kept globally.\n * @deprecated Use `addEventProcessor` instead. Global event processors will be removed in v8.\n */ function addGlobalEventProcessor(callback) {\n    // eslint-disable-next-line deprecation/deprecation\n    getGlobalEventProcessors().push(callback);\n}\n/**\n * Process an array of event processors, returning the processed event (or `null` if the event was dropped).\n */ function notifyEventProcessors(processors, event, hint, index = 0) {\n    return new _sentry_utils__WEBPACK_IMPORTED_MODULE_1__.SyncPromise((resolve, reject)=>{\n        const processor = processors[index];\n        if (event === null || typeof processor !== \"function\") {\n            resolve(event);\n        } else {\n            const result = processor({\n                ...event\n            }, hint);\n            _debug_build_js__WEBPACK_IMPORTED_MODULE_2__.DEBUG_BUILD && processor.id && result === null && _sentry_utils__WEBPACK_IMPORTED_MODULE_3__.logger.log(`Event processor \"${processor.id}\" dropped event`);\n            if ((0,_sentry_utils__WEBPACK_IMPORTED_MODULE_4__.isThenable)(result)) {\n                void result.then((final)=>notifyEventProcessors(processors, final, hint, index + 1).then(resolve)).then(null, reject);\n            } else {\n                void notifyEventProcessors(processors, result, hint, index + 1).then(resolve).then(null, reject);\n            }\n        }\n    });\n}\n //# sourceMappingURL=eventProcessors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2VzbS9ldmVudFByb2Nlc3NvcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBb0Y7QUFDckM7QUFFL0M7OztDQUdDLEdBQ0QsU0FBU0s7SUFDUCxPQUFPRixpRUFBa0JBLENBQUMseUJBQXlCLElBQU0sRUFBRTtBQUM3RDtBQUVBOzs7Q0FHQyxHQUNELFNBQVNHLHdCQUF3QkMsUUFBUTtJQUN2QyxtREFBbUQ7SUFDbkRGLDJCQUEyQkcsSUFBSSxDQUFDRDtBQUNsQztBQUVBOztDQUVDLEdBQ0QsU0FBU0Usc0JBQ1BDLFVBQVUsRUFDVkMsS0FBSyxFQUNMQyxJQUFJLEVBQ0pDLFFBQVEsQ0FBQztJQUVULE9BQU8sSUFBSWIsc0RBQVdBLENBQUMsQ0FBQ2MsU0FBU0M7UUFDL0IsTUFBTUMsWUFBWU4sVUFBVSxDQUFDRyxNQUFNO1FBQ25DLElBQUlGLFVBQVUsUUFBUSxPQUFPSyxjQUFjLFlBQVk7WUFDckRGLFFBQVFIO1FBQ1YsT0FBTztZQUNMLE1BQU1NLFNBQVNELFVBQVU7Z0JBQUUsR0FBR0wsS0FBSztZQUFDLEdBQUdDO1lBRXZDUix3REFBV0EsSUFBSVksVUFBVUUsRUFBRSxJQUFJRCxXQUFXLFFBQVFoQixpREFBTUEsQ0FBQ2tCLEdBQUcsQ0FBQyxDQUFDLGlCQUFpQixFQUFFSCxVQUFVRSxFQUFFLENBQUMsZUFBZSxDQUFDO1lBRTlHLElBQUloQix5REFBVUEsQ0FBQ2UsU0FBUztnQkFDdEIsS0FBS0EsT0FDRkcsSUFBSSxDQUFDQyxDQUFBQSxRQUFTWixzQkFBc0JDLFlBQVlXLE9BQU9ULE1BQU1DLFFBQVEsR0FBR08sSUFBSSxDQUFDTixVQUM3RU0sSUFBSSxDQUFDLE1BQU1MO1lBQ2hCLE9BQU87Z0JBQ0wsS0FBS04sc0JBQXNCQyxZQUFZTyxRQUFRTCxNQUFNQyxRQUFRLEdBQzFETyxJQUFJLENBQUNOLFNBQ0xNLElBQUksQ0FBQyxNQUFNTDtZQUNoQjtRQUNGO0lBQ0Y7QUFDRjtBQUVvRixDQUNwRiwyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vYnJhbGluay13ZWIvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2VzbS9ldmVudFByb2Nlc3NvcnMuanM/MDY0MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTeW5jUHJvbWlzZSwgbG9nZ2VyLCBpc1RoZW5hYmxlLCBnZXRHbG9iYWxTaW5nbGV0b24gfSBmcm9tICdAc2VudHJ5L3V0aWxzJztcbmltcG9ydCB7IERFQlVHX0JVSUxEIH0gZnJvbSAnLi9kZWJ1Zy1idWlsZC5qcyc7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZ2xvYmFsIGV2ZW50IHByb2Nlc3NvcnMuXG4gKiBAZGVwcmVjYXRlZCBHbG9iYWwgZXZlbnQgcHJvY2Vzc29ycyB3aWxsIGJlIHJlbW92ZWQgaW4gdjguXG4gKi9cbmZ1bmN0aW9uIGdldEdsb2JhbEV2ZW50UHJvY2Vzc29ycygpIHtcbiAgcmV0dXJuIGdldEdsb2JhbFNpbmdsZXRvbignZ2xvYmFsRXZlbnRQcm9jZXNzb3JzJywgKCkgPT4gW10pO1xufVxuXG4vKipcbiAqIEFkZCBhIEV2ZW50UHJvY2Vzc29yIHRvIGJlIGtlcHQgZ2xvYmFsbHkuXG4gKiBAZGVwcmVjYXRlZCBVc2UgYGFkZEV2ZW50UHJvY2Vzc29yYCBpbnN0ZWFkLiBHbG9iYWwgZXZlbnQgcHJvY2Vzc29ycyB3aWxsIGJlIHJlbW92ZWQgaW4gdjguXG4gKi9cbmZ1bmN0aW9uIGFkZEdsb2JhbEV2ZW50UHJvY2Vzc29yKGNhbGxiYWNrKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICBnZXRHbG9iYWxFdmVudFByb2Nlc3NvcnMoKS5wdXNoKGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBQcm9jZXNzIGFuIGFycmF5IG9mIGV2ZW50IHByb2Nlc3NvcnMsIHJldHVybmluZyB0aGUgcHJvY2Vzc2VkIGV2ZW50IChvciBgbnVsbGAgaWYgdGhlIGV2ZW50IHdhcyBkcm9wcGVkKS5cbiAqL1xuZnVuY3Rpb24gbm90aWZ5RXZlbnRQcm9jZXNzb3JzKFxuICBwcm9jZXNzb3JzLFxuICBldmVudCxcbiAgaGludCxcbiAgaW5kZXggPSAwLFxuKSB7XG4gIHJldHVybiBuZXcgU3luY1Byb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHByb2Nlc3NvciA9IHByb2Nlc3NvcnNbaW5kZXhdO1xuICAgIGlmIChldmVudCA9PT0gbnVsbCB8fCB0eXBlb2YgcHJvY2Vzc29yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXNvbHZlKGV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcmVzdWx0ID0gcHJvY2Vzc29yKHsgLi4uZXZlbnQgfSwgaGludCkgO1xuXG4gICAgICBERUJVR19CVUlMRCAmJiBwcm9jZXNzb3IuaWQgJiYgcmVzdWx0ID09PSBudWxsICYmIGxvZ2dlci5sb2coYEV2ZW50IHByb2Nlc3NvciBcIiR7cHJvY2Vzc29yLmlkfVwiIGRyb3BwZWQgZXZlbnRgKTtcblxuICAgICAgaWYgKGlzVGhlbmFibGUocmVzdWx0KSkge1xuICAgICAgICB2b2lkIHJlc3VsdFxuICAgICAgICAgIC50aGVuKGZpbmFsID0+IG5vdGlmeUV2ZW50UHJvY2Vzc29ycyhwcm9jZXNzb3JzLCBmaW5hbCwgaGludCwgaW5kZXggKyAxKS50aGVuKHJlc29sdmUpKVxuICAgICAgICAgIC50aGVuKG51bGwsIHJlamVjdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2b2lkIG5vdGlmeUV2ZW50UHJvY2Vzc29ycyhwcm9jZXNzb3JzLCByZXN1bHQsIGhpbnQsIGluZGV4ICsgMSlcbiAgICAgICAgICAudGhlbihyZXNvbHZlKVxuICAgICAgICAgIC50aGVuKG51bGwsIHJlamVjdCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0IHsgYWRkR2xvYmFsRXZlbnRQcm9jZXNzb3IsIGdldEdsb2JhbEV2ZW50UHJvY2Vzc29ycywgbm90aWZ5RXZlbnRQcm9jZXNzb3JzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ldmVudFByb2Nlc3NvcnMuanMubWFwXG4iXSwibmFtZXMiOlsiU3luY1Byb21pc2UiLCJsb2dnZXIiLCJpc1RoZW5hYmxlIiwiZ2V0R2xvYmFsU2luZ2xldG9uIiwiREVCVUdfQlVJTEQiLCJnZXRHbG9iYWxFdmVudFByb2Nlc3NvcnMiLCJhZGRHbG9iYWxFdmVudFByb2Nlc3NvciIsImNhbGxiYWNrIiwicHVzaCIsIm5vdGlmeUV2ZW50UHJvY2Vzc29ycyIsInByb2Nlc3NvcnMiLCJldmVudCIsImhpbnQiLCJpbmRleCIsInJlc29sdmUiLCJyZWplY3QiLCJwcm9jZXNzb3IiLCJyZXN1bHQiLCJpZCIsImxvZyIsInRoZW4iLCJmaW5hbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/core/esm/eventProcessors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sentry/core/esm/exports.js":
/*!**************************************************!*\
  !*** ./node_modules/@sentry/core/esm/exports.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addBreadcrumb: () => (/* binding */ addBreadcrumb),\n/* harmony export */   captureCheckIn: () => (/* binding */ captureCheckIn),\n/* harmony export */   captureEvent: () => (/* binding */ captureEvent),\n/* harmony export */   captureException: () => (/* binding */ captureException),\n/* harmony export */   captureMessage: () => (/* binding */ captureMessage),\n/* harmony export */   captureSession: () => (/* binding */ captureSession),\n/* harmony export */   close: () => (/* binding */ close),\n/* harmony export */   configureScope: () => (/* binding */ configureScope),\n/* harmony export */   endSession: () => (/* binding */ endSession),\n/* harmony export */   flush: () => (/* binding */ flush),\n/* harmony export */   getClient: () => (/* binding */ getClient),\n/* harmony export */   getCurrentScope: () => (/* binding */ getCurrentScope),\n/* harmony export */   isInitialized: () => (/* binding */ isInitialized),\n/* harmony export */   lastEventId: () => (/* binding */ lastEventId),\n/* harmony export */   setContext: () => (/* binding */ setContext),\n/* harmony export */   setExtra: () => (/* binding */ setExtra),\n/* harmony export */   setExtras: () => (/* binding */ setExtras),\n/* harmony export */   setTag: () => (/* binding */ setTag),\n/* harmony export */   setTags: () => (/* binding */ setTags),\n/* harmony export */   setUser: () => (/* binding */ setUser),\n/* harmony export */   startSession: () => (/* binding */ startSession),\n/* harmony export */   startTransaction: () => (/* binding */ startTransaction),\n/* harmony export */   withActiveSpan: () => (/* binding */ withActiveSpan),\n/* harmony export */   withIsolationScope: () => (/* binding */ withIsolationScope),\n/* harmony export */   withMonitor: () => (/* binding */ withMonitor),\n/* harmony export */   withScope: () => (/* binding */ withScope)\n/* harmony export */ });\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @sentry/utils */ \"(ssr)/./node_modules/@sentry/utils/esm/logger.js\");\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @sentry/utils */ \"(ssr)/./node_modules/@sentry/utils/esm/misc.js\");\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @sentry/utils */ \"(ssr)/./node_modules/@sentry/utils/esm/time.js\");\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @sentry/utils */ \"(ssr)/./node_modules/@sentry/utils/esm/is.js\");\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @sentry/utils */ \"(ssr)/./node_modules/@sentry/utils/esm/worldwide.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./constants.js */ \"(ssr)/./node_modules/@sentry/core/esm/constants.js\");\n/* harmony import */ var _debug_build_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./debug-build.js */ \"(ssr)/./node_modules/@sentry/core/esm/debug-build.js\");\n/* harmony import */ var _hub_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hub.js */ \"(ssr)/./node_modules/@sentry/core/esm/hub.js\");\n/* harmony import */ var _session_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./session.js */ \"(ssr)/./node_modules/@sentry/core/esm/session.js\");\n/* harmony import */ var _utils_prepareEvent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/prepareEvent.js */ \"(ssr)/./node_modules/@sentry/core/esm/utils/prepareEvent.js\");\n\n\n\n\n\n\n/**\n * Captures an exception event and sends it to Sentry.\n *\n * @param exception The exception to capture.\n * @param hint Optional additional data to attach to the Sentry event.\n * @returns the id of the captured Sentry event.\n */ function captureException(// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexception, hint) {\n    // eslint-disable-next-line deprecation/deprecation\n    return (0,_hub_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentHub)().captureException(exception, (0,_utils_prepareEvent_js__WEBPACK_IMPORTED_MODULE_1__.parseEventHintOrCaptureContext)(hint));\n}\n/**\n * Captures a message event and sends it to Sentry.\n *\n * @param exception The exception to capture.\n * @param captureContext Define the level of the message or pass in additional data to attach to the message.\n * @returns the id of the captured message.\n */ function captureMessage(message, // eslint-disable-next-line deprecation/deprecation\ncaptureContext) {\n    // This is necessary to provide explicit scopes upgrade, without changing the original\n    // arity of the `captureMessage(message, level)` method.\n    const level = typeof captureContext === \"string\" ? captureContext : undefined;\n    const context = typeof captureContext !== \"string\" ? {\n        captureContext\n    } : undefined;\n    // eslint-disable-next-line deprecation/deprecation\n    return (0,_hub_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentHub)().captureMessage(message, level, context);\n}\n/**\n * Captures a manually created event and sends it to Sentry.\n *\n * @param exception The event to send to Sentry.\n * @param hint Optional additional data to attach to the Sentry event.\n * @returns the id of the captured event.\n */ function captureEvent(event, hint) {\n    // eslint-disable-next-line deprecation/deprecation\n    return (0,_hub_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentHub)().captureEvent(event, hint);\n}\n/**\n * Callback to set context information onto the scope.\n * @param callback Callback function that receives Scope.\n *\n * @deprecated Use getCurrentScope() directly.\n */ function configureScope(callback) {\n    // eslint-disable-next-line deprecation/deprecation\n    (0,_hub_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentHub)().configureScope(callback);\n}\n/**\n * Records a new breadcrumb which will be attached to future events.\n *\n * Breadcrumbs will be added to subsequent events to provide more context on\n * user's actions prior to an error or crash.\n *\n * @param breadcrumb The breadcrumb to record.\n */ function addBreadcrumb(breadcrumb, hint) {\n    // eslint-disable-next-line deprecation/deprecation\n    (0,_hub_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentHub)().addBreadcrumb(breadcrumb, hint);\n}\n/**\n * Sets context data with the given name.\n * @param name of the context\n * @param context Any kind of data. This data will be normalized.\n */ // eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction setContext(name, context) {\n    // eslint-disable-next-line deprecation/deprecation\n    (0,_hub_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentHub)().setContext(name, context);\n}\n/**\n * Set an object that will be merged sent as extra data with the event.\n * @param extras Extras object to merge into current context.\n */ function setExtras(extras) {\n    // eslint-disable-next-line deprecation/deprecation\n    (0,_hub_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentHub)().setExtras(extras);\n}\n/**\n * Set key:value that will be sent as extra data with the event.\n * @param key String of extra\n * @param extra Any kind of data. This data will be normalized.\n */ function setExtra(key, extra) {\n    // eslint-disable-next-line deprecation/deprecation\n    (0,_hub_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentHub)().setExtra(key, extra);\n}\n/**\n * Set an object that will be merged sent as tags data with the event.\n * @param tags Tags context object to merge into current context.\n */ function setTags(tags) {\n    // eslint-disable-next-line deprecation/deprecation\n    (0,_hub_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentHub)().setTags(tags);\n}\n/**\n * Set key:value that will be sent as tags data with the event.\n *\n * Can also be used to unset a tag, by passing `undefined`.\n *\n * @param key String key of tag\n * @param value Value of tag\n */ function setTag(key, value) {\n    // eslint-disable-next-line deprecation/deprecation\n    (0,_hub_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentHub)().setTag(key, value);\n}\n/**\n * Updates user context information for future events.\n *\n * @param user User context object to be set in the current context. Pass `null` to unset the user.\n */ function setUser(user) {\n    // eslint-disable-next-line deprecation/deprecation\n    (0,_hub_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentHub)().setUser(user);\n}\n/**\n * Creates a new scope with and executes the given operation within.\n * The scope is automatically removed once the operation\n * finishes or throws.\n *\n * This is essentially a convenience function for:\n *\n *     pushScope();\n *     callback();\n *     popScope();\n */ /**\n * Either creates a new active scope, or sets the given scope as active scope in the given callback.\n */ function withScope(...rest) {\n    // eslint-disable-next-line deprecation/deprecation\n    const hub = (0,_hub_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentHub)();\n    // If a scope is defined, we want to make this the active scope instead of the default one\n    if (rest.length === 2) {\n        const [scope, callback] = rest;\n        if (!scope) {\n            // eslint-disable-next-line deprecation/deprecation\n            return hub.withScope(callback);\n        }\n        // eslint-disable-next-line deprecation/deprecation\n        return hub.withScope(()=>{\n            // eslint-disable-next-line deprecation/deprecation\n            hub.getStackTop().scope = scope;\n            return callback(scope);\n        });\n    }\n    // eslint-disable-next-line deprecation/deprecation\n    return hub.withScope(rest[0]);\n}\n/**\n * Attempts to fork the current isolation scope and the current scope based on the current async context strategy. If no\n * async context strategy is set, the isolation scope and the current scope will not be forked (this is currently the\n * case, for example, in the browser).\n *\n * Usage of this function in environments without async context strategy is discouraged and may lead to unexpected behaviour.\n *\n * This function is intended for Sentry SDK and SDK integration development. It is not recommended to be used in \"normal\"\n * applications directly because it comes with pitfalls. Use at your own risk!\n *\n * @param callback The callback in which the passed isolation scope is active. (Note: In environments without async\n * context strategy, the currently active isolation scope may change within execution of the callback.)\n * @returns The same value that `callback` returns.\n */ function withIsolationScope(callback) {\n    return (0,_hub_js__WEBPACK_IMPORTED_MODULE_0__.runWithAsyncContext)(()=>{\n        return callback((0,_hub_js__WEBPACK_IMPORTED_MODULE_0__.getIsolationScope)());\n    });\n}\n/**\n * Forks the current scope and sets the provided span as active span in the context of the provided callback.\n *\n * @param span Spans started in the context of the provided callback will be children of this span.\n * @param callback Execution context in which the provided span will be active. Is passed the newly forked scope.\n * @returns the value returned from the provided callback function.\n */ function withActiveSpan(span, callback) {\n    return withScope((scope)=>{\n        // eslint-disable-next-line deprecation/deprecation\n        scope.setSpan(span);\n        return callback(scope);\n    });\n}\n/**\n * Starts a new `Transaction` and returns it. This is the entry point to manual tracing instrumentation.\n *\n * A tree structure can be built by adding child spans to the transaction, and child spans to other spans. To start a\n * new child span within the transaction or any span, call the respective `.startChild()` method.\n *\n * Every child span must be finished before the transaction is finished, otherwise the unfinished spans are discarded.\n *\n * The transaction must be finished with a call to its `.end()` method, at which point the transaction with all its\n * finished child spans will be sent to Sentry.\n *\n * NOTE: This function should only be used for *manual* instrumentation. Auto-instrumentation should call\n * `startTransaction` directly on the hub.\n *\n * @param context Properties of the new `Transaction`.\n * @param customSamplingContext Information given to the transaction sampling function (along with context-dependent\n * default values). See {@link Options.tracesSampler}.\n *\n * @returns The transaction which was just started\n *\n * @deprecated Use `startSpan()`, `startSpanManual()` or `startInactiveSpan()` instead.\n */ function startTransaction(context, customSamplingContext) {\n    // eslint-disable-next-line deprecation/deprecation\n    return (0,_hub_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentHub)().startTransaction({\n        ...context\n    }, customSamplingContext);\n}\n/**\n * Create a cron monitor check in and send it to Sentry.\n *\n * @param checkIn An object that describes a check in.\n * @param upsertMonitorConfig An optional object that describes a monitor config. Use this if you want\n * to create a monitor automatically when sending a check in.\n */ function captureCheckIn(checkIn, upsertMonitorConfig) {\n    const scope = getCurrentScope();\n    const client = getClient();\n    if (!client) {\n        _debug_build_js__WEBPACK_IMPORTED_MODULE_2__.DEBUG_BUILD && _sentry_utils__WEBPACK_IMPORTED_MODULE_3__.logger.warn(\"Cannot capture check-in. No client defined.\");\n    } else if (!client.captureCheckIn) {\n        _debug_build_js__WEBPACK_IMPORTED_MODULE_2__.DEBUG_BUILD && _sentry_utils__WEBPACK_IMPORTED_MODULE_3__.logger.warn(\"Cannot capture check-in. Client does not support sending check-ins.\");\n    } else {\n        return client.captureCheckIn(checkIn, upsertMonitorConfig, scope);\n    }\n    return (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_4__.uuid4)();\n}\n/**\n * Wraps a callback with a cron monitor check in. The check in will be sent to Sentry when the callback finishes.\n *\n * @param monitorSlug The distinct slug of the monitor.\n * @param upsertMonitorConfig An optional object that describes a monitor config. Use this if you want\n * to create a monitor automatically when sending a check in.\n */ function withMonitor(monitorSlug, callback, upsertMonitorConfig) {\n    const checkInId = captureCheckIn({\n        monitorSlug,\n        status: \"in_progress\"\n    }, upsertMonitorConfig);\n    const now = (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_5__.timestampInSeconds)();\n    function finishCheckIn(status) {\n        captureCheckIn({\n            monitorSlug,\n            status,\n            checkInId,\n            duration: (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_5__.timestampInSeconds)() - now\n        });\n    }\n    let maybePromiseResult;\n    try {\n        maybePromiseResult = callback();\n    } catch (e) {\n        finishCheckIn(\"error\");\n        throw e;\n    }\n    if ((0,_sentry_utils__WEBPACK_IMPORTED_MODULE_6__.isThenable)(maybePromiseResult)) {\n        Promise.resolve(maybePromiseResult).then(()=>{\n            finishCheckIn(\"ok\");\n        }, ()=>{\n            finishCheckIn(\"error\");\n        });\n    } else {\n        finishCheckIn(\"ok\");\n    }\n    return maybePromiseResult;\n}\n/**\n * Call `flush()` on the current client, if there is one. See {@link Client.flush}.\n *\n * @param timeout Maximum time in ms the client should wait to flush its event queue. Omitting this parameter will cause\n * the client to wait until all events are sent before resolving the promise.\n * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it\n * doesn't (or if there's no client defined).\n */ async function flush(timeout) {\n    const client = getClient();\n    if (client) {\n        return client.flush(timeout);\n    }\n    _debug_build_js__WEBPACK_IMPORTED_MODULE_2__.DEBUG_BUILD && _sentry_utils__WEBPACK_IMPORTED_MODULE_3__.logger.warn(\"Cannot flush events. No client defined.\");\n    return Promise.resolve(false);\n}\n/**\n * Call `close()` on the current client, if there is one. See {@link Client.close}.\n *\n * @param timeout Maximum time in ms the client should wait to flush its event queue before shutting down. Omitting this\n * parameter will cause the client to wait until all events are sent before disabling itself.\n * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it\n * doesn't (or if there's no client defined).\n */ async function close(timeout) {\n    const client = getClient();\n    if (client) {\n        return client.close(timeout);\n    }\n    _debug_build_js__WEBPACK_IMPORTED_MODULE_2__.DEBUG_BUILD && _sentry_utils__WEBPACK_IMPORTED_MODULE_3__.logger.warn(\"Cannot flush events and disable SDK. No client defined.\");\n    return Promise.resolve(false);\n}\n/**\n * This is the getter for lastEventId.\n *\n * @returns The last event id of a captured event.\n * @deprecated This function will be removed in the next major version of the Sentry SDK.\n */ function lastEventId() {\n    // eslint-disable-next-line deprecation/deprecation\n    return (0,_hub_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentHub)().lastEventId();\n}\n/**\n * Get the currently active client.\n */ function getClient() {\n    // eslint-disable-next-line deprecation/deprecation\n    return (0,_hub_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentHub)().getClient();\n}\n/**\n * Returns true if Sentry has been properly initialized.\n */ function isInitialized() {\n    return !!getClient();\n}\n/**\n * Get the currently active scope.\n */ function getCurrentScope() {\n    // eslint-disable-next-line deprecation/deprecation\n    return (0,_hub_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentHub)().getScope();\n}\n/**\n * Start a session on the current isolation scope.\n *\n * @param context (optional) additional properties to be applied to the returned session object\n *\n * @returns the new active session\n */ function startSession(context) {\n    const client = getClient();\n    const isolationScope = (0,_hub_js__WEBPACK_IMPORTED_MODULE_0__.getIsolationScope)();\n    const currentScope = getCurrentScope();\n    const { release, environment = _constants_js__WEBPACK_IMPORTED_MODULE_7__.DEFAULT_ENVIRONMENT } = client && client.getOptions() || {};\n    // Will fetch userAgent if called from browser sdk\n    const { userAgent } = _sentry_utils__WEBPACK_IMPORTED_MODULE_8__.GLOBAL_OBJ.navigator || {};\n    const session = (0,_session_js__WEBPACK_IMPORTED_MODULE_9__.makeSession)({\n        release,\n        environment,\n        user: currentScope.getUser() || isolationScope.getUser(),\n        ...userAgent && {\n            userAgent\n        },\n        ...context\n    });\n    // End existing session if there's one\n    const currentSession = isolationScope.getSession();\n    if (currentSession && currentSession.status === \"ok\") {\n        (0,_session_js__WEBPACK_IMPORTED_MODULE_9__.updateSession)(currentSession, {\n            status: \"exited\"\n        });\n    }\n    endSession();\n    // Afterwards we set the new session on the scope\n    isolationScope.setSession(session);\n    // TODO (v8): Remove this and only use the isolation scope(?).\n    // For v7 though, we can't \"soft-break\" people using getCurrentHub().getScope().setSession()\n    currentScope.setSession(session);\n    return session;\n}\n/**\n * End the session on the current isolation scope.\n */ function endSession() {\n    const isolationScope = (0,_hub_js__WEBPACK_IMPORTED_MODULE_0__.getIsolationScope)();\n    const currentScope = getCurrentScope();\n    const session = currentScope.getSession() || isolationScope.getSession();\n    if (session) {\n        (0,_session_js__WEBPACK_IMPORTED_MODULE_9__.closeSession)(session);\n    }\n    _sendSessionUpdate();\n    // the session is over; take it off of the scope\n    isolationScope.setSession();\n    // TODO (v8): Remove this and only use the isolation scope(?).\n    // For v7 though, we can't \"soft-break\" people using getCurrentHub().getScope().setSession()\n    currentScope.setSession();\n}\n/**\n * Sends the current Session on the scope\n */ function _sendSessionUpdate() {\n    const isolationScope = (0,_hub_js__WEBPACK_IMPORTED_MODULE_0__.getIsolationScope)();\n    const currentScope = getCurrentScope();\n    const client = getClient();\n    // TODO (v8): Remove currentScope and only use the isolation scope(?).\n    // For v7 though, we can't \"soft-break\" people using getCurrentHub().getScope().setSession()\n    const session = currentScope.getSession() || isolationScope.getSession();\n    if (session && client && client.captureSession) {\n        client.captureSession(session);\n    }\n}\n/**\n * Sends the current session on the scope to Sentry\n *\n * @param end If set the session will be marked as exited and removed from the scope.\n *            Defaults to `false`.\n */ function captureSession(end = false) {\n    // both send the update and pull the session from the scope\n    if (end) {\n        endSession();\n        return;\n    }\n    // only send the update\n    _sendSessionUpdate();\n}\n //# sourceMappingURL=exports.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2VzbS9leHBvcnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEwRjtBQUNyQztBQUNOO0FBQ2tDO0FBQ1Q7QUFDQztBQUV6RTs7Ozs7O0NBTUMsR0FDRCxTQUFTYyxpQkFDUCw4REFBOEQ7QUFDOURDLFNBQVMsRUFDVEMsSUFBSTtJQUVKLG1EQUFtRDtJQUNuRCxPQUFPVCxzREFBYUEsR0FBR08sZ0JBQWdCLENBQUNDLFdBQVdGLHNGQUE4QkEsQ0FBQ0c7QUFDcEY7QUFFQTs7Ozs7O0NBTUMsR0FDRCxTQUFTQyxlQUNQQyxPQUFPLEVBQ1AsbURBQW1EO0FBQ25EQyxjQUFjO0lBRWQsc0ZBQXNGO0lBQ3RGLHdEQUF3RDtJQUN4RCxNQUFNQyxRQUFRLE9BQU9ELG1CQUFtQixXQUFXQSxpQkFBaUJFO0lBQ3BFLE1BQU1DLFVBQVUsT0FBT0gsbUJBQW1CLFdBQVc7UUFBRUE7SUFBZSxJQUFJRTtJQUMxRSxtREFBbUQ7SUFDbkQsT0FBT2Qsc0RBQWFBLEdBQUdVLGNBQWMsQ0FBQ0MsU0FBU0UsT0FBT0U7QUFDeEQ7QUFFQTs7Ozs7O0NBTUMsR0FDRCxTQUFTQyxhQUFhQyxLQUFLLEVBQUVSLElBQUk7SUFDL0IsbURBQW1EO0lBQ25ELE9BQU9ULHNEQUFhQSxHQUFHZ0IsWUFBWSxDQUFDQyxPQUFPUjtBQUM3QztBQUVBOzs7OztDQUtDLEdBQ0QsU0FBU1MsZUFBZUMsUUFBUTtJQUM5QixtREFBbUQ7SUFDbkRuQixzREFBYUEsR0FBR2tCLGNBQWMsQ0FBQ0M7QUFDakM7QUFFQTs7Ozs7OztDQU9DLEdBQ0QsU0FBU0MsY0FBY0MsVUFBVSxFQUFFWixJQUFJO0lBQ3JDLG1EQUFtRDtJQUNuRFQsc0RBQWFBLEdBQUdvQixhQUFhLENBQUNDLFlBQVlaO0FBQzVDO0FBRUE7Ozs7Q0FJQyxHQUNELDhEQUE4RDtBQUM5RCxTQUFTYSxXQUFXQyxJQUFJLEVBQUVS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WDNFLHlEQUFZQSxDQUFDMkU7SUFDZjtJQUNBTTtJQUVBLGdEQUFnRDtJQUNoRGIsZUFBZVksVUFBVTtJQUV6Qiw4REFBOEQ7SUFDOUQsNEZBQTRGO0lBQzVGWCxhQUFhVyxVQUFVO0FBQ3pCO0FBRUE7O0NBRUMsR0FDRCxTQUFTQztJQUNQLE1BQU1iLGlCQUFpQnZFLDBEQUFpQkE7SUFDeEMsTUFBTXdFLGVBQWV4QjtJQUNyQixNQUFNQyxTQUFTQztJQUNmLHNFQUFzRTtJQUN0RSw0RkFBNEY7SUFDNUYsTUFBTTRCLFVBQVVOLGFBQWFTLFVBQVUsTUFBTVYsZUFBZVUsVUFBVTtJQUN0RSxJQUFJSCxXQUFXN0IsVUFBVUEsT0FBT29DLGNBQWMsRUFBRTtRQUM5Q3BDLE9BQU9vQyxjQUFjLENBQUNQO0lBQ3hCO0FBQ0Y7QUFFQTs7Ozs7Q0FLQyxHQUNELFNBQVNPLGVBQWVDLE1BQU0sS0FBSztJQUNqQywyREFBMkQ7SUFDM0QsSUFBSUEsS0FBSztRQUNQSjtRQUNBO0lBQ0Y7SUFFQSx1QkFBdUI7SUFDdkJFO0FBQ0Y7QUFFa1csQ0FDbFcsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb2JyYWxpbmstd2ViLy4vbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9lc20vZXhwb3J0cy5qcz8zOGJmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGxvZ2dlciwgdXVpZDQsIHRpbWVzdGFtcEluU2Vjb25kcywgaXNUaGVuYWJsZSwgR0xPQkFMX09CSiB9IGZyb20gJ0BzZW50cnkvdXRpbHMnO1xuaW1wb3J0IHsgREVGQVVMVF9FTlZJUk9OTUVOVCB9IGZyb20gJy4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IERFQlVHX0JVSUxEIH0gZnJvbSAnLi9kZWJ1Zy1idWlsZC5qcyc7XG5pbXBvcnQgeyBnZXRDdXJyZW50SHViLCBydW5XaXRoQXN5bmNDb250ZXh0LCBnZXRJc29sYXRpb25TY29wZSB9IGZyb20gJy4vaHViLmpzJztcbmltcG9ydCB7IG1ha2VTZXNzaW9uLCB1cGRhdGVTZXNzaW9uLCBjbG9zZVNlc3Npb24gfSBmcm9tICcuL3Nlc3Npb24uanMnO1xuaW1wb3J0IHsgcGFyc2VFdmVudEhpbnRPckNhcHR1cmVDb250ZXh0IH0gZnJvbSAnLi91dGlscy9wcmVwYXJlRXZlbnQuanMnO1xuXG4vKipcbiAqIENhcHR1cmVzIGFuIGV4Y2VwdGlvbiBldmVudCBhbmQgc2VuZHMgaXQgdG8gU2VudHJ5LlxuICpcbiAqIEBwYXJhbSBleGNlcHRpb24gVGhlIGV4Y2VwdGlvbiB0byBjYXB0dXJlLlxuICogQHBhcmFtIGhpbnQgT3B0aW9uYWwgYWRkaXRpb25hbCBkYXRhIHRvIGF0dGFjaCB0byB0aGUgU2VudHJ5IGV2ZW50LlxuICogQHJldHVybnMgdGhlIGlkIG9mIHRoZSBjYXB0dXJlZCBTZW50cnkgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGNhcHR1cmVFeGNlcHRpb24oXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIGV4Y2VwdGlvbixcbiAgaGludCxcbikge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgcmV0dXJuIGdldEN1cnJlbnRIdWIoKS5jYXB0dXJlRXhjZXB0aW9uKGV4Y2VwdGlvbiwgcGFyc2VFdmVudEhpbnRPckNhcHR1cmVDb250ZXh0KGhpbnQpKTtcbn1cblxuLyoqXG4gKiBDYXB0dXJlcyBhIG1lc3NhZ2UgZXZlbnQgYW5kIHNlbmRzIGl0IHRvIFNlbnRyeS5cbiAqXG4gKiBAcGFyYW0gZXhjZXB0aW9uIFRoZSBleGNlcHRpb24gdG8gY2FwdHVyZS5cbiAqIEBwYXJhbSBjYXB0dXJlQ29udGV4dCBEZWZpbmUgdGhlIGxldmVsIG9mIHRoZSBtZXNzYWdlIG9yIHBhc3MgaW4gYWRkaXRpb25hbCBkYXRhIHRvIGF0dGFjaCB0byB0aGUgbWVzc2FnZS5cbiAqIEByZXR1cm5zIHRoZSBpZCBvZiB0aGUgY2FwdHVyZWQgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gY2FwdHVyZU1lc3NhZ2UoXG4gIG1lc3NhZ2UsXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICBjYXB0dXJlQ29udGV4dCxcbikge1xuICAvLyBUaGlzIGlzIG5lY2Vzc2FyeSB0byBwcm92aWRlIGV4cGxpY2l0IHNjb3BlcyB1cGdyYWRlLCB3aXRob3V0IGNoYW5naW5nIHRoZSBvcmlnaW5hbFxuICAvLyBhcml0eSBvZiB0aGUgYGNhcHR1cmVNZXNzYWdlKG1lc3NhZ2UsIGxldmVsKWAgbWV0aG9kLlxuICBjb25zdCBsZXZlbCA9IHR5cGVvZiBjYXB0dXJlQ29udGV4dCA9PT0gJ3N0cmluZycgPyBjYXB0dXJlQ29udGV4dCA6IHVuZGVmaW5lZDtcbiAgY29uc3QgY29udGV4dCA9IHR5cGVvZiBjYXB0dXJlQ29udGV4dCAhPT0gJ3N0cmluZycgPyB7IGNhcHR1cmVDb250ZXh0IH0gOiB1bmRlZmluZWQ7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICByZXR1cm4gZ2V0Q3VycmVudEh1YigpLmNhcHR1cmVNZXNzYWdlKG1lc3NhZ2UsIGxldmVsLCBjb250ZXh0KTtcbn1cblxuLyoqXG4gKiBDYXB0dXJlcyBhIG1hbnVhbGx5IGNyZWF0ZWQgZXZlbnQgYW5kIHNlbmRzIGl0IHRvIFNlbnRyeS5cbiAqXG4gKiBAcGFyYW0gZXhjZXB0aW9uIFRoZSBldmVudCB0byBzZW5kIHRvIFNlbnRyeS5cbiAqIEBwYXJhbSBoaW50IE9wdGlvbmFsIGFkZGl0aW9uYWwgZGF0YSB0byBhdHRhY2ggdG8gdGhlIFNlbnRyeSBldmVudC5cbiAqIEByZXR1cm5zIHRoZSBpZCBvZiB0aGUgY2FwdHVyZWQgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGNhcHR1cmVFdmVudChldmVudCwgaGludCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgcmV0dXJuIGdldEN1cnJlbnRIdWIoKS5jYXB0dXJlRXZlbnQoZXZlbnQsIGhpbnQpO1xufVxuXG4vKipcbiAqIENhbGxiYWNrIHRvIHNldCBjb250ZXh0IGluZm9ybWF0aW9uIG9udG8gdGhlIHNjb3BlLlxuICogQHBhcmFtIGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgU2NvcGUuXG4gKlxuICogQGRlcHJlY2F0ZWQgVXNlIGdldEN1cnJlbnRTY29wZSgpIGRpcmVjdGx5LlxuICovXG5mdW5jdGlvbiBjb25maWd1cmVTY29wZShjYWxsYmFjaykge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgZ2V0Q3VycmVudEh1YigpLmNvbmZpZ3VyZVNjb3BlKGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBSZWNvcmRzIGEgbmV3IGJyZWFkY3J1bWIgd2hpY2ggd2lsbCBiZSBhdHRhY2hlZCB0byBmdXR1cmUgZXZlbnRzLlxuICpcbiAqIEJyZWFkY3J1bWJzIHdpbGwgYmUgYWRkZWQgdG8gc3Vic2VxdWVudCBldmVudHMgdG8gcHJvdmlkZSBtb3JlIGNvbnRleHQgb25cbiAqIHVzZXIncyBhY3Rpb25zIHByaW9yIHRvIGFuIGVycm9yIG9yIGNyYXNoLlxuICpcbiAqIEBwYXJhbSBicmVhZGNydW1iIFRoZSBicmVhZGNydW1iIHRvIHJlY29yZC5cbiAqL1xuZnVuY3Rpb24gYWRkQnJlYWRjcnVtYihicmVhZGNydW1iLCBoaW50KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICBnZXRDdXJyZW50SHViKCkuYWRkQnJlYWRjcnVtYihicmVhZGNydW1iLCBoaW50KTtcbn1cblxuLyoqXG4gKiBTZXRzIGNvbnRleHQgZGF0YSB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuICogQHBhcmFtIG5hbWUgb2YgdGhlIGNvbnRleHRcbiAqIEBwYXJhbSBjb250ZXh0IEFueSBraW5kIG9mIGRhdGEuIFRoaXMgZGF0YSB3aWxsIGJlIG5vcm1hbGl6ZWQuXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBzZXRDb250ZXh0KG5hbWUsIGNvbnRleHQpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gIGdldEN1cnJlbnRIdWIoKS5zZXRDb250ZXh0KG5hbWUsIGNvbnRleHQpO1xufVxuXG4vKipcbiAqIFNldCBhbiBvYmplY3QgdGhhdCB3aWxsIGJlIG1lcmdlZCBzZW50IGFzIGV4dHJhIGRhdGEgd2l0aCB0aGUgZXZlbnQuXG4gKiBAcGFyYW0gZXh0cmFzIEV4dHJhcyBvYmplY3QgdG8gbWVyZ2UgaW50byBjdXJyZW50IGNvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIHNldEV4dHJhcyhleHRyYXMpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gIGdldEN1cnJlbnRIdWIoKS5zZXRFeHRyYXMoZXh0cmFzKTtcbn1cblxuLyoqXG4gKiBTZXQga2V5OnZhbHVlIHRoYXQgd2lsbCBiZSBzZW50IGFzIGV4dHJhIGRhdGEgd2l0aCB0aGUgZXZlbnQuXG4gKiBAcGFyYW0ga2V5IFN0cmluZyBvZiBleHRyYVxuICogQHBhcmFtIGV4dHJhIEFueSBraW5kIG9mIGRhdGEuIFRoaXMgZGF0YSB3aWxsIGJlIG5vcm1hbGl6ZWQuXG4gKi9cbmZ1bmN0aW9uIHNldEV4dHJhKGtleSwgZXh0cmEpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gIGdldEN1cnJlbnRIdWIoKS5zZXRFeHRyYShrZXksIGV4dHJhKTtcbn1cblxuLyoqXG4gKiBTZXQgYW4gb2JqZWN0IHRoYXQgd2lsbCBiZSBtZXJnZWQgc2VudCBhcyB0YWdzIGRhdGEgd2l0aCB0aGUgZXZlbnQuXG4gKiBAcGFyYW0gdGFncyBUYWdzIGNvbnRleHQgb2JqZWN0IHRvIG1lcmdlIGludG8gY3VycmVudCBjb250ZXh0LlxuICovXG5mdW5jdGlvbiBzZXRUYWdzKHRhZ3MpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gIGdldEN1cnJlbnRIdWIoKS5zZXRUYWdzKHRhZ3MpO1xufVxuXG4vKipcbiAqIFNldCBrZXk6dmFsdWUgdGhhdCB3aWxsIGJlIHNlbnQgYXMgdGFncyBkYXRhIHdpdGggdGhlIGV2ZW50LlxuICpcbiAqIENhbiBhbHNvIGJlIHVzZWQgdG8gdW5zZXQgYSB0YWcsIGJ5IHBhc3NpbmcgYHVuZGVmaW5lZGAuXG4gKlxuICogQHBhcmFtIGtleSBTdHJpbmcga2V5IG9mIHRhZ1xuICogQHBhcmFtIHZhbHVlIFZhbHVlIG9mIHRhZ1xuICovXG5mdW5jdGlvbiBzZXRUYWcoa2V5LCB2YWx1ZSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgZ2V0Q3VycmVudEh1YigpLnNldFRhZyhrZXksIHZhbHVlKTtcbn1cblxuLyoqXG4gKiBVcGRhdGVzIHVzZXIgY29udGV4dCBpbmZvcm1hdGlvbiBmb3IgZnV0dXJlIGV2ZW50cy5cbiAqXG4gKiBAcGFyYW0gdXNlciBVc2VyIGNvbnRleHQgb2JqZWN0IHRvIGJlIHNldCBpbiB0aGUgY3VycmVudCBjb250ZXh0LiBQYXNzIGBudWxsYCB0byB1bnNldCB0aGUgdXNlci5cbiAqL1xuZnVuY3Rpb24gc2V0VXNlcih1c2VyKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICBnZXRDdXJyZW50SHViKCkuc2V0VXNlcih1c2VyKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHNjb3BlIHdpdGggYW5kIGV4ZWN1dGVzIHRoZSBnaXZlbiBvcGVyYXRpb24gd2l0aGluLlxuICogVGhlIHNjb3BlIGlzIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCBvbmNlIHRoZSBvcGVyYXRpb25cbiAqIGZpbmlzaGVzIG9yIHRocm93cy5cbiAqXG4gKiBUaGlzIGlzIGVzc2VudGlhbGx5IGEgY29udmVuaWVuY2UgZnVuY3Rpb24gZm9yOlxuICpcbiAqICAgICBwdXNoU2NvcGUoKTtcbiAqICAgICBjYWxsYmFjaygpO1xuICogICAgIHBvcFNjb3BlKCk7XG4gKi9cblxuLyoqXG4gKiBFaXRoZXIgY3JlYXRlcyBhIG5ldyBhY3RpdmUgc2NvcGUsIG9yIHNldHMgdGhlIGdpdmVuIHNjb3BlIGFzIGFjdGl2ZSBzY29wZSBpbiB0aGUgZ2l2ZW4gY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIHdpdGhTY29wZShcbiAgLi4ucmVzdFxuKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICBjb25zdCBodWIgPSBnZXRDdXJyZW50SHViKCk7XG5cbiAgLy8gSWYgYSBzY29wZSBpcyBkZWZpbmVkLCB3ZSB3YW50IHRvIG1ha2UgdGhpcyB0aGUgYWN0aXZlIHNjb3BlIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgb25lXG4gIGlmIChyZXN0Lmxlbmd0aCA9PT0gMikge1xuICAgIGNvbnN0IFtzY29wZSwgY2FsbGJhY2tdID0gcmVzdDtcbiAgICBpZiAoIXNjb3BlKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgICAgIHJldHVybiBodWIud2l0aFNjb3BlKGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgICByZXR1cm4gaHViLndpdGhTY29wZSgoKSA9PiB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgICAgIGh1Yi5nZXRTdGFja1RvcCgpLnNjb3BlID0gc2NvcGUgO1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKHNjb3BlICk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgcmV0dXJuIGh1Yi53aXRoU2NvcGUocmVzdFswXSk7XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gZm9yayB0aGUgY3VycmVudCBpc29sYXRpb24gc2NvcGUgYW5kIHRoZSBjdXJyZW50IHNjb3BlIGJhc2VkIG9uIHRoZSBjdXJyZW50IGFzeW5jIGNvbnRleHQgc3RyYXRlZ3kuIElmIG5vXG4gKiBhc3luYyBjb250ZXh0IHN0cmF0ZWd5IGlzIHNldCwgdGhlIGlzb2xhdGlvbiBzY29wZSBhbmQgdGhlIGN1cnJlbnQgc2NvcGUgd2lsbCBub3QgYmUgZm9ya2VkICh0aGlzIGlzIGN1cnJlbnRseSB0aGVcbiAqIGNhc2UsIGZvciBleGFtcGxlLCBpbiB0aGUgYnJvd3NlcikuXG4gKlxuICogVXNhZ2Ugb2YgdGhpcyBmdW5jdGlvbiBpbiBlbnZpcm9ubWVudHMgd2l0aG91dCBhc3luYyBjb250ZXh0IHN0cmF0ZWd5IGlzIGRpc2NvdXJhZ2VkIGFuZCBtYXkgbGVhZCB0byB1bmV4cGVjdGVkIGJlaGF2aW91ci5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGludGVuZGVkIGZvciBTZW50cnkgU0RLIGFuZCBTREsgaW50ZWdyYXRpb24gZGV2ZWxvcG1lbnQuIEl0IGlzIG5vdCByZWNvbW1lbmRlZCB0byBiZSB1c2VkIGluIFwibm9ybWFsXCJcbiAqIGFwcGxpY2F0aW9ucyBkaXJlY3RseSBiZWNhdXNlIGl0IGNvbWVzIHdpdGggcGl0ZmFsbHMuIFVzZSBhdCB5b3VyIG93biByaXNrIVxuICpcbiAqIEBwYXJhbSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgaW4gd2hpY2ggdGhlIHBhc3NlZCBpc29sYXRpb24gc2NvcGUgaXMgYWN0aXZlLiAoTm90ZTogSW4gZW52aXJvbm1lbnRzIHdpdGhvdXQgYXN5bmNcbiAqIGNvbnRleHQgc3RyYXRlZ3ksIHRoZSBjdXJyZW50bHkgYWN0aXZlIGlzb2xhdGlvbiBzY29wZSBtYXkgY2hhbmdlIHdpdGhpbiBleGVjdXRpb24gb2YgdGhlIGNhbGxiYWNrLilcbiAqIEByZXR1cm5zIFRoZSBzYW1lIHZhbHVlIHRoYXQgYGNhbGxiYWNrYCByZXR1cm5zLlxuICovXG5mdW5jdGlvbiB3aXRoSXNvbGF0aW9uU2NvcGUoY2FsbGJhY2spIHtcbiAgcmV0dXJuIHJ1bldpdGhBc3luY0NvbnRleHQoKCkgPT4ge1xuICAgIHJldHVybiBjYWxsYmFjayhnZXRJc29sYXRpb25TY29wZSgpKTtcbiAgfSk7XG59XG5cbi8qKlxuICogRm9ya3MgdGhlIGN1cnJlbnQgc2NvcGUgYW5kIHNldHMgdGhlIHByb3ZpZGVkIHNwYW4gYXMgYWN0aXZlIHNwYW4gaW4gdGhlIGNvbnRleHQgb2YgdGhlIHByb3ZpZGVkIGNhbGxiYWNrLlxuICpcbiAqIEBwYXJhbSBzcGFuIFNwYW5zIHN0YXJ0ZWQgaW4gdGhlIGNvbnRleHQgb2YgdGhlIHByb3ZpZGVkIGNhbGxiYWNrIHdpbGwgYmUgY2hpbGRyZW4gb2YgdGhpcyBzcGFuLlxuICogQHBhcmFtIGNhbGxiYWNrIEV4ZWN1dGlvbiBjb250ZXh0IGluIHdoaWNoIHRoZSBwcm92aWRlZCBzcGFuIHdpbGwgYmUgYWN0aXZlLiBJcyBwYXNzZWQgdGhlIG5ld2x5IGZvcmtlZCBzY29wZS5cbiAqIEByZXR1cm5zIHRoZSB2YWx1ZSByZXR1cm5lZCBmcm9tIHRoZSBwcm92aWRlZCBjYWxsYmFjayBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gd2l0aEFjdGl2ZVNwYW4oc3BhbiwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHdpdGhTY29wZShzY29wZSA9PiB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gICAgc2NvcGUuc2V0U3BhbihzcGFuKTtcbiAgICByZXR1cm4gY2FsbGJhY2soc2NvcGUpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBTdGFydHMgYSBuZXcgYFRyYW5zYWN0aW9uYCBhbmQgcmV0dXJucyBpdC4gVGhpcyBpcyB0aGUgZW50cnkgcG9pbnQgdG8gbWFudWFsIHRyYWNpbmcgaW5zdHJ1bWVudGF0aW9uLlxuICpcbiAqIEEgdHJlZSBzdHJ1Y3R1cmUgY2FuIGJlIGJ1aWx0IGJ5IGFkZGluZyBjaGlsZCBzcGFucyB0byB0aGUgdHJhbnNhY3Rpb24sIGFuZCBjaGlsZCBzcGFucyB0byBvdGhlciBzcGFucy4gVG8gc3RhcnQgYVxuICogbmV3IGNoaWxkIHNwYW4gd2l0aGluIHRoZSB0cmFuc2FjdGlvbiBvciBhbnkgc3BhbiwgY2FsbCB0aGUgcmVzcGVjdGl2ZSBgLnN0YXJ0Q2hpbGQoKWAgbWV0aG9kLlxuICpcbiAqIEV2ZXJ5IGNoaWxkIHNwYW4gbXVzdCBiZSBmaW5pc2hlZCBiZWZvcmUgdGhlIHRyYW5zYWN0aW9uIGlzIGZpbmlzaGVkLCBvdGhlcndpc2UgdGhlIHVuZmluaXNoZWQgc3BhbnMgYXJlIGRpc2NhcmRlZC5cbiAqXG4gKiBUaGUgdHJhbnNhY3Rpb24gbXVzdCBiZSBmaW5pc2hlZCB3aXRoIGEgY2FsbCB0byBpdHMgYC5lbmQoKWAgbWV0aG9kLCBhdCB3aGljaCBwb2ludCB0aGUgdHJhbnNhY3Rpb24gd2l0aCBhbGwgaXRzXG4gKiBmaW5pc2hlZCBjaGlsZCBzcGFucyB3aWxsIGJlIHNlbnQgdG8gU2VudHJ5LlxuICpcbiAqIE5PVEU6IFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgKm1hbnVhbCogaW5zdHJ1bWVudGF0aW9uLiBBdXRvLWluc3RydW1lbnRhdGlvbiBzaG91bGQgY2FsbFxuICogYHN0YXJ0VHJhbnNhY3Rpb25gIGRpcmVjdGx5IG9uIHRoZSBodWIuXG4gKlxuICogQHBhcmFtIGNvbnRleHQgUHJvcGVydGllcyBvZiB0aGUgbmV3IGBUcmFuc2FjdGlvbmAuXG4gKiBAcGFyYW0gY3VzdG9tU2FtcGxpbmdDb250ZXh0IEluZm9ybWF0aW9uIGdpdmVuIHRvIHRoZSB0cmFuc2FjdGlvbiBzYW1wbGluZyBmdW5jdGlvbiAoYWxvbmcgd2l0aCBjb250ZXh0LWRlcGVuZGVudFxuICogZGVmYXVsdCB2YWx1ZXMpLiBTZWUge0BsaW5rIE9wdGlvbnMudHJhY2VzU2FtcGxlcn0uXG4gKlxuICogQHJldHVybnMgVGhlIHRyYW5zYWN0aW9uIHdoaWNoIHdhcyBqdXN0IHN0YXJ0ZWRcbiAqXG4gKiBAZGVwcmVjYXRlZCBVc2UgYHN0YXJ0U3BhbigpYCwgYHN0YXJ0U3Bhbk1hbnVhbCgpYCBvciBgc3RhcnRJbmFjdGl2ZVNwYW4oKWAgaW5zdGVhZC5cbiAqL1xuZnVuY3Rpb24gc3RhcnRUcmFuc2FjdGlvbihcbiAgY29udGV4dCxcbiAgY3VzdG9tU2FtcGxpbmdDb250ZXh0LFxuKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICByZXR1cm4gZ2V0Q3VycmVudEh1YigpLnN0YXJ0VHJhbnNhY3Rpb24oeyAuLi5jb250ZXh0IH0sIGN1c3RvbVNhbXBsaW5nQ29udGV4dCk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgY3JvbiBtb25pdG9yIGNoZWNrIGluIGFuZCBzZW5kIGl0IHRvIFNlbnRyeS5cbiAqXG4gKiBAcGFyYW0gY2hlY2tJbiBBbiBvYmplY3QgdGhhdCBkZXNjcmliZXMgYSBjaGVjayBpbi5cbiAqIEBwYXJhbSB1cHNlcnRNb25pdG9yQ29uZmlnIEFuIG9wdGlvbmFsIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBhIG1vbml0b3IgY29uZmlnLiBVc2UgdGhpcyBpZiB5b3Ugd2FudFxuICogdG8gY3JlYXRlIGEgbW9uaXRvciBhdXRvbWF0aWNhbGx5IHdoZW4gc2VuZGluZyBhIGNoZWNrIGluLlxuICovXG5mdW5jdGlvbiBjYXB0dXJlQ2hlY2tJbihjaGVja0luLCB1cHNlcnRNb25pdG9yQ29uZmlnKSB7XG4gIGNvbnN0IHNjb3BlID0gZ2V0Q3VycmVudFNjb3BlKCk7XG4gIGNvbnN0IGNsaWVudCA9IGdldENsaWVudCgpO1xuICBpZiAoIWNsaWVudCkge1xuICAgIERFQlVHX0JVSUxEICYmIGxvZ2dlci53YXJuKCdDYW5ub3QgY2FwdHVyZSBjaGVjay1pbi4gTm8gY2xpZW50IGRlZmluZWQuJyk7XG4gIH0gZWxzZSBpZiAoIWNsaWVudC5jYXB0dXJlQ2hlY2tJbikge1xuICAgIERFQlVHX0JVSUxEICYmIGxvZ2dlci53YXJuKCdDYW5ub3QgY2FwdHVyZSBjaGVjay1pbi4gQ2xpZW50IGRvZXMgbm90IHN1cHBvcnQgc2VuZGluZyBjaGVjay1pbnMuJyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNsaWVudC5jYXB0dXJlQ2hlY2tJbihjaGVja0luLCB1cHNlcnRNb25pdG9yQ29uZmlnLCBzY29wZSk7XG4gIH1cblxuICByZXR1cm4gdXVpZDQoKTtcbn1cblxuLyoqXG4gKiBXcmFwcyBhIGNhbGxiYWNrIHdpdGggYSBjcm9uIG1vbml0b3IgY2hlY2sgaW4uIFRoZSBjaGVjayBpbiB3aWxsIGJlIHNlbnQgdG8gU2VudHJ5IHdoZW4gdGhlIGNhbGxiYWNrIGZpbmlzaGVzLlxuICpcbiAqIEBwYXJhbSBtb25pdG9yU2x1ZyBUaGUgZGlzdGluY3Qgc2x1ZyBvZiB0aGUgbW9uaXRvci5cbiAqIEBwYXJhbSB1cHNlcnRNb25pdG9yQ29uZmlnIEFuIG9wdGlvbmFsIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBhIG1vbml0b3IgY29uZmlnLiBVc2UgdGhpcyBpZiB5b3Ugd2FudFxuICogdG8gY3JlYXRlIGEgbW9uaXRvciBhdXRvbWF0aWNhbGx5IHdoZW4gc2VuZGluZyBhIGNoZWNrIGluLlxuICovXG5mdW5jdGlvbiB3aXRoTW9uaXRvcihcbiAgbW9uaXRvclNsdWcsXG4gIGNhbGxiYWNrLFxuICB1cHNlcnRNb25pdG9yQ29uZmlnLFxuKSB7XG4gIGNvbnN0IGNoZWNrSW5JZCA9IGNhcHR1cmVDaGVja0luKHsgbW9uaXRvclNsdWcsIHN0YXR1czogJ2luX3Byb2dyZXNzJyB9LCB1cHNlcnRNb25pdG9yQ29uZmlnKTtcbiAgY29uc3Qgbm93ID0gdGltZXN0YW1wSW5TZWNvbmRzKCk7XG5cbiAgZnVuY3Rpb24gZmluaXNoQ2hlY2tJbihzdGF0dXMpIHtcbiAgICBjYXB0dXJlQ2hlY2tJbih7IG1vbml0b3JTbHVnLCBzdGF0dXMsIGNoZWNrSW5JZCwgZHVyYXRpb246IHRpbWVzdGFtcEluU2Vjb25kcygpIC0gbm93IH0pO1xuICB9XG5cbiAgbGV0IG1heWJlUHJvbWlzZVJlc3VsdDtcbiAgdHJ5IHtcbiAgICBtYXliZVByb21pc2VSZXN1bHQgPSBjYWxsYmFjaygpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZmluaXNoQ2hlY2tJbignZXJyb3InKTtcbiAgICB0aHJvdyBlO1xuICB9XG5cbiAgaWYgKGlzVGhlbmFibGUobWF5YmVQcm9taXNlUmVzdWx0KSkge1xuICAgIFByb21pc2UucmVzb2x2ZShtYXliZVByb21pc2VSZXN1bHQpLnRoZW4oXG4gICAgICAoKSA9PiB7XG4gICAgICAgIGZpbmlzaENoZWNrSW4oJ29rJyk7XG4gICAgICB9LFxuICAgICAgKCkgPT4ge1xuICAgICAgICBmaW5pc2hDaGVja0luKCdlcnJvcicpO1xuICAgICAgfSxcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIGZpbmlzaENoZWNrSW4oJ29rJyk7XG4gIH1cblxuICByZXR1cm4gbWF5YmVQcm9taXNlUmVzdWx0O1xufVxuXG4vKipcbiAqIENhbGwgYGZsdXNoKClgIG9uIHRoZSBjdXJyZW50IGNsaWVudCwgaWYgdGhlcmUgaXMgb25lLiBTZWUge0BsaW5rIENsaWVudC5mbHVzaH0uXG4gKlxuICogQHBhcmFtIHRpbWVvdXQgTWF4aW11bSB0aW1lIGluIG1zIHRoZSBjbGllbnQgc2hvdWxkIHdhaXQgdG8gZmx1c2ggaXRzIGV2ZW50IHF1ZXVlLiBPbWl0dGluZyB0aGlzIHBhcmFtZXRlciB3aWxsIGNhdXNlXG4gKiB0aGUgY2xpZW50IHRvIHdhaXQgdW50aWwgYWxsIGV2ZW50cyBhcmUgc2VudCBiZWZvcmUgcmVzb2x2aW5nIHRoZSBwcm9taXNlLlxuICogQHJldHVybnMgQSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIGB0cnVlYCBpZiB0aGUgcXVldWUgc3VjY2Vzc2Z1bGx5IGRyYWlucyBiZWZvcmUgdGhlIHRpbWVvdXQsIG9yIGBmYWxzZWAgaWYgaXRcbiAqIGRvZXNuJ3QgKG9yIGlmIHRoZXJlJ3Mgbm8gY2xpZW50IGRlZmluZWQpLlxuICovXG5hc3luYyBmdW5jdGlvbiBmbHVzaCh0aW1lb3V0KSB7XG4gIGNvbnN0IGNsaWVudCA9IGdldENsaWVudCgpO1xuICBpZiAoY2xpZW50KSB7XG4gICAgcmV0dXJuIGNsaWVudC5mbHVzaCh0aW1lb3V0KTtcbiAgfVxuICBERUJVR19CVUlMRCAmJiBsb2dnZXIud2FybignQ2Fubm90IGZsdXNoIGV2ZW50cy4gTm8gY2xpZW50IGRlZmluZWQuJyk7XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xufVxuXG4vKipcbiAqIENhbGwgYGNsb3NlKClgIG9uIHRoZSBjdXJyZW50IGNsaWVudCwgaWYgdGhlcmUgaXMgb25lLiBTZWUge0BsaW5rIENsaWVudC5jbG9zZX0uXG4gKlxuICogQHBhcmFtIHRpbWVvdXQgTWF4aW11bSB0aW1lIGluIG1zIHRoZSBjbGllbnQgc2hvdWxkIHdhaXQgdG8gZmx1c2ggaXRzIGV2ZW50IHF1ZXVlIGJlZm9yZSBzaHV0dGluZyBkb3duLiBPbWl0dGluZyB0aGlzXG4gKiBwYXJhbWV0ZXIgd2lsbCBjYXVzZSB0aGUgY2xpZW50IHRvIHdhaXQgdW50aWwgYWxsIGV2ZW50cyBhcmUgc2VudCBiZWZvcmUgZGlzYWJsaW5nIGl0c2VsZi5cbiAqIEByZXR1cm5zIEEgcHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byBgdHJ1ZWAgaWYgdGhlIHF1ZXVlIHN1Y2Nlc3NmdWxseSBkcmFpbnMgYmVmb3JlIHRoZSB0aW1lb3V0LCBvciBgZmFsc2VgIGlmIGl0XG4gKiBkb2Vzbid0IChvciBpZiB0aGVyZSdzIG5vIGNsaWVudCBkZWZpbmVkKS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gY2xvc2UodGltZW91dCkge1xuICBjb25zdCBjbGllbnQgPSBnZXRDbGllbnQoKTtcbiAgaWYgKGNsaWVudCkge1xuICAgIHJldHVybiBjbGllbnQuY2xvc2UodGltZW91dCk7XG4gIH1cbiAgREVCVUdfQlVJTEQgJiYgbG9nZ2VyLndhcm4oJ0Nhbm5vdCBmbHVzaCBldmVudHMgYW5kIGRpc2FibGUgU0RLLiBObyBjbGllbnQgZGVmaW5lZC4nKTtcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG59XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgZ2V0dGVyIGZvciBsYXN0RXZlbnRJZC5cbiAqXG4gKiBAcmV0dXJucyBUaGUgbGFzdCBldmVudCBpZCBvZiBhIGNhcHR1cmVkIGV2ZW50LlxuICogQGRlcHJlY2F0ZWQgVGhpcyBmdW5jdGlvbiB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiB0aGUgU2VudHJ5IFNESy5cbiAqL1xuZnVuY3Rpb24gbGFzdEV2ZW50SWQoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICByZXR1cm4gZ2V0Q3VycmVudEh1YigpLmxhc3RFdmVudElkKCk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50bHkgYWN0aXZlIGNsaWVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0Q2xpZW50KCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgcmV0dXJuIGdldEN1cnJlbnRIdWIoKS5nZXRDbGllbnQoKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgU2VudHJ5IGhhcyBiZWVuIHByb3Blcmx5IGluaXRpYWxpemVkLlxuICovXG5mdW5jdGlvbiBpc0luaXRpYWxpemVkKCkge1xuICByZXR1cm4gISFnZXRDbGllbnQoKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnRseSBhY3RpdmUgc2NvcGUuXG4gKi9cbmZ1bmN0aW9uIGdldEN1cnJlbnRTY29wZSgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gIHJldHVybiBnZXRDdXJyZW50SHViKCkuZ2V0U2NvcGUoKTtcbn1cblxuLyoqXG4gKiBTdGFydCBhIHNlc3Npb24gb24gdGhlIGN1cnJlbnQgaXNvbGF0aW9uIHNjb3BlLlxuICpcbiAqIEBwYXJhbSBjb250ZXh0IChvcHRpb25hbCkgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIHJldHVybmVkIHNlc3Npb24gb2JqZWN0XG4gKlxuICogQHJldHVybnMgdGhlIG5ldyBhY3RpdmUgc2Vzc2lvblxuICovXG5mdW5jdGlvbiBzdGFydFNlc3Npb24oY29udGV4dCkge1xuICBjb25zdCBjbGllbnQgPSBnZXRDbGllbnQoKTtcbiAgY29uc3QgaXNvbGF0aW9uU2NvcGUgPSBnZXRJc29sYXRpb25TY29wZSgpO1xuICBjb25zdCBjdXJyZW50U2NvcGUgPSBnZXRDdXJyZW50U2NvcGUoKTtcblxuICBjb25zdCB7IHJlbGVhc2UsIGVudmlyb25tZW50ID0gREVGQVVMVF9FTlZJUk9OTUVOVCB9ID0gKGNsaWVudCAmJiBjbGllbnQuZ2V0T3B0aW9ucygpKSB8fCB7fTtcblxuICAvLyBXaWxsIGZldGNoIHVzZXJBZ2VudCBpZiBjYWxsZWQgZnJvbSBicm93c2VyIHNka1xuICBjb25zdCB7IHVzZXJBZ2VudCB9ID0gR0xPQkFMX09CSi5uYXZpZ2F0b3IgfHwge307XG5cbiAgY29uc3Qgc2Vzc2lvbiA9IG1ha2VTZXNzaW9uKHtcbiAgICByZWxlYXNlLFxuICAgIGVudmlyb25tZW50LFxuICAgIHVzZXI6IGN1cnJlbnRTY29wZS5nZXRVc2VyKCkgfHwgaXNvbGF0aW9uU2NvcGUuZ2V0VXNlcigpLFxuICAgIC4uLih1c2VyQWdlbnQgJiYgeyB1c2VyQWdlbnQgfSksXG4gICAgLi4uY29udGV4dCxcbiAgfSk7XG5cbiAgLy8gRW5kIGV4aXN0aW5nIHNlc3Npb24gaWYgdGhlcmUncyBvbmVcbiAgY29uc3QgY3VycmVudFNlc3Npb24gPSBpc29sYXRpb25TY29wZS5nZXRTZXNzaW9uKCk7XG4gIGlmIChjdXJyZW50U2Vzc2lvbiAmJiBjdXJyZW50U2Vzc2lvbi5zdGF0dXMgPT09ICdvaycpIHtcbiAgICB1cGRhdGVTZXNzaW9uKGN1cnJlbnRTZXNzaW9uLCB7IHN0YXR1czogJ2V4aXRlZCcgfSk7XG4gIH1cblxuICBlbmRTZXNzaW9uKCk7XG5cbiAgLy8gQWZ0ZXJ3YXJkcyB3ZSBzZXQgdGhlIG5ldyBzZXNzaW9uIG9uIHRoZSBzY29wZVxuICBpc29sYXRpb25TY29wZS5zZXRTZXNzaW9uKHNlc3Npb24pO1xuXG4gIC8vIFRPRE8gKHY4KTogUmVtb3ZlIHRoaXMgYW5kIG9ubHkgdXNlIHRoZSBpc29sYXRpb24gc2NvcGUoPykuXG4gIC8vIEZvciB2NyB0aG91Z2gsIHdlIGNhbid0IFwic29mdC1icmVha1wiIHBlb3BsZSB1c2luZyBnZXRDdXJyZW50SHViKCkuZ2V0U2NvcGUoKS5zZXRTZXNzaW9uKClcbiAgY3VycmVudFNjb3BlLnNldFNlc3Npb24oc2Vzc2lvbik7XG5cbiAgcmV0dXJuIHNlc3Npb247XG59XG5cbi8qKlxuICogRW5kIHRoZSBzZXNzaW9uIG9uIHRoZSBjdXJyZW50IGlzb2xhdGlvbiBzY29wZS5cbiAqL1xuZnVuY3Rpb24gZW5kU2Vzc2lvbigpIHtcbiAgY29uc3QgaXNvbGF0aW9uU2NvcGUgPSBnZXRJc29sYXRpb25TY29wZSgpO1xuICBjb25zdCBjdXJyZW50U2NvcGUgPSBnZXRDdXJyZW50U2NvcGUoKTtcblxuICBjb25zdCBzZXNzaW9uID0gY3VycmVudFNjb3BlLmdldFNlc3Npb24oKSB8fCBpc29sYXRpb25TY29wZS5nZXRTZXNzaW9uKCk7XG4gIGlmIChzZXNzaW9uKSB7XG4gICAgY2xvc2VTZXNzaW9uKHNlc3Npb24pO1xuICB9XG4gIF9zZW5kU2Vzc2lvblVwZGF0ZSgpO1xuXG4gIC8vIHRoZSBzZXNzaW9uIGlzIG92ZXI7IHRha2UgaXQgb2ZmIG9mIHRoZSBzY29wZVxuICBpc29sYXRpb25TY29wZS5zZXRTZXNzaW9uKCk7XG5cbiAgLy8gVE9ETyAodjgpOiBSZW1vdmUgdGhpcyBhbmQgb25seSB1c2UgdGhlIGlzb2xhdGlvbiBzY29wZSg/KS5cbiAgLy8gRm9yIHY3IHRob3VnaCwgd2UgY2FuJ3QgXCJzb2Z0LWJyZWFrXCIgcGVvcGxlIHVzaW5nIGdldEN1cnJlbnRIdWIoKS5nZXRTY29wZSgpLnNldFNlc3Npb24oKVxuICBjdXJyZW50U2NvcGUuc2V0U2Vzc2lvbigpO1xufVxuXG4vKipcbiAqIFNlbmRzIHRoZSBjdXJyZW50IFNlc3Npb24gb24gdGhlIHNjb3BlXG4gKi9cbmZ1bmN0aW9uIF9zZW5kU2Vzc2lvblVwZGF0ZSgpIHtcbiAgY29uc3QgaXNvbGF0aW9uU2NvcGUgPSBnZXRJc29sYXRpb25TY29wZSgpO1xuICBjb25zdCBjdXJyZW50U2NvcGUgPSBnZXRDdXJyZW50U2NvcGUoKTtcbiAgY29uc3QgY2xpZW50ID0gZ2V0Q2xpZW50KCk7XG4gIC8vIFRPRE8gKHY4KTogUmVtb3ZlIGN1cnJlbnRTY29wZSBhbmQgb25seSB1c2UgdGhlIGlzb2xhdGlvbiBzY29wZSg/KS5cbiAgLy8gRm9yIHY3IHRob3VnaCwgd2UgY2FuJ3QgXCJzb2Z0LWJyZWFrXCIgcGVvcGxlIHVzaW5nIGdldEN1cnJlbnRIdWIoKS5nZXRTY29wZSgpLnNldFNlc3Npb24oKVxuICBjb25zdCBzZXNzaW9uID0gY3VycmVudFNjb3BlLmdldFNlc3Npb24oKSB8fCBpc29sYXRpb25TY29wZS5nZXRTZXNzaW9uKCk7XG4gIGlmIChzZXNzaW9uICYmIGNsaWVudCAmJiBjbGllbnQuY2FwdHVyZVNlc3Npb24pIHtcbiAgICBjbGllbnQuY2FwdHVyZVNlc3Npb24oc2Vzc2lvbik7XG4gIH1cbn1cblxuLyoqXG4gKiBTZW5kcyB0aGUgY3VycmVudCBzZXNzaW9uIG9uIHRoZSBzY29wZSB0byBTZW50cnlcbiAqXG4gKiBAcGFyYW0gZW5kIElmIHNldCB0aGUgc2Vzc2lvbiB3aWxsIGJlIG1hcmtlZCBhcyBleGl0ZWQgYW5kIHJlbW92ZWQgZnJvbSB0aGUgc2NvcGUuXG4gKiAgICAgICAgICAgIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGNhcHR1cmVTZXNzaW9uKGVuZCA9IGZhbHNlKSB7XG4gIC8vIGJvdGggc2VuZCB0aGUgdXBkYXRlIGFuZCBwdWxsIHRoZSBzZXNzaW9uIGZyb20gdGhlIHNjb3BlXG4gIGlmIChlbmQpIHtcbiAgICBlbmRTZXNzaW9uKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gb25seSBzZW5kIHRoZSB1cGRhdGVcbiAgX3NlbmRTZXNzaW9uVXBkYXRlKCk7XG59XG5cbmV4cG9ydCB7IGFkZEJyZWFkY3J1bWIsIGNhcHR1cmVDaGVja0luLCBjYXB0dXJlRXZlbnQsIGNhcHR1cmVFeGNlcHRpb24sIGNhcHR1cmVNZXNzYWdlLCBjYXB0dXJlU2Vzc2lvbiwgY2xvc2UsIGNvbmZpZ3VyZVNjb3BlLCBlbmRTZXNzaW9uLCBmbHVzaCwgZ2V0Q2xpZW50LCBnZXRDdXJyZW50U2NvcGUsIGlzSW5pdGlhbGl6ZWQsIGxhc3RFdmVudElkLCBzZXRDb250ZXh0LCBzZXRFeHRyYSwgc2V0RXh0cmFzLCBzZXRUYWcsIHNldFRhZ3MsIHNldFVzZXIsIHN0YXJ0U2Vzc2lvbiwgc3RhcnRUcmFuc2FjdGlvbiwgd2l0aEFjdGl2ZVNwYW4sIHdpdGhJc29sYXRpb25TY29wZSwgd2l0aE1vbml0b3IsIHdpdGhTY29wZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXhwb3J0cy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJsb2dnZXIiLCJ1dWlkNCIsInRpbWVzdGFtcEluU2Vjb25kcyIsImlzVGhlbmFibGUiLCJHTE9CQUxfT0JKIiwiREVGQVVMVF9FTlZJUk9OTUVOVCIsIkRFQlVHX0JVSUxEIiwiZ2V0Q3VycmVudEh1YiIsInJ1bldpdGhBc3luY0NvbnRleHQiLCJnZXRJc29sYXRpb25TY29wZSIsIm1ha2VTZXNzaW9uIiwidXBkYXRlU2Vzc2lvbiIsImNsb3NlU2Vzc2lvbiIsInBhcnNlRXZlbnRIaW50T3JDYXB0dXJlQ29udGV4dCIsImNhcHR1cmVFeGNlcHRpb24iLCJleGNlcHRpb24iLCJoaW50IiwiY2FwdHVyZU1lc3NhZ2UiLCJtZXNzYWdlIiwiY2FwdHVyZUNvbnRleHQiLCJsZXZlbCIsInVuZGVmaW5lZCIsImNvbnRleHQiLCJjYXB0dXJlRXZlbnQiLCJldmVudCIsImNvbmZpZ3VyZVNjb3BlIiwiY2FsbGJhY2siLCJhZGRCcmVhZGNydW1iIiwiYnJlYWRjcnVtYiIsInNldENvbnRleHQiLCJuYW1lIiwic2V0RXh0cmFzIiwiZXh0cmFzIiwic2V0RXh0cmEiLCJrZXkiLCJleHRyYSIsInNldFRhZ3MiLCJ0YWdzIiwic2V0VGFnIiwidmFsdWUiLCJzZXRVc2VyIiwidXNlciIsIndpdGhTY29wZSIsInJlc3QiLCJodWIiLCJsZW5ndGgiLCJzY29wZSIsImdldFN0YWNrVG9wIiwid2l0aElzb2xhdGlvblNjb3BlIiwid2l0aEFjdGl2ZVNwYW4iLCJzcGFuIiwic2V0U3BhbiIsInN0YXJ0VHJhbnNhY3Rpb24iLCJjdXN0b21TYW1wbGluZ0NvbnRleHQiLCJjYXB0dXJlQ2hlY2tJbiIsImNoZWNrSW4iLCJ1cHNlcnRNb25pdG9yQ29uZmlnIiwiZ2V0Q3VycmVudFNjb3BlIiwiY2xpZW50IiwiZ2V0Q2xpZW50Iiwid2FybiIsIndpdGhNb25pdG9yIiwibW9uaXRvclNsdWciLCJjaGVja0luSWQiLCJzdGF0dXMiLCJub3ciLCJmaW5pc2hDaGVja0luIiwiZHVyYXRpb24iLCJtYXliZVByb21pc2VSZXN1bHQiLCJlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwiZmx1c2giLCJ0aW1lb3V0IiwiY2xvc2UiLCJsYXN0RXZlbnRJZCIsImlzSW5pdGlhbGl6ZWQiLCJnZXRTY29wZSIsInN0YXJ0U2Vzc2lvbiIsImlzb2xhdGlvblNjb3BlIiwiY3VycmVudFNjb3BlIiwicmVsZWFzZSIsImVudmlyb25tZW50IiwiZ2V0T3B0aW9ucyIsInVzZXJBZ2VudCIsIm5hdmlnYXRvciIsInNlc3Npb24iLCJnZXRVc2VyIiwiY3VycmVudFNlc3Npb24iLCJnZXRTZXNzaW9uIiwiZW5kU2Vzc2lvbiIsInNldFNlc3Npb24iLCJfc2VuZFNlc3Npb25VcGRhdGUiLCJjYXB0dXJlU2Vzc2lvbiIsImVuZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/core/esm/exports.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sentry/core/esm/hub.js":
/*!**********************************************!*\
  !*** ./node_modules/@sentry/core/esm/hub.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   API_VERSION: () => (/* binding */ API_VERSION),\n/* harmony export */   Hub: () => (/* binding */ Hub),\n/* harmony export */   ensureHubOnCarrier: () => (/* binding */ ensureHubOnCarrier),\n/* harmony export */   getCurrentHub: () => (/* binding */ getCurrentHub),\n/* harmony export */   getHubFromCarrier: () => (/* binding */ getHubFromCarrier),\n/* harmony export */   getIsolationScope: () => (/* binding */ getIsolationScope),\n/* harmony export */   getMainCarrier: () => (/* binding */ getMainCarrier),\n/* harmony export */   makeMain: () => (/* binding */ makeMain),\n/* harmony export */   runWithAsyncContext: () => (/* binding */ runWithAsyncContext),\n/* harmony export */   setAsyncContextStrategy: () => (/* binding */ setAsyncContextStrategy),\n/* harmony export */   setHubOnCarrier: () => (/* binding */ setHubOnCarrier)\n/* harmony export */ });\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sentry/utils */ \"(ssr)/./node_modules/@sentry/utils/esm/is.js\");\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @sentry/utils */ \"(ssr)/./node_modules/@sentry/utils/esm/misc.js\");\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @sentry/utils */ \"(ssr)/./node_modules/@sentry/utils/esm/time.js\");\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @sentry/utils */ \"(ssr)/./node_modules/@sentry/utils/esm/logger.js\");\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @sentry/utils */ \"(ssr)/./node_modules/@sentry/utils/esm/worldwide.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./constants.js */ \"(ssr)/./node_modules/@sentry/core/esm/constants.js\");\n/* harmony import */ var _debug_build_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./debug-build.js */ \"(ssr)/./node_modules/@sentry/core/esm/debug-build.js\");\n/* harmony import */ var _scope_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scope.js */ \"(ssr)/./node_modules/@sentry/core/esm/scope.js\");\n/* harmony import */ var _session_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./session.js */ \"(ssr)/./node_modules/@sentry/core/esm/session.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./version.js */ \"(ssr)/./node_modules/@sentry/core/esm/version.js\");\n\n\n\n\n\n\n/**\n * API compatibility version of this hub.\n *\n * WARNING: This number should only be increased when the global interface\n * changes and new methods are introduced.\n *\n * @hidden\n */ const API_VERSION = parseFloat(_version_js__WEBPACK_IMPORTED_MODULE_0__.SDK_VERSION);\n/**\n * Default maximum number of breadcrumbs added to an event. Can be overwritten\n * with {@link Options.maxBreadcrumbs}.\n */ const DEFAULT_BREADCRUMBS = 100;\n/**\n * @inheritDoc\n */ class Hub {\n    /** Is a {@link Layer}[] containing the client and scope */ /** Contains the last event id of a captured event.  */ /**\n   * Creates a new instance of the hub, will push one {@link Layer} into the\n   * internal stack on creation.\n   *\n   * @param client bound to the hub.\n   * @param scope bound to the hub.\n   * @param version number, higher number means higher priority.\n   *\n   * @deprecated Instantiation of Hub objects is deprecated and the constructor will be removed in version 8 of the SDK.\n   *\n   * If you are currently using the Hub for multi-client use like so:\n   *\n   * ```\n   * // OLD\n   * const hub = new Hub();\n   * hub.bindClient(client);\n   * makeMain(hub)\n   * ```\n   *\n   * instead initialize the client as follows:\n   *\n   * ```\n   * // NEW\n   * Sentry.withIsolationScope(() => {\n   *    Sentry.setCurrentClient(client);\n   *    client.init();\n   * });\n   * ```\n   *\n   * If you are using the Hub to capture events like so:\n   *\n   * ```\n   * // OLD\n   * const client = new Client();\n   * const hub = new Hub(client);\n   * hub.captureException()\n   * ```\n   *\n   * instead capture isolated events as follows:\n   *\n   * ```\n   * // NEW\n   * const client = new Client();\n   * const scope = new Scope();\n   * scope.setClient(client);\n   * scope.captureException();\n   * ```\n   */ constructor(client, scope, isolationScope, _version = API_VERSION){\n        this._version = _version;\n        let assignedScope;\n        if (!scope) {\n            assignedScope = new _scope_js__WEBPACK_IMPORTED_MODULE_1__.Scope();\n            assignedScope.setClient(client);\n        } else {\n            assignedScope = scope;\n        }\n        let assignedIsolationScope;\n        if (!isolationScope) {\n            assignedIsolationScope = new _scope_js__WEBPACK_IMPORTED_MODULE_1__.Scope();\n            assignedIsolationScope.setClient(client);\n        } else {\n            assignedIsolationScope = isolationScope;\n        }\n        this._stack = [\n            {\n                scope: assignedScope\n            }\n        ];\n        if (client) {\n            // eslint-disable-next-line deprecation/deprecation\n            this.bindClient(client);\n        }\n        this._isolationScope = assignedIsolationScope;\n    }\n    /**\n   * Checks if this hub's version is older than the given version.\n   *\n   * @param version A version number to compare to.\n   * @return True if the given version is newer; otherwise false.\n   *\n   * @deprecated This will be removed in v8.\n   */ isOlderThan(version) {\n        return this._version < version;\n    }\n    /**\n   * This binds the given client to the current scope.\n   * @param client An SDK client (client) instance.\n   *\n   * @deprecated Use `initAndBind()` directly, or `setCurrentClient()` and/or `client.init()` instead.\n   */ bindClient(client) {\n        // eslint-disable-next-line deprecation/deprecation\n        const top = this.getStackTop();\n        top.client = client;\n        top.scope.setClient(client);\n        // eslint-disable-next-line deprecation/deprecation\n        if (client && client.setupIntegrations) {\n            // eslint-disable-next-line deprecation/deprecation\n            client.setupIntegrations();\n        }\n    }\n    /**\n   * @inheritDoc\n   *\n   * @deprecated Use `withScope` instead.\n   */ pushScope() {\n        // We want to clone the content of prev scope\n        // eslint-disable-next-line deprecation/deprecation\n        const scope = this.getScope().clone();\n        // eslint-disable-next-line deprecation/deprecation\n        this.getStack().push({\n            // eslint-disable-next-line deprecation/deprecation\n            client: this.getClient(),\n            scope\n        });\n        return scope;\n    }\n    /**\n   * @inheritDoc\n   *\n   * @deprecated Use `withScope` instead.\n   */ popScope() {\n        // eslint-disable-next-line deprecation/deprecation\n        if (this.getStack().length <= 1) return false;\n        // eslint-disable-next-line deprecation/deprecation\n        return !!this.getStack().pop();\n    }\n    /**\n   * @inheritDoc\n   *\n   * @deprecated Use `Sentry.withScope()` instead.\n   */ withScope(callback) {\n        // eslint-disable-next-line deprecation/deprecation\n        const scope = this.pushScope();\n        let maybePromiseResult;\n        try {\n            maybePromiseResult = callback(scope);\n        } catch (e) {\n            // eslint-disable-next-line deprecation/deprecation\n            this.popScope();\n            throw e;\n        }\n        if ((0,_sentry_utils__WEBPACK_IMPORTED_MODULE_2__.isThenable)(maybePromiseResult)) {\n            // @ts-expect-error - isThenable returns the wrong type\n            return maybePromiseResult.then((res)=>{\n                // eslint-disable-next-line deprecation/deprecation\n                this.popScope();\n                return res;\n            }, (e)=>{\n                // eslint-disable-next-line deprecation/deprecation\n                this.popScope();\n                throw e;\n            });\n        }\n        // eslint-disable-next-line deprecation/deprecation\n        this.popScope();\n        return maybePromiseResult;\n    }\n    /**\n   * @inheritDoc\n   *\n   * @deprecated Use `Sentry.getClient()` instead.\n   */ getClient() {\n        // eslint-disable-next-line deprecation/deprecation\n        return this.getStackTop().client;\n    }\n    /**\n   * Returns the scope of the top stack.\n   *\n   * @deprecated Use `Sentry.getCurrentScope()` instead.\n   */ getScope() {\n        // eslint-disable-next-line deprecation/deprecation\n        return this.getStackTop().scope;\n    }\n    /**\n   * @deprecated Use `Sentry.getIsolationScope()` instead.\n   */ getIsolationScope() {\n        return this._isolationScope;\n    }\n    /**\n   * Returns the scope stack for domains or the process.\n   * @deprecated This will be removed in v8.\n   */ getStack() {\n        return this._stack;\n    }\n    /**\n   * Returns the topmost scope layer in the order domain > local > process.\n   * @deprecated This will be removed in v8.\n   */ getStackTop() {\n        return this._stack[this._stack.length - 1];\n    }\n    /**\n   * @inheritDoc\n   *\n   * @deprecated Use `Sentry.captureException()` instead.\n   */ captureException(exception, hint) {\n        const eventId = this._lastEventId = hint && hint.event_id ? hint.event_id : (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_3__.uuid4)();\n        const syntheticException = new Error(\"Sentry syntheticException\");\n        // eslint-disable-next-line deprecation/deprecation\n        this.getScope().captureException(exception, {\n            originalException: exception,\n            syntheticException,\n            ...hint,\n            event_id: eventId\n        });\n        return eventId;\n    }\n    /**\n   * @inheritDoc\n   *\n   * @deprecated Use  `Sentry.captureMessage()` instead.\n   */ captureMessage(message, // eslint-disable-next-line deprecation/deprecation\n    level, hint) {\n        const eventId = this._lastEventId = hint && hint.event_id ? hint.event_id : (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_3__.uuid4)();\n        const syntheticException = new Error(message);\n        // eslint-disable-next-line deprecation/deprecation\n        this.getScope().captureMessage(message, level, {\n            originalException: message,\n            syntheticException,\n            ...hint,\n            event_id: eventId\n        });\n        return eventId;\n    }\n    /**\n   * @inheritDoc\n   *\n   * @deprecated Use `Sentry.captureEvent()` instead.\n   */ captureEvent(event, hint) {\n        const eventId = hint && hint.event_id ? hint.event_id : (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_3__.uuid4)();\n        if (!event.type) {\n            this._lastEventId = eventId;\n        }\n        // eslint-disable-next-line deprecation/deprecation\n        this.getScope().captureEvent(event, {\n            ...hint,\n            event_id: eventId\n        });\n        return eventId;\n    }\n    /**\n   * @inheritDoc\n   *\n   * @deprecated This will be removed in v8.\n   */ lastEventId() {\n        return this._lastEventId;\n    }\n    /**\n   * @inheritDoc\n   *\n   * @deprecated Use `Sentry.addBreadcrumb()` instead.\n   */ addBreadcrumb(breadcrumb, hint) {\n        // eslint-disable-next-line deprecation/deprecation\n        const { scope, client } = this.getStackTop();\n        if (!client) return;\n        const { beforeBreadcrumb = null, maxBreadcrumbs = DEFAULT_BREADCRUMBS } = client.getOptions && client.getOptions() || {};\n        if (maxBreadcrumbs <= 0) return;\n        const timestamp = (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_4__.dateTimestampInSeconds)();\n        const mergedBreadcrumb = {\n            timestamp,\n            ...breadcrumb\n        };\n        const finalBreadcrumb = beforeBreadcrumb ? (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_5__.consoleSandbox)(()=>beforeBreadcrumb(mergedBreadcrumb, hint)) : mergedBreadcrumb;\n        if (finalBreadcrumb === null) return;\n        if (client.emit) {\n            client.emit(\"beforeAddBreadcrumb\", finalBreadcrumb, hint);\n        }\n        // TODO(v8): I know this comment doesn't make much sense because the hub will be deprecated but I still wanted to\n        // write it down. In theory, we would have to add the breadcrumbs to the isolation scope here, however, that would\n        // duplicate all of the breadcrumbs. There was the possibility of adding breadcrumbs to both, the isolation scope\n        // and the normal scope, and deduplicating it down the line in the event processing pipeline. However, that would\n        // have been very fragile, because the breadcrumb objects would have needed to keep their identity all throughout\n        // the event processing pipeline.\n        // In the new implementation, the top level `Sentry.addBreadcrumb()` should ONLY write to the isolation scope.\n        scope.addBreadcrumb(finalBreadcrumb, maxBreadcrumbs);\n    }\n    /**\n   * @inheritDoc\n   * @deprecated Use `Sentry.setUser()` instead.\n   */ setUser(user) {\n        // TODO(v8): The top level `Sentry.setUser()` function should write ONLY to the isolation scope.\n        // eslint-disable-next-line deprecation/deprecation\n        this.getScope().setUser(user);\n        // eslint-disable-next-line deprecation/deprecation\n        this.getIsolationScope().setUser(user);\n    }\n    /**\n   * @inheritDoc\n   * @deprecated Use `Sentry.setTags()` instead.\n   */ setTags(tags) {\n        // TODO(v8): The top level `Sentry.setTags()` function should write ONLY to the isolation scope.\n        // eslint-disable-next-line deprecation/deprecation\n        this.getScope().setTags(tags);\n        // eslint-disable-next-line deprecation/deprecation\n        this.getIsolationScope().setTags(tags);\n    }\n    /**\n   * @inheritDoc\n   * @deprecated Use `Sentry.setExtras()` instead.\n   */ setExtras(extras) {\n        // TODO(v8): The top level `Sentry.setExtras()` function should write ONLY to the isolation scope.\n        // eslint-disable-next-line deprecation/deprecation\n        this.getScope().setExtras(extras);\n        // eslint-disable-next-line deprecation/deprecation\n        this.getIsolationScope().setExtras(extras);\n    }\n    /**\n   * @inheritDoc\n   * @deprecated Use `Sentry.setTag()` instead.\n   */ setTag(key, value) {\n        // TODO(v8): The top level `Sentry.setTag()` function should write ONLY to the isolation scope.\n        // eslint-disable-next-line deprecation/deprecation\n        this.getScope().setTag(key, value);\n        // eslint-disable-next-line deprecation/deprecation\n        this.getIsolationScope().setTag(key, value);\n    }\n    /**\n   * @inheritDoc\n   * @deprecated Use `Sentry.setExtra()` instead.\n   */ setExtra(key, extra) {\n        // TODO(v8): The top level `Sentry.setExtra()` function should write ONLY to the isolation scope.\n        // eslint-disable-next-line deprecation/deprecation\n        this.getScope().setExtra(key, extra);\n        // eslint-disable-next-line deprecation/deprecation\n        this.getIsolationScope().setExtra(key, extra);\n    }\n    /**\n   * @inheritDoc\n   * @deprecated Use `Sentry.setContext()` instead.\n   */ // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    setContext(name, context) {\n        // TODO(v8): The top level `Sentry.setContext()` function should write ONLY to the isolation scope.\n        // eslint-disable-next-line deprecation/deprecation\n        this.getScope().setContext(name, context);\n        // eslint-disable-next-line deprecation/deprecation\n        this.getIsolationScope().setContext(name, context);\n    }\n    /**\n   * @inheritDoc\n   *\n   * @deprecated Use `getScope()` directly.\n   */ configureScope(callback) {\n        // eslint-disable-next-line deprecation/deprecation\n        const { scope, client } = this.getStackTop();\n        if (client) {\n            callback(scope);\n        }\n    }\n    /**\n   * @inheritDoc\n   */ run(callback) {\n        // eslint-disable-next-line deprecation/deprecation\n        const oldHub = makeMain(this);\n        try {\n            callback(this);\n        } finally{\n            // eslint-disable-next-line deprecation/deprecation\n            makeMain(oldHub);\n        }\n    }\n    /**\n   * @inheritDoc\n   * @deprecated Use `Sentry.getClient().getIntegrationByName()` instead.\n   */ getIntegration(integration) {\n        // eslint-disable-next-line deprecation/deprecation\n        const client = this.getClient();\n        if (!client) return null;\n        try {\n            // eslint-disable-next-line deprecation/deprecation\n            return client.getIntegration(integration);\n        } catch (_oO) {\n            _debug_build_js__WEBPACK_IMPORTED_MODULE_6__.DEBUG_BUILD && _sentry_utils__WEBPACK_IMPORTED_MODULE_5__.logger.warn(`Cannot retrieve integration ${integration.id} from the current Hub`);\n            return null;\n        }\n    }\n    /**\n   * Starts a new `Transaction` and returns it. This is the entry point to manual tracing instrumentation.\n   *\n   * A tree structure can be built by adding child spans to the transaction, and child spans to other spans. To start a\n   * new child span within the transaction or any span, call the respective `.startChild()` method.\n   *\n   * Every child span must be finished before the transaction is finished, otherwise the unfinished spans are discarded.\n   *\n   * The transaction must be finished with a call to its `.end()` method, at which point the transaction with all its\n   * finished child spans will be sent to Sentry.\n   *\n   * @param context Properties of the new `Transaction`.\n   * @param customSamplingContext Information given to the transaction sampling function (along with context-dependent\n   * default values). See {@link Options.tracesSampler}.\n   *\n   * @returns The transaction which was just started\n   *\n   * @deprecated Use `startSpan()`, `startSpanManual()` or `startInactiveSpan()` instead.\n   */ startTransaction(context, customSamplingContext) {\n        const result = this._callExtensionMethod(\"startTransaction\", context, customSamplingContext);\n        if (_debug_build_js__WEBPACK_IMPORTED_MODULE_6__.DEBUG_BUILD && !result) {\n            // eslint-disable-next-line deprecation/deprecation\n            const client = this.getClient();\n            if (!client) {\n                _sentry_utils__WEBPACK_IMPORTED_MODULE_5__.logger.warn(\"Tracing extension 'startTransaction' is missing. You should 'init' the SDK before calling 'startTransaction'\");\n            } else {\n                _sentry_utils__WEBPACK_IMPORTED_MODULE_5__.logger.warn(`Tracing extension 'startTransaction' has not been added. Call 'addTracingExtensions' before calling 'init':\nSentry.addTracingExtensions();\nSentry.init({...});\n`);\n            }\n        }\n        return result;\n    }\n    /**\n   * @inheritDoc\n   * @deprecated Use `spanToTraceHeader()` instead.\n   */ traceHeaders() {\n        return this._callExtensionMethod(\"traceHeaders\");\n    }\n    /**\n   * @inheritDoc\n   *\n   * @deprecated Use top level `captureSession` instead.\n   */ captureSession(endSession = false) {\n        // both send the update and pull the session from the scope\n        if (endSession) {\n            // eslint-disable-next-line deprecation/deprecation\n            return this.endSession();\n        }\n        // only send the update\n        this._sendSessionUpdate();\n    }\n    /**\n   * @inheritDoc\n   * @deprecated Use top level `endSession` instead.\n   */ endSession() {\n        // eslint-disable-next-line deprecation/deprecation\n        const layer = this.getStackTop();\n        const scope = layer.scope;\n        const session = scope.getSession();\n        if (session) {\n            (0,_session_js__WEBPACK_IMPORTED_MODULE_7__.closeSession)(session);\n        }\n        this._sendSessionUpdate();\n        // the session is over; take it off of the scope\n        scope.setSession();\n    }\n    /**\n   * @inheritDoc\n   * @deprecated Use top level `startSession` instead.\n   */ startSession(context) {\n        // eslint-disable-next-line deprecation/deprecation\n        const { scope, client } = this.getStackTop();\n        const { release, environment = _constants_js__WEBPACK_IMPORTED_MODULE_8__.DEFAULT_ENVIRONMENT } = client && client.getOptions() || {};\n        // Will fetch userAgent if called from browser sdk\n        const { userAgent } = _sentry_utils__WEBPACK_IMPORTED_MODULE_9__.GLOBAL_OBJ.navigator || {};\n        const session = (0,_session_js__WEBPACK_IMPORTED_MODULE_7__.makeSession)({\n            release,\n            environment,\n            user: scope.getUser(),\n            ...userAgent && {\n                userAgent\n            },\n            ...context\n        });\n        // End existing session if there's one\n        const currentSession = scope.getSession && scope.getSession();\n        if (currentSession && currentSession.status === \"ok\") {\n            (0,_session_js__WEBPACK_IMPORTED_MODULE_7__.updateSession)(currentSession, {\n                status: \"exited\"\n            });\n        }\n        // eslint-disable-next-line deprecation/deprecation\n        this.endSession();\n        // Afterwards we set the new session on the scope\n        scope.setSession(session);\n        return session;\n    }\n    /**\n   * Returns if default PII should be sent to Sentry and propagated in ourgoing requests\n   * when Tracing is used.\n   *\n   * @deprecated Use top-level `getClient().getOptions().sendDefaultPii` instead. This function\n   * only unnecessarily increased API surface but only wrapped accessing the option.\n   */ shouldSendDefaultPii() {\n        // eslint-disable-next-line deprecation/deprecation\n        const client = this.getClient();\n        const options = client && client.getOptions();\n        return Boolean(options && options.sendDefaultPii);\n    }\n    /**\n   * Sends the current Session on the scope\n   */ _sendSessionUpdate() {\n        // eslint-disable-next-line deprecation/deprecation\n        const { scope, client } = this.getStackTop();\n        const session = scope.getSession();\n        if (session && client && client.captureSession) {\n            client.captureSession(session);\n        }\n    }\n    /**\n   * Calls global extension method and binding current instance to the function call\n   */ // @ts-expect-error Function lacks ending return statement and return type does not include 'undefined'. ts(2366)\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _callExtensionMethod(method, ...args) {\n        const carrier = getMainCarrier();\n        const sentry = carrier.__SENTRY__;\n        if (sentry && sentry.extensions && typeof sentry.extensions[method] === \"function\") {\n            return sentry.extensions[method].apply(this, args);\n        }\n        _debug_build_js__WEBPACK_IMPORTED_MODULE_6__.DEBUG_BUILD && _sentry_utils__WEBPACK_IMPORTED_MODULE_5__.logger.warn(`Extension method ${method} couldn't be found, doing nothing.`);\n    }\n}\n/**\n * Returns the global shim registry.\n *\n * FIXME: This function is problematic, because despite always returning a valid Carrier,\n * it has an optional `__SENTRY__` property, which then in turn requires us to always perform an unnecessary check\n * at the call-site. We always access the carrier through this function, so we can guarantee that `__SENTRY__` is there.\n **/ function getMainCarrier() {\n    _sentry_utils__WEBPACK_IMPORTED_MODULE_9__.GLOBAL_OBJ.__SENTRY__ = _sentry_utils__WEBPACK_IMPORTED_MODULE_9__.GLOBAL_OBJ.__SENTRY__ || {\n        extensions: {},\n        hub: undefined\n    };\n    return _sentry_utils__WEBPACK_IMPORTED_MODULE_9__.GLOBAL_OBJ;\n}\n/**\n * Replaces the current main hub with the passed one on the global object\n *\n * @returns The old replaced hub\n *\n * @deprecated Use `setCurrentClient()` instead.\n */ function makeMain(hub) {\n    const registry = getMainCarrier();\n    const oldHub = getHubFromCarrier(registry);\n    setHubOnCarrier(registry, hub);\n    return oldHub;\n}\n/**\n * Returns the default hub instance.\n *\n * If a hub is already registered in the global carrier but this module\n * contains a more recent version, it replaces the registered version.\n * Otherwise, the currently registered hub will be returned.\n *\n * @deprecated Use the respective replacement method directly instead.\n */ function getCurrentHub() {\n    // Get main carrier (global for every environment)\n    const registry = getMainCarrier();\n    if (registry.__SENTRY__ && registry.__SENTRY__.acs) {\n        const hub = registry.__SENTRY__.acs.getCurrentHub();\n        if (hub) {\n            return hub;\n        }\n    }\n    // Return hub that lives on a global object\n    return getGlobalHub(registry);\n}\n/**\n * Get the currently active isolation scope.\n * The isolation scope is active for the current exection context,\n * meaning that it will remain stable for the same Hub.\n */ function getIsolationScope() {\n    // eslint-disable-next-line deprecation/deprecation\n    return getCurrentHub().getIsolationScope();\n}\nfunction getGlobalHub(registry = getMainCarrier()) {\n    // If there's no hub, or its an old API, assign a new one\n    if (!hasHubOnCarrier(registry) || // eslint-disable-next-line deprecation/deprecation\n    getHubFromCarrier(registry).isOlderThan(API_VERSION)) {\n        // eslint-disable-next-line deprecation/deprecation\n        setHubOnCarrier(registry, new Hub());\n    }\n    // Return hub that lives on a global object\n    return getHubFromCarrier(registry);\n}\n/**\n * @private Private API with no semver guarantees!\n *\n * If the carrier does not contain a hub, a new hub is created with the global hub client and scope.\n */ function ensureHubOnCarrier(carrier, parent = getGlobalHub()) {\n    // If there's no hub on current domain, or it's an old API, assign a new one\n    if (!hasHubOnCarrier(carrier) || // eslint-disable-next-line deprecation/deprecation\n    getHubFromCarrier(carrier).isOlderThan(API_VERSION)) {\n        // eslint-disable-next-line deprecation/deprecation\n        const client = parent.getClient();\n        // eslint-disable-next-line deprecation/deprecation\n        const scope = parent.getScope();\n        // eslint-disable-next-line deprecation/deprecation\n        const isolationScope = parent.getIsolationScope();\n        // eslint-disable-next-line deprecation/deprecation\n        setHubOnCarrier(carrier, new Hub(client, scope.clone(), isolationScope.clone()));\n    }\n}\n/**\n * @private Private API with no semver guarantees!\n *\n * Sets the global async context strategy\n */ function setAsyncContextStrategy(strategy) {\n    // Get main carrier (global for every environment)\n    const registry = getMainCarrier();\n    registry.__SENTRY__ = registry.__SENTRY__ || {};\n    registry.__SENTRY__.acs = strategy;\n}\n/**\n * Runs the supplied callback in its own async context. Async Context strategies are defined per SDK.\n *\n * @param callback The callback to run in its own async context\n * @param options Options to pass to the async context strategy\n * @returns The result of the callback\n */ function runWithAsyncContext(callback, options = {}) {\n    const registry = getMainCarrier();\n    if (registry.__SENTRY__ && registry.__SENTRY__.acs) {\n        return registry.__SENTRY__.acs.runWithAsyncContext(callback, options);\n    }\n    // if there was no strategy, fallback to just calling the callback\n    return callback();\n}\n/**\n * This will tell whether a carrier has a hub on it or not\n * @param carrier object\n */ function hasHubOnCarrier(carrier) {\n    return !!(carrier && carrier.__SENTRY__ && carrier.__SENTRY__.hub);\n}\n/**\n * This will create a new {@link Hub} and add to the passed object on\n * __SENTRY__.hub.\n * @param carrier object\n * @hidden\n */ function getHubFromCarrier(carrier) {\n    // eslint-disable-next-line deprecation/deprecation\n    return (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_9__.getGlobalSingleton)(\"hub\", ()=>new Hub(), carrier);\n}\n/**\n * This will set passed {@link Hub} on the passed object's __SENTRY__.hub attribute\n * @param carrier object\n * @param hub Hub\n * @returns A boolean indicating success or failure\n */ function setHubOnCarrier(carrier, hub) {\n    if (!carrier) return false;\n    const __SENTRY__ = carrier.__SENTRY__ = carrier.__SENTRY__ || {};\n    __SENTRY__.hub = hub;\n    return true;\n}\n //# sourceMappingURL=hub.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2VzbS9odWIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWtJO0FBQzdFO0FBQ047QUFDWjtBQUNxQztBQUM3QjtBQUUzQzs7Ozs7OztDQU9DLEdBQ0QsTUFBTWMsY0FBY0MsV0FBV0Ysb0RBQVdBO0FBRTFDOzs7Q0FHQyxHQUNELE1BQU1HLHNCQUFzQjtBQUU1Qjs7Q0FFQyxHQUNELE1BQU1DO0lBQ0oseURBQXlELEdBRXpELHFEQUFxRCxHQUVyRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0ErQ0MsR0FDQUMsWUFDQ0MsTUFBTSxFQUNOQyxLQUFLLEVBQ0xDLGNBQWMsRUFDWkMsV0FBV1IsV0FBVyxDQUN4QjtRQUFDLElBQUksQ0FBQ1EsUUFBUSxHQUFHQTtRQUNqQixJQUFJQztRQUNKLElBQUksQ0FBQ0gsT0FBTztZQUNWRyxnQkFBZ0IsSUFBSWQsNENBQUtBO1lBQ3pCYyxjQUFjQyxTQUFTLENBQUNMO1FBQzFCLE9BQU87WUFDTEksZ0JBQWdCSDtRQUNsQjtRQUVBLElBQUlLO1FBQ0osSUFBSSxDQUFDSixnQkFBZ0I7WUFDbkJJLHlCQUF5QixJQUFJaEIsNENBQUtBO1lBQ2xDZ0IsdUJBQXVCRCxTQUFTLENBQUNMO1FBQ25DLE9BQU87WUFDTE0seUJBQXlCSjtRQUMzQjtRQUVBLElBQUksQ0FBQ0ssTUFBTSxHQUFHO1lBQUM7Z0JBQUVOLE9BQU9HO1lBQWM7U0FBRTtRQUV4QyxJQUFJSixRQUFRO1lBQ1YsbURBQW1EO1lBQ25ELElBQUksQ0FBQ1EsVUFBVSxDQUFDUjtRQUNsQjtRQUVBLElBQUksQ0FBQ1MsZUFBZSxHQUFHSDtJQUN6QjtJQUVBOzs7Ozs7O0dBT0MsR0FDQUksWUFBWUMsT0FBTyxFQUFFO1FBQ3BCLE9BQU8sSUFBSSxDQUFDUixRQUFRLEdBQUdRO0lBQ3pCO0lBRUE7Ozs7O0dBS0MsR0FDQUgsV0FBV1IsTUFB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SUFDOUNLLFNBQVNMLFVBQVUsQ0FBQ1MsR0FBRyxHQUFHTTtBQUM1QjtBQUVBOzs7Ozs7Q0FNQyxHQUNELFNBQVNDLG9CQUFvQm5HLFFBQVEsRUFBRTJFLFVBQVUsQ0FBQyxDQUFDO0lBQ2pELE1BQU1hLFdBQVdQO0lBRWpCLElBQUlPLFNBQVNMLFVBQVUsSUFBSUssU0FBU0wsVUFBVSxDQUFDUyxHQUFHLEVBQUU7UUFDbEQsT0FBT0osU0FBU0wsVUFBVSxDQUFDUyxHQUFHLENBQUNPLG1CQUFtQixDQUFDbkcsVUFBVTJFO0lBQy9EO0lBRUEsa0VBQWtFO0lBQ2xFLE9BQU8zRTtBQUNUO0FBRUE7OztDQUdDLEdBQ0QsU0FBUzhGLGdCQUFnQmQsT0FBTztJQUM5QixPQUFPLENBQUMsQ0FBRUEsQ0FBQUEsV0FBV0EsUUFBUUcsVUFBVSxJQUFJSCxRQUFRRyxVQUFVLENBQUNHLEdBQUc7QUFDbkU7QUFFQTs7Ozs7Q0FLQyxHQUNELFNBQVNHLGtCQUFrQlQsT0FBTztJQUNoQyxtREFBbUQ7SUFDbkQsT0FBT3RILGlFQUFrQkEsQ0FBQyxPQUFPLElBQU0sSUFBSVcsT0FBTzJHO0FBQ3BEO0FBRUE7Ozs7O0NBS0MsR0FDRCxTQUFTVSxnQkFBZ0JWLE9BQU8sRUFBRU0sR0FBRztJQUNuQyxJQUFJLENBQUNOLFNBQVMsT0FBTztJQUNyQixNQUFNRyxhQUFjSCxRQUFRRyxVQUFVLEdBQUdILFFBQVFHLFVBQVUsSUFBSSxDQUFDO0lBQ2hFQSxXQUFXRyxHQUFHLEdBQUdBO0lBQ2pCLE9BQU87QUFDVDtBQUU4TCxDQUM5TCwrQkFBK0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vYnJhbGluay13ZWIvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2VzbS9odWIuanM/MzkyNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc1RoZW5hYmxlLCB1dWlkNCwgZGF0ZVRpbWVzdGFtcEluU2Vjb25kcywgY29uc29sZVNhbmRib3gsIGxvZ2dlciwgR0xPQkFMX09CSiwgZ2V0R2xvYmFsU2luZ2xldG9uIH0gZnJvbSAnQHNlbnRyeS91dGlscyc7XG5pbXBvcnQgeyBERUZBVUxUX0VOVklST05NRU5UIH0gZnJvbSAnLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgREVCVUdfQlVJTEQgfSBmcm9tICcuL2RlYnVnLWJ1aWxkLmpzJztcbmltcG9ydCB7IFNjb3BlIH0gZnJvbSAnLi9zY29wZS5qcyc7XG5pbXBvcnQgeyBjbG9zZVNlc3Npb24sIG1ha2VTZXNzaW9uLCB1cGRhdGVTZXNzaW9uIH0gZnJvbSAnLi9zZXNzaW9uLmpzJztcbmltcG9ydCB7IFNES19WRVJTSU9OIH0gZnJvbSAnLi92ZXJzaW9uLmpzJztcblxuLyoqXG4gKiBBUEkgY29tcGF0aWJpbGl0eSB2ZXJzaW9uIG9mIHRoaXMgaHViLlxuICpcbiAqIFdBUk5JTkc6IFRoaXMgbnVtYmVyIHNob3VsZCBvbmx5IGJlIGluY3JlYXNlZCB3aGVuIHRoZSBnbG9iYWwgaW50ZXJmYWNlXG4gKiBjaGFuZ2VzIGFuZCBuZXcgbWV0aG9kcyBhcmUgaW50cm9kdWNlZC5cbiAqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IEFQSV9WRVJTSU9OID0gcGFyc2VGbG9hdChTREtfVkVSU0lPTik7XG5cbi8qKlxuICogRGVmYXVsdCBtYXhpbXVtIG51bWJlciBvZiBicmVhZGNydW1icyBhZGRlZCB0byBhbiBldmVudC4gQ2FuIGJlIG92ZXJ3cml0dGVuXG4gKiB3aXRoIHtAbGluayBPcHRpb25zLm1heEJyZWFkY3J1bWJzfS5cbiAqL1xuY29uc3QgREVGQVVMVF9CUkVBRENSVU1CUyA9IDEwMDtcblxuLyoqXG4gKiBAaW5oZXJpdERvY1xuICovXG5jbGFzcyBIdWIgIHtcbiAgLyoqIElzIGEge0BsaW5rIExheWVyfVtdIGNvbnRhaW5pbmcgdGhlIGNsaWVudCBhbmQgc2NvcGUgKi9cblxuICAvKiogQ29udGFpbnMgdGhlIGxhc3QgZXZlbnQgaWQgb2YgYSBjYXB0dXJlZCBldmVudC4gICovXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGh1Yiwgd2lsbCBwdXNoIG9uZSB7QGxpbmsgTGF5ZXJ9IGludG8gdGhlXG4gICAqIGludGVybmFsIHN0YWNrIG9uIGNyZWF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gY2xpZW50IGJvdW5kIHRvIHRoZSBodWIuXG4gICAqIEBwYXJhbSBzY29wZSBib3VuZCB0byB0aGUgaHViLlxuICAgKiBAcGFyYW0gdmVyc2lvbiBudW1iZXIsIGhpZ2hlciBudW1iZXIgbWVhbnMgaGlnaGVyIHByaW9yaXR5LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBJbnN0YW50aWF0aW9uIG9mIEh1YiBvYmplY3RzIGlzIGRlcHJlY2F0ZWQgYW5kIHRoZSBjb25zdHJ1Y3RvciB3aWxsIGJlIHJlbW92ZWQgaW4gdmVyc2lvbiA4IG9mIHRoZSBTREsuXG4gICAqXG4gICAqIElmIHlvdSBhcmUgY3VycmVudGx5IHVzaW5nIHRoZSBIdWIgZm9yIG11bHRpLWNsaWVudCB1c2UgbGlrZSBzbzpcbiAgICpcbiAgICogYGBgXG4gICAqIC8vIE9MRFxuICAgKiBjb25zdCBodWIgPSBuZXcgSHViKCk7XG4gICAqIGh1Yi5iaW5kQ2xpZW50KGNsaWVudCk7XG4gICAqIG1ha2VNYWluKGh1YilcbiAgICogYGBgXG4gICAqXG4gICAqIGluc3RlYWQgaW5pdGlhbGl6ZSB0aGUgY2xpZW50IGFzIGZvbGxvd3M6XG4gICAqXG4gICAqIGBgYFxuICAgKiAvLyBORVdcbiAgICogU2VudHJ5LndpdGhJc29sYXRpb25TY29wZSgoKSA9PiB7XG4gICAqICAgIFNlbnRyeS5zZXRDdXJyZW50Q2xpZW50KGNsaWVudCk7XG4gICAqICAgIGNsaWVudC5pbml0KCk7XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogSWYgeW91IGFyZSB1c2luZyB0aGUgSHViIHRvIGNhcHR1cmUgZXZlbnRzIGxpa2Ugc286XG4gICAqXG4gICAqIGBgYFxuICAgKiAvLyBPTERcbiAgICogY29uc3QgY2xpZW50ID0gbmV3IENsaWVudCgpO1xuICAgKiBjb25zdCBodWIgPSBuZXcgSHViKGNsaWVudCk7XG4gICAqIGh1Yi5jYXB0dXJlRXhjZXB0aW9uKClcbiAgICogYGBgXG4gICAqXG4gICAqIGluc3RlYWQgY2FwdHVyZSBpc29sYXRlZCBldmVudHMgYXMgZm9sbG93czpcbiAgICpcbiAgICogYGBgXG4gICAqIC8vIE5FV1xuICAgKiBjb25zdCBjbGllbnQgPSBuZXcgQ2xpZW50KCk7XG4gICAqIGNvbnN0IHNjb3BlID0gbmV3IFNjb3BlKCk7XG4gICAqIHNjb3BlLnNldENsaWVudChjbGllbnQpO1xuICAgKiBzY29wZS5jYXB0dXJlRXhjZXB0aW9uKCk7XG4gICAqIGBgYFxuICAgKi9cbiAgIGNvbnN0cnVjdG9yKFxuICAgIGNsaWVudCxcbiAgICBzY29wZSxcbiAgICBpc29sYXRpb25TY29wZSxcbiAgICAgIF92ZXJzaW9uID0gQVBJX1ZFUlNJT04sXG4gICkge3RoaXMuX3ZlcnNpb24gPSBfdmVyc2lvbjtcbiAgICBsZXQgYXNzaWduZWRTY29wZTtcbiAgICBpZiAoIXNjb3BlKSB7XG4gICAgICBhc3NpZ25lZFNjb3BlID0gbmV3IFNjb3BlKCk7XG4gICAgICBhc3NpZ25lZFNjb3BlLnNldENsaWVudChjbGllbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25lZFNjb3BlID0gc2NvcGU7XG4gICAgfVxuXG4gICAgbGV0IGFzc2lnbmVkSXNvbGF0aW9uU2NvcGU7XG4gICAgaWYgKCFpc29sYXRpb25TY29wZSkge1xuICAgICAgYXNzaWduZWRJc29sYXRpb25TY29wZSA9IG5ldyBTY29wZSgpO1xuICAgICAgYXNzaWduZWRJc29sYXRpb25TY29wZS5zZXRDbGllbnQoY2xpZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzaWduZWRJc29sYXRpb25TY29wZSA9IGlzb2xhdGlvblNjb3BlO1xuICAgIH1cblxuICAgIHRoaXMuX3N0YWNrID0gW3sgc2NvcGU6IGFzc2lnbmVkU2NvcGUgfV07XG5cbiAgICBpZiAoY2xpZW50KSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgICAgIHRoaXMuYmluZENsaWVudChjbGllbnQpO1xuICAgIH1cblxuICAgIHRoaXMuX2lzb2xhdGlvblNjb3BlID0gYXNzaWduZWRJc29sYXRpb25TY29wZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyBodWIncyB2ZXJzaW9uIGlzIG9sZGVyIHRoYW4gdGhlIGdpdmVuIHZlcnNpb24uXG4gICAqXG4gICAqIEBwYXJhbSB2ZXJzaW9uIEEgdmVyc2lvbiBudW1iZXIgdG8gY29tcGFyZSB0by5cbiAgICogQHJldHVybiBUcnVlIGlmIHRoZSBnaXZlbiB2ZXJzaW9uIGlzIG5ld2VyOyBvdGhlcndpc2UgZmFsc2UuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFRoaXMgd2lsbCBiZSByZW1vdmVkIGluIHY4LlxuICAgKi9cbiAgIGlzT2xkZXJUaGFuKHZlcnNpb24pIHtcbiAgICByZXR1cm4gdGhpcy5fdmVyc2lvbiA8IHZlcnNpb247XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBiaW5kcyB0aGUgZ2l2ZW4gY2xpZW50IHRvIHRoZSBjdXJyZW50IHNjb3BlLlxuICAgKiBAcGFyYW0gY2xpZW50IEFuIFNESyBjbGllbnQgKGNsaWVudCkgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgaW5pdEFuZEJpbmQoKWAgZGlyZWN0bHksIG9yIGBzZXRDdXJyZW50Q2xpZW50KClgIGFuZC9vciBgY2xpZW50LmluaXQoKWAgaW5zdGVhZC5cbiAgICovXG4gICBiaW5kQ2xpZW50KGNsaWVudCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICAgIGNvbnN0IHRvcCA9IHRoaXMuZ2V0U3RhY2tUb3AoKTtcbiAgICB0b3AuY2xpZW50ID0gY2xpZW50O1xuICAgIHRvcC5zY29wZS5zZXRDbGllbnQoY2xpZW50KTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgICBpZiAoY2xpZW50ICYmIGNsaWVudC5zZXR1cEludGVncmF0aW9ucykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gICAgICBjbGllbnQuc2V0dXBJbnRlZ3JhdGlvbnMoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGB3aXRoU2NvcGVgIGluc3RlYWQuXG4gICAqL1xuICAgcHVzaFNjb3BlKCkge1xuICAgIC8vIFdlIHdhbnQgdG8gY2xvbmUgdGhlIGNvbnRlbnQgb2YgcHJldiBzY29wZVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICAgIGNvbnN0IHNjb3BlID0gdGhpcy5nZXRTY29wZSgpLmNsb25lKCk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gICAgdGhpcy5nZXRTdGFjaygpLnB1c2goe1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gICAgICBjbGllbnQ6IHRoaXMuZ2V0Q2xpZW50KCksXG4gICAgICBzY29wZSxcbiAgICB9KTtcbiAgICByZXR1cm4gc2NvcGU7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGB3aXRoU2NvcGVgIGluc3RlYWQuXG4gICAqL1xuICAgcG9wU2NvcGUoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gICAgaWYgKHRoaXMuZ2V0U3RhY2soKS5sZW5ndGggPD0gMSkgcmV0dXJuIGZhbHNlO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICAgIHJldHVybiAhIXRoaXMuZ2V0U3RhY2soKS5wb3AoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYFNlbnRyeS53aXRoU2NvcGUoKWAgaW5zdGVhZC5cbiAgICovXG4gICB3aXRoU2NvcGUoY2FsbGJhY2spIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgICBjb25zdCBzY29wZSA9IHRoaXMucHVzaFNjb3BlKCk7XG5cbiAgICBsZXQgbWF5YmVQcm9taXNlUmVzdWx0O1xuICAgIHRyeSB7XG4gICAgICBtYXliZVByb21pc2VSZXN1bHQgPSBjYWxsYmFjayhzY29wZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gICAgICB0aGlzLnBvcFNjb3BlKCk7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cblxuICAgIGlmIChpc1RoZW5hYmxlKG1heWJlUHJvbWlzZVJlc3VsdCkpIHtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBpc1RoZW5hYmxlIHJldHVybnMgdGhlIHdyb25nIHR5cGVcbiAgICAgIHJldHVybiBtYXliZVByb21pc2VSZXN1bHQudGhlbihcbiAgICAgICAgcmVzID0+IHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgICAgICAgICB0aGlzLnBvcFNjb3BlKCk7XG4gICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSxcbiAgICAgICAgZSA9PiB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gICAgICAgICAgdGhpcy5wb3BTY29wZSgpO1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0sXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICAgIHRoaXMucG9wU2NvcGUoKTtcbiAgICByZXR1cm4gbWF5YmVQcm9taXNlUmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgU2VudHJ5LmdldENsaWVudCgpYCBpbnN0ZWFkLlxuICAgKi9cbiAgIGdldENsaWVudCgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgICByZXR1cm4gdGhpcy5nZXRTdGFja1RvcCgpLmNsaWVudCA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc2NvcGUgb2YgdGhlIHRvcCBzdGFjay5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGBTZW50cnkuZ2V0Q3VycmVudFNjb3BlKClgIGluc3RlYWQuXG4gICAqL1xuICAgZ2V0U2NvcGUoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gICAgcmV0dXJuIHRoaXMuZ2V0U3RhY2tUb3AoKS5zY29wZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYFNlbnRyeS5nZXRJc29sYXRpb25TY29wZSgpYCBpbnN0ZWFkLlxuICAgKi9cbiAgIGdldElzb2xhdGlvblNjb3BlKCkge1xuICAgIHJldHVybiB0aGlzLl9pc29sYXRpb25TY29wZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzY29wZSBzdGFjayBmb3IgZG9tYWlucyBvciB0aGUgcHJvY2Vzcy5cbiAgICogQGRlcHJlY2F0ZWQgVGhpcyB3aWxsIGJlIHJlbW92ZWQgaW4gdjguXG4gICAqL1xuICAgZ2V0U3RhY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YWNrO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRvcG1vc3Qgc2NvcGUgbGF5ZXIgaW4gdGhlIG9yZGVyIGRvbWFpbiA+IGxvY2FsID4gcHJvY2Vzcy5cbiAgICogQGRlcHJlY2F0ZWQgVGhpcyB3aWxsIGJlIHJlbW92ZWQgaW4gdjguXG4gICAqL1xuICAgZ2V0U3RhY2tUb3AoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YWNrW3RoaXMuX3N0YWNrLmxlbmd0aCAtIDFdO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgU2VudHJ5LmNhcHR1cmVFeGNlcHRpb24oKWAgaW5zdGVhZC5cbiAgICovXG4gICBjYXB0dXJlRXhjZXB0aW9uKGV4Y2VwdGlvbiwgaGludCkge1xuICAgIGNvbnN0IGV2ZW50SWQgPSAodGhpcy5fbGFzdEV2ZW50SWQgPSBoaW50ICYmIGhpbnQuZXZlbnRfaWQgPyBoaW50LmV2ZW50X2lkIDogdXVpZDQoKSk7XG4gICAgY29uc3Qgc3ludGhldGljRXhjZXB0aW9uID0gbmV3IEVycm9yKCdTZW50cnkgc3ludGhldGljRXhjZXB0aW9uJyk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gICAgdGhpcy5nZXRTY29wZSgpLmNhcHR1cmVFeGNlcHRpb24oZXhjZXB0aW9uLCB7XG4gICAgICBvcmlnaW5hbEV4Y2VwdGlvbjogZXhjZXB0aW9uLFxuICAgICAgc3ludGhldGljRXhjZXB0aW9uLFxuICAgICAgLi4uaGludCxcbiAgICAgIGV2ZW50X2lkOiBldmVudElkLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGV2ZW50SWQ7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlICBgU2VudHJ5LmNhcHR1cmVNZXNzYWdlKClgIGluc3RlYWQuXG4gICAqL1xuICAgY2FwdHVyZU1lc3NhZ2UoXG4gICAgbWVzc2FnZSxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgICBsZXZlbCxcbiAgICBoaW50LFxuICApIHtcbiAgICBjb25zdCBldmVudElkID0gKHRoaXMuX2xhc3RFdmVudElkID0gaGludCAmJiBoaW50LmV2ZW50X2lkID8gaGludC5ldmVudF9pZCA6IHV1aWQ0KCkpO1xuICAgIGNvbnN0IHN5bnRoZXRpY0V4Y2VwdGlvbiA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgICB0aGlzLmdldFNjb3BlKCkuY2FwdHVyZU1lc3NhZ2UobWVzc2FnZSwgbGV2ZWwsIHtcbiAgICAgIG9yaWdpbmFsRXhjZXB0aW9uOiBtZXNzYWdlLFxuICAgICAgc3ludGhldGljRXhjZXB0aW9uLFxuICAgICAgLi4uaGludCxcbiAgICAgIGV2ZW50X2lkOiBldmVudElkLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGV2ZW50SWQ7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGBTZW50cnkuY2FwdHVyZUV2ZW50KClgIGluc3RlYWQuXG4gICAqL1xuICAgY2FwdHVyZUV2ZW50KGV2ZW50LCBoaW50KSB7XG4gICAgY29uc3QgZXZlbnRJZCA9IGhpbnQgJiYgaGludC5ldmVudF9pZCA/IGhpbnQuZXZlbnRfaWQgOiB1dWlkNCgpO1xuICAgIGlmICghZXZlbnQudHlwZSkge1xuICAgICAgdGhpcy5fbGFzdEV2ZW50SWQgPSBldmVudElkO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgICB0aGlzLmdldFNjb3BlKCkuY2FwdHVyZUV2ZW50KGV2ZW50LCB7IC4uLmhpbnQsIGV2ZW50X2lkOiBldmVudElkIH0pO1xuICAgIHJldHVybiBldmVudElkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFRoaXMgd2lsbCBiZSByZW1vdmVkIGluIHY4LlxuICAgKi9cbiAgIGxhc3RFdmVudElkKCkge1xuICAgIHJldHVybiB0aGlzLl9sYXN0RXZlbnRJZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYFNlbnRyeS5hZGRCcmVhZGNydW1iKClgIGluc3RlYWQuXG4gICAqL1xuICAgYWRkQnJlYWRjcnVtYihicmVhZGNydW1iLCBoaW50KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gICAgY29uc3QgeyBzY29wZSwgY2xpZW50IH0gPSB0aGlzLmdldFN0YWNrVG9wKCk7XG5cbiAgICBpZiAoIWNsaWVudCkgcmV0dXJuO1xuXG4gICAgY29uc3QgeyBiZWZvcmVCcmVhZGNydW1iID0gbnVsbCwgbWF4QnJlYWRjcnVtYnMgPSBERUZBVUxUX0JSRUFEQ1JVTUJTIH0gPVxuICAgICAgKGNsaWVudC5nZXRPcHRpb25zICYmIGNsaWVudC5nZXRPcHRpb25zKCkpIHx8IHt9O1xuXG4gICAgaWYgKG1heEJyZWFkY3J1bWJzIDw9IDApIHJldHVybjtcblxuICAgIGNvbnN0IHRpbWVzdGFtcCA9IGRhdGVUaW1lc3RhbXBJblNlY29uZHMoKTtcbiAgICBjb25zdCBtZXJnZWRCcmVhZGNydW1iID0geyB0aW1lc3RhbXAsIC4uLmJyZWFkY3J1bWIgfTtcbiAgICBjb25zdCBmaW5hbEJyZWFkY3J1bWIgPSBiZWZvcmVCcmVhZGNydW1iXG4gICAgICA/IChjb25zb2xlU2FuZGJveCgoKSA9PiBiZWZvcmVCcmVhZGNydW1iKG1lcmdlZEJyZWFkY3J1bWIsIGhpbnQpKSApXG4gICAgICA6IG1lcmdlZEJyZWFkY3J1bWI7XG5cbiAgICBpZiAoZmluYWxCcmVhZGNydW1iID09PSBudWxsKSByZXR1cm47XG5cbiAgICBpZiAoY2xpZW50LmVtaXQpIHtcbiAgICAgIGNsaWVudC5lbWl0KCdiZWZvcmVBZGRCcmVhZGNydW1iJywgZmluYWxCcmVhZGNydW1iLCBoaW50KTtcbiAgICB9XG5cbiAgICAvLyBUT0RPKHY4KTogSSBrbm93IHRoaXMgY29tbWVudCBkb2Vzbid0IG1ha2UgbXVjaCBzZW5zZSBiZWNhdXNlIHRoZSBodWIgd2lsbCBiZSBkZXByZWNhdGVkIGJ1dCBJIHN0aWxsIHdhbnRlZCB0b1xuICAgIC8vIHdyaXRlIGl0IGRvd24uIEluIHRoZW9yeSwgd2Ugd291bGQgaGF2ZSB0byBhZGQgdGhlIGJyZWFkY3J1bWJzIHRvIHRoZSBpc29sYXRpb24gc2NvcGUgaGVyZSwgaG93ZXZlciwgdGhhdCB3b3VsZFxuICAgIC8vIGR1cGxpY2F0ZSBhbGwgb2YgdGhlIGJyZWFkY3J1bWJzLiBUaGVyZSB3YXMgdGhlIHBvc3NpYmlsaXR5IG9mIGFkZGluZyBicmVhZGNydW1icyB0byBib3RoLCB0aGUgaXNvbGF0aW9uIHNjb3BlXG4gICAgLy8gYW5kIHRoZSBub3JtYWwgc2NvcGUsIGFuZCBkZWR1cGxpY2F0aW5nIGl0IGRvd24gdGhlIGxpbmUgaW4gdGhlIGV2ZW50IHByb2Nlc3NpbmcgcGlwZWxpbmUuIEhvd2V2ZXIsIHRoYXQgd291bGRcbiAgICAvLyBoYXZlIGJlZW4gdmVyeSBmcmFnaWxlLCBiZWNhdXNlIHRoZSBicmVhZGNydW1iIG9iamVjdHMgd291bGQgaGF2ZSBuZWVkZWQgdG8ga2VlcCB0aGVpciBpZGVudGl0eSBhbGwgdGhyb3VnaG91dFxuICAgIC8vIHRoZSBldmVudCBwcm9jZXNzaW5nIHBpcGVsaW5lLlxuICAgIC8vIEluIHRoZSBuZXcgaW1wbGVtZW50YXRpb24sIHRoZSB0b3AgbGV2ZWwgYFNlbnRyeS5hZGRCcmVhZGNydW1iKClgIHNob3VsZCBPTkxZIHdyaXRlIHRvIHRoZSBpc29sYXRpb24gc2NvcGUuXG5cbiAgICBzY29wZS5hZGRCcmVhZGNydW1iKGZpbmFsQnJlYWRjcnVtYiwgbWF4QnJlYWRjcnVtYnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgU2VudHJ5LnNldFVzZXIoKWAgaW5zdGVhZC5cbiAgICovXG4gICBzZXRVc2VyKHVzZXIpIHtcbiAgICAvLyBUT0RPKHY4KTogVGhlIHRvcCBsZXZlbCBgU2VudHJ5LnNldFVzZXIoKWAgZnVuY3Rpb24gc2hvdWxkIHdyaXRlIE9OTFkgdG8gdGhlIGlzb2xhdGlvbiBzY29wZS5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgICB0aGlzLmdldFNjb3BlKCkuc2V0VXNlcih1c2VyKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgICB0aGlzLmdldElzb2xhdGlvblNjb3BlKCkuc2V0VXNlcih1c2VyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKiBAZGVwcmVjYXRlZCBVc2UgYFNlbnRyeS5zZXRUYWdzKClgIGluc3RlYWQuXG4gICAqL1xuICAgc2V0VGFncyh0YWdzKSB7XG4gICAgLy8gVE9ETyh2OCk6IFRoZSB0b3AgbGV2ZWwgYFNlbnRyeS5zZXRUYWdzKClgIGZ1bmN0aW9uIHNob3VsZCB3cml0ZSBPTkxZIHRvIHRoZSBpc29sYXRpb24gc2NvcGUuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gICAgdGhpcy5nZXRTY29wZSgpLnNldFRhZ3ModGFncyk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gICAgdGhpcy5nZXRJc29sYXRpb25TY29wZSgpLnNldFRhZ3ModGFncyk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGBTZW50cnkuc2V0RXh0cmFzKClgIGluc3RlYWQuXG4gICAqL1xuICAgc2V0RXh0cmFzKGV4dHJhcykge1xuICAgIC8vIFRPRE8odjgpOiBUaGUgdG9wIGxldmVsIGBTZW50cnkuc2V0RXh0cmFzKClgIGZ1bmN0aW9uIHNob3VsZCB3cml0ZSBPTkxZIHRvIHRoZSBpc29sYXRpb24gc2NvcGUuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gICAgdGhpcy5nZXRTY29wZSgpLnNldEV4dHJhcyhleHRyYXMpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICAgIHRoaXMuZ2V0SXNvbGF0aW9uU2NvcGUoKS5zZXRFeHRyYXMoZXh0cmFzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKiBAZGVwcmVjYXRlZCBVc2UgYFNlbnRyeS5zZXRUYWcoKWAgaW5zdGVhZC5cbiAgICovXG4gICBzZXRUYWcoa2V5LCB2YWx1ZSkge1xuICAgIC8vIFRPRE8odjgpOiBUaGUgdG9wIGxldmVsIGBTZW50cnkuc2V0VGFnKClgIGZ1bmN0aW9uIHNob3VsZCB3cml0ZSBPTkxZIHRvIHRoZSBpc29sYXRpb24gc2NvcGUuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gICAgdGhpcy5nZXRTY29wZSgpLnNldFRhZyhrZXksIHZhbHVlKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgICB0aGlzLmdldElzb2xhdGlvblNjb3BlKCkuc2V0VGFnKGtleSwgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgU2VudHJ5LnNldEV4dHJhKClgIGluc3RlYWQuXG4gICAqL1xuICAgc2V0RXh0cmEoa2V5LCBleHRyYSkge1xuICAgIC8vIFRPRE8odjgpOiBUaGUgdG9wIGxldmVsIGBTZW50cnkuc2V0RXh0cmEoKWAgZnVuY3Rpb24gc2hvdWxkIHdyaXRlIE9OTFkgdG8gdGhlIGlzb2xhdGlvbiBzY29wZS5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgICB0aGlzLmdldFNjb3BlKCkuc2V0RXh0cmEoa2V5LCBleHRyYSk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gICAgdGhpcy5nZXRJc29sYXRpb25TY29wZSgpLnNldEV4dHJhKGtleSwgZXh0cmEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgU2VudHJ5LnNldENvbnRleHQoKWAgaW5zdGVhZC5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICBzZXRDb250ZXh0KG5hbWUsIGNvbnRleHQpIHtcbiAgICAvLyBUT0RPKHY4KTogVGhlIHRvcCBsZXZlbCBgU2VudHJ5LnNldENvbnRleHQoKWAgZnVuY3Rpb24gc2hvdWxkIHdyaXRlIE9OTFkgdG8gdGhlIGlzb2xhdGlvbiBzY29wZS5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgICB0aGlzLmdldFNjb3BlKCkuc2V0Q29udGV4dChuYW1lLCBjb250ZXh0KTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgICB0aGlzLmdldElzb2xhdGlvblNjb3BlKCkuc2V0Q29udGV4dChuYW1lLCBjb250ZXh0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYGdldFNjb3BlKClgIGRpcmVjdGx5LlxuICAgKi9cbiAgIGNvbmZpZ3VyZVNjb3BlKGNhbGxiYWNrKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gICAgY29uc3QgeyBzY29wZSwgY2xpZW50IH0gPSB0aGlzLmdldFN0YWNrVG9wKCk7XG4gICAgaWYgKGNsaWVudCkge1xuICAgICAgY2FsbGJhY2soc2NvcGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgIHJ1bihjYWxsYmFjaykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICAgIGNvbnN0IG9sZEh1YiA9IG1ha2VNYWluKHRoaXMpO1xuICAgIHRyeSB7XG4gICAgICBjYWxsYmFjayh0aGlzKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gICAgICBtYWtlTWFpbihvbGRIdWIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKiBAZGVwcmVjYXRlZCBVc2UgYFNlbnRyeS5nZXRDbGllbnQoKS5nZXRJbnRlZ3JhdGlvbkJ5TmFtZSgpYCBpbnN0ZWFkLlxuICAgKi9cbiAgIGdldEludGVncmF0aW9uKGludGVncmF0aW9uKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXRDbGllbnQoKTtcbiAgICBpZiAoIWNsaWVudCkgcmV0dXJuIG51bGw7XG4gICAgdHJ5IHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICAgICAgcmV0dXJuIGNsaWVudC5nZXRJbnRlZ3JhdGlvbihpbnRlZ3JhdGlvbik7XG4gICAgfSBjYXRjaCAoX29PKSB7XG4gICAgICBERUJVR19CVUlMRCAmJiBsb2dnZXIud2FybihgQ2Fubm90IHJldHJpZXZlIGludGVncmF0aW9uICR7aW50ZWdyYXRpb24uaWR9IGZyb20gdGhlIGN1cnJlbnQgSHViYCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RhcnRzIGEgbmV3IGBUcmFuc2FjdGlvbmAgYW5kIHJldHVybnMgaXQuIFRoaXMgaXMgdGhlIGVudHJ5IHBvaW50IHRvIG1hbnVhbCB0cmFjaW5nIGluc3RydW1lbnRhdGlvbi5cbiAgICpcbiAgICogQSB0cmVlIHN0cnVjdHVyZSBjYW4gYmUgYnVpbHQgYnkgYWRkaW5nIGNoaWxkIHNwYW5zIHRvIHRoZSB0cmFuc2FjdGlvbiwgYW5kIGNoaWxkIHNwYW5zIHRvIG90aGVyIHNwYW5zLiBUbyBzdGFydCBhXG4gICAqIG5ldyBjaGlsZCBzcGFuIHdpdGhpbiB0aGUgdHJhbnNhY3Rpb24gb3IgYW55IHNwYW4sIGNhbGwgdGhlIHJlc3BlY3RpdmUgYC5zdGFydENoaWxkKClgIG1ldGhvZC5cbiAgICpcbiAgICogRXZlcnkgY2hpbGQgc3BhbiBtdXN0IGJlIGZpbmlzaGVkIGJlZm9yZSB0aGUgdHJhbnNhY3Rpb24gaXMgZmluaXNoZWQsIG90aGVyd2lzZSB0aGUgdW5maW5pc2hlZCBzcGFucyBhcmUgZGlzY2FyZGVkLlxuICAgKlxuICAgKiBUaGUgdHJhbnNhY3Rpb24gbXVzdCBiZSBmaW5pc2hlZCB3aXRoIGEgY2FsbCB0byBpdHMgYC5lbmQoKWAgbWV0aG9kLCBhdCB3aGljaCBwb2ludCB0aGUgdHJhbnNhY3Rpb24gd2l0aCBhbGwgaXRzXG4gICAqIGZpbmlzaGVkIGNoaWxkIHNwYW5zIHdpbGwgYmUgc2VudCB0byBTZW50cnkuXG4gICAqXG4gICAqIEBwYXJhbSBjb250ZXh0IFByb3BlcnRpZXMgb2YgdGhlIG5ldyBgVHJhbnNhY3Rpb25gLlxuICAgKiBAcGFyYW0gY3VzdG9tU2FtcGxpbmdDb250ZXh0IEluZm9ybWF0aW9uIGdpdmVuIHRvIHRoZSB0cmFuc2FjdGlvbiBzYW1wbGluZyBmdW5jdGlvbiAoYWxvbmcgd2l0aCBjb250ZXh0LWRlcGVuZGVudFxuICAgKiBkZWZhdWx0IHZhbHVlcykuIFNlZSB7QGxpbmsgT3B0aW9ucy50cmFjZXNTYW1wbGVyfS5cbiAgICpcbiAgICogQHJldHVybnMgVGhlIHRyYW5zYWN0aW9uIHdoaWNoIHdhcyBqdXN0IHN0YXJ0ZWRcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGBzdGFydFNwYW4oKWAsIGBzdGFydFNwYW5NYW51YWwoKWAgb3IgYHN0YXJ0SW5hY3RpdmVTcGFuKClgIGluc3RlYWQuXG4gICAqL1xuICAgc3RhcnRUcmFuc2FjdGlvbihjb250ZXh0LCBjdXN0b21TYW1wbGluZ0NvbnRleHQpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9jYWxsRXh0ZW5zaW9uTWV0aG9kKCdzdGFydFRyYW5zYWN0aW9uJywgY29udGV4dCwgY3VzdG9tU2FtcGxpbmdDb250ZXh0KTtcblxuICAgIGlmIChERUJVR19CVUlMRCAmJiAhcmVzdWx0KSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0Q2xpZW50KCk7XG4gICAgICBpZiAoIWNsaWVudCkge1xuICAgICAgICBsb2dnZXIud2FybihcbiAgICAgICAgICBcIlRyYWNpbmcgZXh0ZW5zaW9uICdzdGFydFRyYW5zYWN0aW9uJyBpcyBtaXNzaW5nLiBZb3Ugc2hvdWxkICdpbml0JyB0aGUgU0RLIGJlZm9yZSBjYWxsaW5nICdzdGFydFRyYW5zYWN0aW9uJ1wiLFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oYFRyYWNpbmcgZXh0ZW5zaW9uICdzdGFydFRyYW5zYWN0aW9uJyBoYXMgbm90IGJlZW4gYWRkZWQuIENhbGwgJ2FkZFRyYWNpbmdFeHRlbnNpb25zJyBiZWZvcmUgY2FsbGluZyAnaW5pdCc6XG5TZW50cnkuYWRkVHJhY2luZ0V4dGVuc2lvbnMoKTtcblNlbnRyeS5pbml0KHsuLi59KTtcbmApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGBzcGFuVG9UcmFjZUhlYWRlcigpYCBpbnN0ZWFkLlxuICAgKi9cbiAgIHRyYWNlSGVhZGVycygpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbEV4dGVuc2lvbk1ldGhvZCgndHJhY2VIZWFkZXJzJyk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHRvcCBsZXZlbCBgY2FwdHVyZVNlc3Npb25gIGluc3RlYWQuXG4gICAqL1xuICAgY2FwdHVyZVNlc3Npb24oZW5kU2Vzc2lvbiA9IGZhbHNlKSB7XG4gICAgLy8gYm90aCBzZW5kIHRoZSB1cGRhdGUgYW5kIHB1bGwgdGhlIHNlc3Npb24gZnJvbSB0aGUgc2NvcGVcbiAgICBpZiAoZW5kU2Vzc2lvbikge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gICAgICByZXR1cm4gdGhpcy5lbmRTZXNzaW9uKCk7XG4gICAgfVxuXG4gICAgLy8gb25seSBzZW5kIHRoZSB1cGRhdGVcbiAgICB0aGlzLl9zZW5kU2Vzc2lvblVwZGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqIEBkZXByZWNhdGVkIFVzZSB0b3AgbGV2ZWwgYGVuZFNlc3Npb25gIGluc3RlYWQuXG4gICAqL1xuICAgZW5kU2Vzc2lvbigpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgICBjb25zdCBsYXllciA9IHRoaXMuZ2V0U3RhY2tUb3AoKTtcbiAgICBjb25zdCBzY29wZSA9IGxheWVyLnNjb3BlO1xuICAgIGNvbnN0IHNlc3Npb24gPSBzY29wZS5nZXRTZXNzaW9uKCk7XG4gICAgaWYgKHNlc3Npb24pIHtcbiAgICAgIGNsb3NlU2Vzc2lvbihzZXNzaW9uKTtcbiAgICB9XG4gICAgdGhpcy5fc2VuZFNlc3Npb25VcGRhdGUoKTtcblxuICAgIC8vIHRoZSBzZXNzaW9uIGlzIG92ZXI7IHRha2UgaXQgb2ZmIG9mIHRoZSBzY29wZVxuICAgIHNjb3BlLnNldFNlc3Npb24oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKiBAZGVwcmVjYXRlZCBVc2UgdG9wIGxldmVsIGBzdGFydFNlc3Npb25gIGluc3RlYWQuXG4gICAqL1xuICAgc3RhcnRTZXNzaW9uKGNvbnRleHQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgICBjb25zdCB7IHNjb3BlLCBjbGllbnQgfSA9IHRoaXMuZ2V0U3RhY2tUb3AoKTtcbiAgICBjb25zdCB7IHJlbGVhc2UsIGVudmlyb25tZW50ID0gREVGQVVMVF9FTlZJUk9OTUVOVCB9ID0gKGNsaWVudCAmJiBjbGllbnQuZ2V0T3B0aW9ucygpKSB8fCB7fTtcblxuICAgIC8vIFdpbGwgZmV0Y2ggdXNlckFnZW50IGlmIGNhbGxlZCBmcm9tIGJyb3dzZXIgc2RrXG4gICAgY29uc3QgeyB1c2VyQWdlbnQgfSA9IEdMT0JBTF9PQkoubmF2aWdhdG9yIHx8IHt9O1xuXG4gICAgY29uc3Qgc2Vzc2lvbiA9IG1ha2VTZXNzaW9uKHtcbiAgICAgIHJlbGVhc2UsXG4gICAgICBlbnZpcm9ubWVudCxcbiAgICAgIHVzZXI6IHNjb3BlLmdldFVzZXIoKSxcbiAgICAgIC4uLih1c2VyQWdlbnQgJiYgeyB1c2VyQWdlbnQgfSksXG4gICAgICAuLi5jb250ZXh0LFxuICAgIH0pO1xuXG4gICAgLy8gRW5kIGV4aXN0aW5nIHNlc3Npb24gaWYgdGhlcmUncyBvbmVcbiAgICBjb25zdCBjdXJyZW50U2Vzc2lvbiA9IHNjb3BlLmdldFNlc3Npb24gJiYgc2NvcGUuZ2V0U2Vzc2lvbigpO1xuICAgIGlmIChjdXJyZW50U2Vzc2lvbiAmJiBjdXJyZW50U2Vzc2lvbi5zdGF0dXMgPT09ICdvaycpIHtcbiAgICAgIHVwZGF0ZVNlc3Npb24oY3VycmVudFNlc3Npb24sIHsgc3RhdHVzOiAnZXhpdGVkJyB9KTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gICAgdGhpcy5lbmRTZXNzaW9uKCk7XG5cbiAgICAvLyBBZnRlcndhcmRzIHdlIHNldCB0aGUgbmV3IHNlc3Npb24gb24gdGhlIHNjb3BlXG4gICAgc2NvcGUuc2V0U2Vzc2lvbihzZXNzaW9uKTtcblxuICAgIHJldHVybiBzZXNzaW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaWYgZGVmYXVsdCBQSUkgc2hvdWxkIGJlIHNlbnQgdG8gU2VudHJ5IGFuZCBwcm9wYWdhdGVkIGluIG91cmdvaW5nIHJlcXVlc3RzXG4gICAqIHdoZW4gVHJhY2luZyBpcyB1c2VkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgdG9wLWxldmVsIGBnZXRDbGllbnQoKS5nZXRPcHRpb25zKCkuc2VuZERlZmF1bHRQaWlgIGluc3RlYWQuIFRoaXMgZnVuY3Rpb25cbiAgICogb25seSB1bm5lY2Vzc2FyaWx5IGluY3JlYXNlZCBBUEkgc3VyZmFjZSBidXQgb25seSB3cmFwcGVkIGFjY2Vzc2luZyB0aGUgb3B0aW9uLlxuICAgKi9cbiAgIHNob3VsZFNlbmREZWZhdWx0UGlpKCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0Q2xpZW50KCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGNsaWVudCAmJiBjbGllbnQuZ2V0T3B0aW9ucygpO1xuICAgIHJldHVybiBCb29sZWFuKG9wdGlvbnMgJiYgb3B0aW9ucy5zZW5kRGVmYXVsdFBpaSk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgdGhlIGN1cnJlbnQgU2Vzc2lvbiBvbiB0aGUgc2NvcGVcbiAgICovXG4gICBfc2VuZFNlc3Npb25VcGRhdGUoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gICAgY29uc3QgeyBzY29wZSwgY2xpZW50IH0gPSB0aGlzLmdldFN0YWNrVG9wKCk7XG5cbiAgICBjb25zdCBzZXNzaW9uID0gc2NvcGUuZ2V0U2Vzc2lvbigpO1xuICAgIGlmIChzZXNzaW9uICYmIGNsaWVudCAmJiBjbGllbnQuY2FwdHVyZVNlc3Npb24pIHtcbiAgICAgIGNsaWVudC5jYXB0dXJlU2Vzc2lvbihzZXNzaW9uKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsbHMgZ2xvYmFsIGV4dGVuc2lvbiBtZXRob2QgYW5kIGJpbmRpbmcgY3VycmVudCBpbnN0YW5jZSB0byB0aGUgZnVuY3Rpb24gY2FsbFxuICAgKi9cbiAgLy8gQHRzLWV4cGVjdC1lcnJvciBGdW5jdGlvbiBsYWNrcyBlbmRpbmcgcmV0dXJuIHN0YXRlbWVudCBhbmQgcmV0dXJuIHR5cGUgZG9lcyBub3QgaW5jbHVkZSAndW5kZWZpbmVkJy4gdHMoMjM2NilcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgIF9jYWxsRXh0ZW5zaW9uTWV0aG9kKG1ldGhvZCwgLi4uYXJncykge1xuICAgIGNvbnN0IGNhcnJpZXIgPSBnZXRNYWluQ2FycmllcigpO1xuICAgIGNvbnN0IHNlbnRyeSA9IGNhcnJpZXIuX19TRU5UUllfXztcbiAgICBpZiAoc2VudHJ5ICYmIHNlbnRyeS5leHRlbnNpb25zICYmIHR5cGVvZiBzZW50cnkuZXh0ZW5zaW9uc1ttZXRob2RdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gc2VudHJ5LmV4dGVuc2lvbnNbbWV0aG9kXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgREVCVUdfQlVJTEQgJiYgbG9nZ2VyLndhcm4oYEV4dGVuc2lvbiBtZXRob2QgJHttZXRob2R9IGNvdWxkbid0IGJlIGZvdW5kLCBkb2luZyBub3RoaW5nLmApO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZ2xvYmFsIHNoaW0gcmVnaXN0cnkuXG4gKlxuICogRklYTUU6IFRoaXMgZnVuY3Rpb24gaXMgcHJvYmxlbWF0aWMsIGJlY2F1c2UgZGVzcGl0ZSBhbHdheXMgcmV0dXJuaW5nIGEgdmFsaWQgQ2FycmllcixcbiAqIGl0IGhhcyBhbiBvcHRpb25hbCBgX19TRU5UUllfX2AgcHJvcGVydHksIHdoaWNoIHRoZW4gaW4gdHVybiByZXF1aXJlcyB1cyB0byBhbHdheXMgcGVyZm9ybSBhbiB1bm5lY2Vzc2FyeSBjaGVja1xuICogYXQgdGhlIGNhbGwtc2l0ZS4gV2UgYWx3YXlzIGFjY2VzcyB0aGUgY2FycmllciB0aHJvdWdoIHRoaXMgZnVuY3Rpb24sIHNvIHdlIGNhbiBndWFyYW50ZWUgdGhhdCBgX19TRU5UUllfX2AgaXMgdGhlcmUuXG4gKiovXG5mdW5jdGlvbiBnZXRNYWluQ2FycmllcigpIHtcbiAgR0xPQkFMX09CSi5fX1NFTlRSWV9fID0gR0xPQkFMX09CSi5fX1NFTlRSWV9fIHx8IHtcbiAgICBleHRlbnNpb25zOiB7fSxcbiAgICBodWI6IHVuZGVmaW5lZCxcbiAgfTtcbiAgcmV0dXJuIEdMT0JBTF9PQko7XG59XG5cbi8qKlxuICogUmVwbGFjZXMgdGhlIGN1cnJlbnQgbWFpbiBodWIgd2l0aCB0aGUgcGFzc2VkIG9uZSBvbiB0aGUgZ2xvYmFsIG9iamVjdFxuICpcbiAqIEByZXR1cm5zIFRoZSBvbGQgcmVwbGFjZWQgaHViXG4gKlxuICogQGRlcHJlY2F0ZWQgVXNlIGBzZXRDdXJyZW50Q2xpZW50KClgIGluc3RlYWQuXG4gKi9cbmZ1bmN0aW9uIG1ha2VNYWluKGh1Yikge1xuICBjb25zdCByZWdpc3RyeSA9IGdldE1haW5DYXJyaWVyKCk7XG4gIGNvbnN0IG9sZEh1YiA9IGdldEh1YkZyb21DYXJyaWVyKHJlZ2lzdHJ5KTtcbiAgc2V0SHViT25DYXJyaWVyKHJlZ2lzdHJ5LCBodWIpO1xuICByZXR1cm4gb2xkSHViO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGRlZmF1bHQgaHViIGluc3RhbmNlLlxuICpcbiAqIElmIGEgaHViIGlzIGFscmVhZHkgcmVnaXN0ZXJlZCBpbiB0aGUgZ2xvYmFsIGNhcnJpZXIgYnV0IHRoaXMgbW9kdWxlXG4gKiBjb250YWlucyBhIG1vcmUgcmVjZW50IHZlcnNpb24sIGl0IHJlcGxhY2VzIHRoZSByZWdpc3RlcmVkIHZlcnNpb24uXG4gKiBPdGhlcndpc2UsIHRoZSBjdXJyZW50bHkgcmVnaXN0ZXJlZCBodWIgd2lsbCBiZSByZXR1cm5lZC5cbiAqXG4gKiBAZGVwcmVjYXRlZCBVc2UgdGhlIHJlc3BlY3RpdmUgcmVwbGFjZW1lbnQgbWV0aG9kIGRpcmVjdGx5IGluc3RlYWQuXG4gKi9cbmZ1bmN0aW9uIGdldEN1cnJlbnRIdWIoKSB7XG4gIC8vIEdldCBtYWluIGNhcnJpZXIgKGdsb2JhbCBmb3IgZXZlcnkgZW52aXJvbm1lbnQpXG4gIGNvbnN0IHJlZ2lzdHJ5ID0gZ2V0TWFpbkNhcnJpZXIoKTtcblxuICBpZiAocmVnaXN0cnkuX19TRU5UUllfXyAmJiByZWdpc3RyeS5fX1NFTlRSWV9fLmFjcykge1xuICAgIGNvbnN0IGh1YiA9IHJlZ2lzdHJ5Ll9fU0VOVFJZX18uYWNzLmdldEN1cnJlbnRIdWIoKTtcblxuICAgIGlmIChodWIpIHtcbiAgICAgIHJldHVybiBodWI7XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0dXJuIGh1YiB0aGF0IGxpdmVzIG9uIGEgZ2xvYmFsIG9iamVjdFxuICByZXR1cm4gZ2V0R2xvYmFsSHViKHJlZ2lzdHJ5KTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnRseSBhY3RpdmUgaXNvbGF0aW9uIHNjb3BlLlxuICogVGhlIGlzb2xhdGlvbiBzY29wZSBpcyBhY3RpdmUgZm9yIHRoZSBjdXJyZW50IGV4ZWN0aW9uIGNvbnRleHQsXG4gKiBtZWFuaW5nIHRoYXQgaXQgd2lsbCByZW1haW4gc3RhYmxlIGZvciB0aGUgc2FtZSBIdWIuXG4gKi9cbmZ1bmN0aW9uIGdldElzb2xhdGlvblNjb3BlKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgcmV0dXJuIGdldEN1cnJlbnRIdWIoKS5nZXRJc29sYXRpb25TY29wZSgpO1xufVxuXG5mdW5jdGlvbiBnZXRHbG9iYWxIdWIocmVnaXN0cnkgPSBnZXRNYWluQ2FycmllcigpKSB7XG4gIC8vIElmIHRoZXJlJ3Mgbm8gaHViLCBvciBpdHMgYW4gb2xkIEFQSSwgYXNzaWduIGEgbmV3IG9uZVxuXG4gIGlmIChcbiAgICAhaGFzSHViT25DYXJyaWVyKHJlZ2lzdHJ5KSB8fFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICAgIGdldEh1YkZyb21DYXJyaWVyKHJlZ2lzdHJ5KS5pc09sZGVyVGhhbihBUElfVkVSU0lPTilcbiAgKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gICAgc2V0SHViT25DYXJyaWVyKHJlZ2lzdHJ5LCBuZXcgSHViKCkpO1xuICB9XG5cbiAgLy8gUmV0dXJuIGh1YiB0aGF0IGxpdmVzIG9uIGEgZ2xvYmFsIG9iamVjdFxuICByZXR1cm4gZ2V0SHViRnJvbUNhcnJpZXIocmVnaXN0cnkpO1xufVxuXG4vKipcbiAqIEBwcml2YXRlIFByaXZhdGUgQVBJIHdpdGggbm8gc2VtdmVyIGd1YXJhbnRlZXMhXG4gKlxuICogSWYgdGhlIGNhcnJpZXIgZG9lcyBub3QgY29udGFpbiBhIGh1YiwgYSBuZXcgaHViIGlzIGNyZWF0ZWQgd2l0aCB0aGUgZ2xvYmFsIGh1YiBjbGllbnQgYW5kIHNjb3BlLlxuICovXG5mdW5jdGlvbiBlbnN1cmVIdWJPbkNhcnJpZXIoY2FycmllciwgcGFyZW50ID0gZ2V0R2xvYmFsSHViKCkpIHtcbiAgLy8gSWYgdGhlcmUncyBubyBodWIgb24gY3VycmVudCBkb21haW4sIG9yIGl0J3MgYW4gb2xkIEFQSSwgYXNzaWduIGEgbmV3IG9uZVxuICBpZiAoXG4gICAgIWhhc0h1Yk9uQ2FycmllcihjYXJyaWVyKSB8fFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICAgIGdldEh1YkZyb21DYXJyaWVyKGNhcnJpZXIpLmlzT2xkZXJUaGFuKEFQSV9WRVJTSU9OKVxuICApIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgICBjb25zdCBjbGllbnQgPSBwYXJlbnQuZ2V0Q2xpZW50KCk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gICAgY29uc3Qgc2NvcGUgPSBwYXJlbnQuZ2V0U2NvcGUoKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgICBjb25zdCBpc29sYXRpb25TY29wZSA9IHBhcmVudC5nZXRJc29sYXRpb25TY29wZSgpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICAgIHNldEh1Yk9uQ2FycmllcihjYXJyaWVyLCBuZXcgSHViKGNsaWVudCwgc2NvcGUuY2xvbmUoKSwgaXNvbGF0aW9uU2NvcGUuY2xvbmUoKSkpO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGUgUHJpdmF0ZSBBUEkgd2l0aCBubyBzZW12ZXIgZ3VhcmFudGVlcyFcbiAqXG4gKiBTZXRzIHRoZSBnbG9iYWwgYXN5bmMgY29udGV4dCBzdHJhdGVneVxuICovXG5mdW5jdGlvbiBzZXRBc3luY0NvbnRleHRTdHJhdGVneShzdHJhdGVneSkge1xuICAvLyBHZXQgbWFpbiBjYXJyaWVyIChnbG9iYWwgZm9yIGV2ZXJ5IGVudmlyb25tZW50KVxuICBjb25zdCByZWdpc3RyeSA9IGdldE1haW5DYXJyaWVyKCk7XG4gIHJlZ2lzdHJ5Ll9fU0VOVFJZX18gPSByZWdpc3RyeS5fX1NFTlRSWV9fIHx8IHt9O1xuICByZWdpc3RyeS5fX1NFTlRSWV9fLmFjcyA9IHN0cmF0ZWd5O1xufVxuXG4vKipcbiAqIFJ1bnMgdGhlIHN1cHBsaWVkIGNhbGxiYWNrIGluIGl0cyBvd24gYXN5bmMgY29udGV4dC4gQXN5bmMgQ29udGV4dCBzdHJhdGVnaWVzIGFyZSBkZWZpbmVkIHBlciBTREsuXG4gKlxuICogQHBhcmFtIGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBydW4gaW4gaXRzIG93biBhc3luYyBjb250ZXh0XG4gKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIHRvIHBhc3MgdG8gdGhlIGFzeW5jIGNvbnRleHQgc3RyYXRlZ3lcbiAqIEByZXR1cm5zIFRoZSByZXN1bHQgb2YgdGhlIGNhbGxiYWNrXG4gKi9cbmZ1bmN0aW9uIHJ1bldpdGhBc3luY0NvbnRleHQoY2FsbGJhY2ssIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCByZWdpc3RyeSA9IGdldE1haW5DYXJyaWVyKCk7XG5cbiAgaWYgKHJlZ2lzdHJ5Ll9fU0VOVFJZX18gJiYgcmVnaXN0cnkuX19TRU5UUllfXy5hY3MpIHtcbiAgICByZXR1cm4gcmVnaXN0cnkuX19TRU5UUllfXy5hY3MucnVuV2l0aEFzeW5jQ29udGV4dChjYWxsYmFjaywgb3B0aW9ucyk7XG4gIH1cblxuICAvLyBpZiB0aGVyZSB3YXMgbm8gc3RyYXRlZ3ksIGZhbGxiYWNrIHRvIGp1c3QgY2FsbGluZyB0aGUgY2FsbGJhY2tcbiAgcmV0dXJuIGNhbGxiYWNrKCk7XG59XG5cbi8qKlxuICogVGhpcyB3aWxsIHRlbGwgd2hldGhlciBhIGNhcnJpZXIgaGFzIGEgaHViIG9uIGl0IG9yIG5vdFxuICogQHBhcmFtIGNhcnJpZXIgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGhhc0h1Yk9uQ2FycmllcihjYXJyaWVyKSB7XG4gIHJldHVybiAhIShjYXJyaWVyICYmIGNhcnJpZXIuX19TRU5UUllfXyAmJiBjYXJyaWVyLl9fU0VOVFJZX18uaHViKTtcbn1cblxuLyoqXG4gKiBUaGlzIHdpbGwgY3JlYXRlIGEgbmV3IHtAbGluayBIdWJ9IGFuZCBhZGQgdG8gdGhlIHBhc3NlZCBvYmplY3Qgb25cbiAqIF9fU0VOVFJZX18uaHViLlxuICogQHBhcmFtIGNhcnJpZXIgb2JqZWN0XG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIGdldEh1YkZyb21DYXJyaWVyKGNhcnJpZXIpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gIHJldHVybiBnZXRHbG9iYWxTaW5nbGV0b24oJ2h1YicsICgpID0+IG5ldyBIdWIoKSwgY2Fycmllcik7XG59XG5cbi8qKlxuICogVGhpcyB3aWxsIHNldCBwYXNzZWQge0BsaW5rIEh1Yn0gb24gdGhlIHBhc3NlZCBvYmplY3QncyBfX1NFTlRSWV9fLmh1YiBhdHRyaWJ1dGVcbiAqIEBwYXJhbSBjYXJyaWVyIG9iamVjdFxuICogQHBhcmFtIGh1YiBIdWJcbiAqIEByZXR1cm5zIEEgYm9vbGVhbiBpbmRpY2F0aW5nIHN1Y2Nlc3Mgb3IgZmFpbHVyZVxuICovXG5mdW5jdGlvbiBzZXRIdWJPbkNhcnJpZXIoY2FycmllciwgaHViKSB7XG4gIGlmICghY2FycmllcikgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBfX1NFTlRSWV9fID0gKGNhcnJpZXIuX19TRU5UUllfXyA9IGNhcnJpZXIuX19TRU5UUllfXyB8fCB7fSk7XG4gIF9fU0VOVFJZX18uaHViID0gaHViO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IHsgQVBJX1ZFUlNJT04sIEh1YiwgZW5zdXJlSHViT25DYXJyaWVyLCBnZXRDdXJyZW50SHViLCBnZXRIdWJGcm9tQ2FycmllciwgZ2V0SXNvbGF0aW9uU2NvcGUsIGdldE1haW5DYXJyaWVyLCBtYWtlTWFpbiwgcnVuV2l0aEFzeW5jQ29udGV4dCwgc2V0QXN5bmNDb250ZXh0U3RyYXRlZ3ksIHNldEh1Yk9uQ2FycmllciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aHViLmpzLm1hcFxuIl0sIm5hbWVzIjpbImlzVGhlbmFibGUiLCJ1dWlkNCIsImRhdGVUaW1lc3RhbXBJblNlY29uZHMiLCJjb25zb2xlU2FuZGJveCIsImxvZ2dlciIsIkdMT0JBTF9PQkoiLCJnZXRHbG9iYWxTaW5nbGV0b24iLCJERUZBVUxUX0VOVklST05NRU5UIiwiREVCVUdfQlVJTEQiLCJTY29wZSIsImNsb3NlU2Vzc2lvbiIsIm1ha2VTZXNzaW9uIiwidXBkYXRlU2Vzc2lvbiIsIlNES19WRVJTSU9OIiwiQVBJX1ZFUlNJT04iLCJwYXJzZUZsb2F0IiwiREVGQVVMVF9CUkVBRENSVU1CUyIsIkh1YiIsImNvbnN0cnVjdG9yIiwiY2xpZW50Iiwic2NvcGUiLCJpc29sYXRpb25TY29wZSIsIl92ZXJzaW9uIiwiYXNzaWduZWRTY29wZSIsInNldENsaWVudCIsImFzc2lnbmVkSXNvbGF0aW9uU2NvcGUiLCJfc3RhY2siLCJiaW5kQ2xpZW50IiwiX2lzb2xhdGlvblNjb3BlIiwiaXNPbGRlclRoYW4iLCJ2ZXJzaW9uIiwidG9wIiwiZ2V0U3RhY2tUb3AiLCJzZXR1cEludGVncmF0aW9ucyIsInB1c2hTY29wZSIsImdldFNjb3BlIiwiY2xvbmUiLCJnZXRTdGFjayIsInB1c2giLCJnZXRDbGllbnQiLCJwb3BTY29wZSIsImxlbmd0aCIsInBvcCIsIndpdGhTY29wZSIsImNhbGxiYWNrIiwibWF5YmVQcm9taXNlUmVzdWx0IiwiZSIsInRoZW4iLCJyZXMiLCJnZXRJc29sYXRpb25TY29wZSIsImNhcHR1cmVFeGNlcHRpb24iLCJleGNlcHRpb24iLCJoaW50IiwiZXZlbnRJZCIsIl9sYXN0RXZlbnRJZCIsImV2ZW50X2lkIiwic3ludGhldGljRXhjZXB0aW9uIiwiRXJyb3IiLCJvcmlnaW5hbEV4Y2VwdGlvbiIsImNhcHR1cmVNZXNzYWdlIiwibWVzc2FnZSIsImxldmVsIiwiY2FwdHVyZUV2ZW50IiwiZXZlbnQiLCJ0eXBlIiwibGFzdEV2ZW50SWQiLCJhZGRCcmVhZGNydW1iIiwiYnJlYWRjcnVtYiIsImJlZm9yZUJyZWFkY3J1bWIiLCJtYXhCcmVhZGNydW1icyIsImdldE9wdGlvbnMiLCJ0aW1lc3RhbXAiLCJtZXJnZWRCcmVhZGNydW1iIiwiZmluYWxCcmVhZGNydW1iIiwiZW1pdCIsInNldFVzZXIiLCJ1c2VyIiwic2V0VGFncyIsInRhZ3MiLCJzZXRFeHRyYXMiLCJleHRyYXMiLCJzZXRUYWciLCJrZXkiLCJ2YWx1ZSIsInNldEV4dHJhIiwiZXh0cmEiLCJzZXRDb250ZXh0IiwibmFtZSIsImNvbnRleHQiLCJjb25maWd1cmVTY29wZSIsInJ1biIsIm9sZEh1YiIsIm1ha2VNYWluIiwiZ2V0SW50ZWdyYXRpb24iLCJpbnRlZ3JhdGlvbiIsIl9vTyIsIndhcm4iLCJpZCIsInN0YXJ0VHJhbnNhY3Rpb24iLCJjdXN0b21TYW1wbGluZ0NvbnRleHQiLCJyZXN1bHQiLCJfY2FsbEV4dGVuc2lvbk1ldGhvZCIsInRyYWNlSGVhZGVycyIsImNhcHR1cmVTZXNzaW9uIiwiZW5kU2Vzc2lvbiIsIl9zZW5kU2Vzc2lvblVwZGF0ZSIsImxheWVyIiwic2Vzc2lvbiIsImdldFNlc3Npb24iLCJzZXRTZXNzaW9uIiwic3RhcnRTZXNzaW9uIiwicmVsZWFzZSIsImVudmlyb25tZW50IiwidXNlckFnZW50IiwibmF2aWdhdG9yIiwiZ2V0VXNlciIsImN1cnJlbnRTZXNzaW9uIiwic3RhdHVzIiwic2hvdWxkU2VuZERlZmF1bHRQaWkiLCJvcHRpb25zIiwiQm9vbGVhbiIsInNlbmREZWZhdWx0UGlpIiwibWV0aG9kIiwiYXJncyIsImNhcnJpZXIiLCJnZXRNYWluQ2FycmllciIsInNlbnRyeSIsIl9fU0VOVFJZX18iLCJleHRlbnNpb25zIiwiYXBwbHkiLCJodWIiLCJ1bmRlZmluZWQiLCJyZWdpc3RyeSIsImdldEh1YkZyb21DYXJyaWVyIiwic2V0SHViT25DYXJyaWVyIiwiZ2V0Q3VycmVudEh1YiIsImFjcyIsImdldEdsb2JhbEh1YiIsImhhc0h1Yk9uQ2FycmllciIsImVuc3VyZUh1Yk9uQ2FycmllciIsInBhcmVudCIsInNldEFzeW5jQ29udGV4dFN0cmF0ZWd5Iiwic3RyYXRlZ3kiLCJydW5XaXRoQXN5bmNDb250ZXh0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/core/esm/hub.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sentry/core/esm/scope.js":
/*!************************************************!*\
  !*** ./node_modules/@sentry/core/esm/scope.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Scope: () => (/* binding */ Scope),\n/* harmony export */   getGlobalScope: () => (/* binding */ getGlobalScope),\n/* harmony export */   setGlobalScope: () => (/* binding */ setGlobalScope)\n/* harmony export */ });\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @sentry/utils */ \"(ssr)/./node_modules/@sentry/utils/esm/is.js\");\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sentry/utils */ \"(ssr)/./node_modules/@sentry/utils/esm/time.js\");\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @sentry/utils */ \"(ssr)/./node_modules/@sentry/utils/esm/misc.js\");\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @sentry/utils */ \"(ssr)/./node_modules/@sentry/utils/esm/logger.js\");\n/* harmony import */ var _eventProcessors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./eventProcessors.js */ \"(ssr)/./node_modules/@sentry/core/esm/eventProcessors.js\");\n/* harmony import */ var _session_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./session.js */ \"(ssr)/./node_modules/@sentry/core/esm/session.js\");\n/* harmony import */ var _utils_applyScopeDataToEvent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/applyScopeDataToEvent.js */ \"(ssr)/./node_modules/@sentry/core/esm/utils/applyScopeDataToEvent.js\");\n\n\n\n\n/**\n * Default value for maximum number of breadcrumbs added to an event.\n */ const DEFAULT_MAX_BREADCRUMBS = 100;\n/**\n * The global scope is kept in this module.\n * When accessing this via `getGlobalScope()` we'll make sure to set one if none is currently present.\n */ let globalScope;\n/**\n * Holds additional event information. {@link Scope.applyToEvent} will be\n * called by the client before an event will be sent.\n */ class Scope {\n    /** Flag if notifying is happening. */ /** Callback for client to receive scope changes. */ /** Callback list that will be called after {@link applyToEvent}. */ /** Array of breadcrumbs. */ /** User */ /** Tags */ /** Extra */ /** Contexts */ /** Attachments */ /** Propagation Context for distributed tracing */ /**\n   * A place to stash data which is needed at some point in the SDK's event processing pipeline but which shouldn't get\n   * sent to Sentry\n   */ /** Fingerprint */ /** Severity */ // eslint-disable-next-line deprecation/deprecation\n    /**\n   * Transaction Name\n   */ /** Span */ /** Session */ /** Request Mode Session Status */ /** The client on this scope */ // NOTE: Any field which gets added here should get added not only to the constructor but also to the `clone` method.\n    constructor(){\n        this._notifyingListeners = false;\n        this._scopeListeners = [];\n        this._eventProcessors = [];\n        this._breadcrumbs = [];\n        this._attachments = [];\n        this._user = {};\n        this._tags = {};\n        this._extra = {};\n        this._contexts = {};\n        this._sdkProcessingMetadata = {};\n        this._propagationContext = generatePropagationContext();\n    }\n    /**\n   * Inherit values from the parent scope.\n   * @deprecated Use `scope.clone()` and `new Scope()` instead.\n   */ static clone(scope) {\n        return scope ? scope.clone() : new Scope();\n    }\n    /**\n   * Clone this scope instance.\n   */ clone() {\n        const newScope = new Scope();\n        newScope._breadcrumbs = [\n            ...this._breadcrumbs\n        ];\n        newScope._tags = {\n            ...this._tags\n        };\n        newScope._extra = {\n            ...this._extra\n        };\n        newScope._contexts = {\n            ...this._contexts\n        };\n        newScope._user = this._user;\n        newScope._level = this._level;\n        newScope._span = this._span;\n        newScope._session = this._session;\n        newScope._transactionName = this._transactionName;\n        newScope._fingerprint = this._fingerprint;\n        newScope._eventProcessors = [\n            ...this._eventProcessors\n        ];\n        newScope._requestSession = this._requestSession;\n        newScope._attachments = [\n            ...this._attachments\n        ];\n        newScope._sdkProcessingMetadata = {\n            ...this._sdkProcessingMetadata\n        };\n        newScope._propagationContext = {\n            ...this._propagationContext\n        };\n        newScope._client = this._client;\n        return newScope;\n    }\n    /** Update the client on the scope. */ setClient(client) {\n        this._client = client;\n    }\n    /**\n   * Get the client assigned to this scope.\n   *\n   * It is generally recommended to use the global function `Sentry.getClient()` instead, unless you know what you are doing.\n   */ getClient() {\n        return this._client;\n    }\n    /**\n   * Add internal on change listener. Used for sub SDKs that need to store the scope.\n   * @hidden\n   */ addScopeListener(callback) {\n        this._scopeListeners.push(callback);\n    }\n    /**\n   * @inheritDoc\n   */ addEventProcessor(callback) {\n        this._eventProcessors.push(callback);\n        return this;\n    }\n    /**\n   * @inheritDoc\n   */ setUser(user) {\n        // If null is passed we want to unset everything, but still define keys,\n        // so that later down in the pipeline any existing values are cleared.\n        this._user = user || {\n            email: undefined,\n            id: undefined,\n            ip_address: undefined,\n            segment: undefined,\n            username: undefined\n        };\n        if (this._session) {\n            (0,_session_js__WEBPACK_IMPORTED_MODULE_0__.updateSession)(this._session, {\n                user\n            });\n        }\n        this._notifyScopeListeners();\n        return this;\n    }\n    /**\n   * @inheritDoc\n   */ getUser() {\n        return this._user;\n    }\n    /**\n   * @inheritDoc\n   */ getRequestSession() {\n        return this._requestSession;\n    }\n    /**\n   * @inheritDoc\n   */ setRequestSession(requestSession) {\n        this._requestSession = requestSession;\n        return this;\n    }\n    /**\n   * @inheritDoc\n   */ setTags(tags) {\n        this._tags = {\n            ...this._tags,\n            ...tags\n        };\n        this._notifyScopeListeners();\n        return this;\n    }\n    /**\n   * @inheritDoc\n   */ setTag(key, value) {\n        this._tags = {\n            ...this._tags,\n            [key]: value\n        };\n        this._notifyScopeListeners();\n        return this;\n    }\n    /**\n   * @inheritDoc\n   */ setExtras(extras) {\n        this._extra = {\n            ...this._extra,\n            ...extras\n        };\n        this._notifyScopeListeners();\n        return this;\n    }\n    /**\n   * @inheritDoc\n   */ setExtra(key, extra) {\n        this._extra = {\n            ...this._extra,\n            [key]: extra\n        };\n        this._notifyScopeListeners();\n        return this;\n    }\n    /**\n   * @inheritDoc\n   */ setFingerprint(fingerprint) {\n        this._fingerprint = fingerprint;\n        this._notifyScopeListeners();\n        return this;\n    }\n    /**\n   * @inheritDoc\n   */ setLevel(// eslint-disable-next-line deprecation/deprecation\n    level) {\n        this._level = level;\n        this._notifyScopeListeners();\n        return this;\n    }\n    /**\n   * Sets the transaction name on the scope for future events.\n   * @deprecated Use extra or tags instead.\n   */ setTransactionName(name) {\n        this._transactionName = name;\n        this._notifyScopeListeners();\n        return this;\n    }\n    /**\n   * @inheritDoc\n   */ setContext(key, context) {\n        if (context === null) {\n            // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n            delete this._contexts[key];\n        } else {\n            this._contexts[key] = context;\n        }\n        this._notifyScopeListeners();\n        return this;\n    }\n    /**\n   * Sets the Span on the scope.\n   * @param span Span\n   * @deprecated Instead of setting a span on a scope, use `startSpan()`/`startSpanManual()` instead.\n   */ setSpan(span) {\n        this._span = span;\n        this._notifyScopeListeners();\n        return this;\n    }\n    /**\n   * Returns the `Span` if there is one.\n   * @deprecated Use `getActiveSpan()` instead.\n   */ getSpan() {\n        return this._span;\n    }\n    /**\n   * Returns the `Transaction` attached to the scope (if there is one).\n   * @deprecated You should not rely on the transaction, but just use `startSpan()` APIs instead.\n   */ getTransaction() {\n        // Often, this span (if it exists at all) will be a transaction, but it's not guaranteed to be. Regardless, it will\n        // have a pointer to the currently-active transaction.\n        const span = this._span;\n        // Cannot replace with getRootSpan because getRootSpan returns a span, not a transaction\n        // Also, this method will be removed anyway.\n        // eslint-disable-next-line deprecation/deprecation\n        return span && span.transaction;\n    }\n    /**\n   * @inheritDoc\n   */ setSession(session) {\n        if (!session) {\n            delete this._session;\n        } else {\n            this._session = session;\n        }\n        this._notifyScopeListeners();\n        return this;\n    }\n    /**\n   * @inheritDoc\n   */ getSession() {\n        return this._session;\n    }\n    /**\n   * @inheritDoc\n   */ update(captureContext) {\n        if (!captureContext) {\n            return this;\n        }\n        const scopeToMerge = typeof captureContext === \"function\" ? captureContext(this) : captureContext;\n        if (scopeToMerge instanceof Scope) {\n            const scopeData = scopeToMerge.getScopeData();\n            this._tags = {\n                ...this._tags,\n                ...scopeData.tags\n            };\n            this._extra = {\n                ...this._extra,\n                ...scopeData.extra\n            };\n            this._contexts = {\n                ...this._contexts,\n                ...scopeData.contexts\n            };\n            if (scopeData.user && Object.keys(scopeData.user).length) {\n                this._user = scopeData.user;\n            }\n            if (scopeData.level) {\n                this._level = scopeData.level;\n            }\n            if (scopeData.fingerprint.length) {\n                this._fingerprint = scopeData.fingerprint;\n            }\n            if (scopeToMerge.getRequestSession()) {\n                this._requestSession = scopeToMerge.getRequestSession();\n            }\n            if (scopeData.propagationContext) {\n                this._propagationContext = scopeData.propagationContext;\n            }\n        } else if ((0,_sentry_utils__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(scopeToMerge)) {\n            const scopeContext = captureContext;\n            this._tags = {\n                ...this._tags,\n                ...scopeContext.tags\n            };\n            this._extra = {\n                ...this._extra,\n                ...scopeContext.extra\n            };\n            this._contexts = {\n                ...this._contexts,\n                ...scopeContext.contexts\n            };\n            if (scopeContext.user) {\n                this._user = scopeContext.user;\n            }\n            if (scopeContext.level) {\n                this._level = scopeContext.level;\n            }\n            if (scopeContext.fingerprint) {\n                this._fingerprint = scopeContext.fingerprint;\n            }\n            if (scopeContext.requestSession) {\n                this._requestSession = scopeContext.requestSession;\n            }\n            if (scopeContext.propagationContext) {\n                this._propagationContext = scopeContext.propagationContext;\n            }\n        }\n        return this;\n    }\n    /**\n   * @inheritDoc\n   */ clear() {\n        this._breadcrumbs = [];\n        this._tags = {};\n        this._extra = {};\n        this._user = {};\n        this._contexts = {};\n        this._level = undefined;\n        this._transactionName = undefined;\n        this._fingerprint = undefined;\n        this._requestSession = undefined;\n        this._span = undefined;\n        this._session = undefined;\n        this._notifyScopeListeners();\n        this._attachments = [];\n        this._propagationContext = generatePropagationContext();\n        return this;\n    }\n    /**\n   * @inheritDoc\n   */ addBreadcrumb(breadcrumb, maxBreadcrumbs) {\n        const maxCrumbs = typeof maxBreadcrumbs === \"number\" ? maxBreadcrumbs : DEFAULT_MAX_BREADCRUMBS;\n        // No data has been changed, so don't notify scope listeners\n        if (maxCrumbs <= 0) {\n            return this;\n        }\n        const mergedBreadcrumb = {\n            timestamp: (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_2__.dateTimestampInSeconds)(),\n            ...breadcrumb\n        };\n        const breadcrumbs = this._breadcrumbs;\n        breadcrumbs.push(mergedBreadcrumb);\n        this._breadcrumbs = breadcrumbs.length > maxCrumbs ? breadcrumbs.slice(-maxCrumbs) : breadcrumbs;\n        this._notifyScopeListeners();\n        return this;\n    }\n    /**\n   * @inheritDoc\n   */ getLastBreadcrumb() {\n        return this._breadcrumbs[this._breadcrumbs.length - 1];\n    }\n    /**\n   * @inheritDoc\n   */ clearBreadcrumbs() {\n        this._breadcrumbs = [];\n        this._notifyScopeListeners();\n        return this;\n    }\n    /**\n   * @inheritDoc\n   */ addAttachment(attachment) {\n        this._attachments.push(attachment);\n        return this;\n    }\n    /**\n   * @inheritDoc\n   * @deprecated Use `getScopeData()` instead.\n   */ getAttachments() {\n        const data = this.getScopeData();\n        return data.attachments;\n    }\n    /**\n   * @inheritDoc\n   */ clearAttachments() {\n        this._attachments = [];\n        return this;\n    }\n    /** @inheritDoc */ getScopeData() {\n        const { _breadcrumbs, _attachments, _contexts, _tags, _extra, _user, _level, _fingerprint, _eventProcessors, _propagationContext, _sdkProcessingMetadata, _transactionName, _span } = this;\n        return {\n            breadcrumbs: _breadcrumbs,\n            attachments: _attachments,\n            contexts: _contexts,\n            tags: _tags,\n            extra: _extra,\n            user: _user,\n            level: _level,\n            fingerprint: _fingerprint || [],\n            eventProcessors: _eventProcessors,\n            propagationContext: _propagationContext,\n            sdkProcessingMetadata: _sdkProcessingMetadata,\n            transactionName: _transactionName,\n            span: _span\n        };\n    }\n    /**\n   * Applies data from the scope to the event and runs all event processors on it.\n   *\n   * @param event Event\n   * @param hint Object containing additional information about the original exception, for use by the event processors.\n   * @hidden\n   * @deprecated Use `applyScopeDataToEvent()` directly\n   */ applyToEvent(event, hint = {}, additionalEventProcessors = []) {\n        (0,_utils_applyScopeDataToEvent_js__WEBPACK_IMPORTED_MODULE_3__.applyScopeDataToEvent)(event, this.getScopeData());\n        // TODO (v8): Update this order to be: Global > Client > Scope\n        const eventProcessors = [\n            ...additionalEventProcessors,\n            // eslint-disable-next-line deprecation/deprecation\n            ...(0,_eventProcessors_js__WEBPACK_IMPORTED_MODULE_4__.getGlobalEventProcessors)(),\n            ...this._eventProcessors\n        ];\n        return (0,_eventProcessors_js__WEBPACK_IMPORTED_MODULE_4__.notifyEventProcessors)(eventProcessors, event, hint);\n    }\n    /**\n   * Add data which will be accessible during event processing but won't get sent to Sentry\n   */ setSDKProcessingMetadata(newData) {\n        this._sdkProcessingMetadata = {\n            ...this._sdkProcessingMetadata,\n            ...newData\n        };\n        return this;\n    }\n    /**\n   * @inheritDoc\n   */ setPropagationContext(context) {\n        this._propagationContext = context;\n        return this;\n    }\n    /**\n   * @inheritDoc\n   */ getPropagationContext() {\n        return this._propagationContext;\n    }\n    /**\n   * Capture an exception for this scope.\n   *\n   * @param exception The exception to capture.\n   * @param hint Optinal additional data to attach to the Sentry event.\n   * @returns the id of the captured Sentry event.\n   */ captureException(exception, hint) {\n        const eventId = hint && hint.event_id ? hint.event_id : (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_5__.uuid4)();\n        if (!this._client) {\n            _sentry_utils__WEBPACK_IMPORTED_MODULE_6__.logger.warn(\"No client configured on scope - will not capture exception!\");\n            return eventId;\n        }\n        const syntheticException = new Error(\"Sentry syntheticException\");\n        this._client.captureException(exception, {\n            originalException: exception,\n            syntheticException,\n            ...hint,\n            event_id: eventId\n        }, this);\n        return eventId;\n    }\n    /**\n   * Capture a message for this scope.\n   *\n   * @param message The message to capture.\n   * @param level An optional severity level to report the message with.\n   * @param hint Optional additional data to attach to the Sentry event.\n   * @returns the id of the captured message.\n   */ captureMessage(message, level, hint) {\n        const eventId = hint && hint.event_id ? hint.event_id : (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_5__.uuid4)();\n        if (!this._client) {\n            _sentry_utils__WEBPACK_IMPORTED_MODULE_6__.logger.warn(\"No client configured on scope - will not capture message!\");\n            return eventId;\n        }\n        const syntheticException = new Error(message);\n        this._client.captureMessage(message, level, {\n            originalException: message,\n            syntheticException,\n            ...hint,\n            event_id: eventId\n        }, this);\n        return eventId;\n    }\n    /**\n   * Captures a manually created event for this scope and sends it to Sentry.\n   *\n   * @param exception The event to capture.\n   * @param hint Optional additional data to attach to the Sentry event.\n   * @returns the id of the captured event.\n   */ captureEvent(event, hint) {\n        const eventId = hint && hint.event_id ? hint.event_id : (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_5__.uuid4)();\n        if (!this._client) {\n            _sentry_utils__WEBPACK_IMPORTED_MODULE_6__.logger.warn(\"No client configured on scope - will not capture event!\");\n            return eventId;\n        }\n        this._client.captureEvent(event, {\n            ...hint,\n            event_id: eventId\n        }, this);\n        return eventId;\n    }\n    /**\n   * This will be called on every set call.\n   */ _notifyScopeListeners() {\n        // We need this check for this._notifyingListeners to be able to work on scope during updates\n        // If this check is not here we'll produce endless recursion when something is done with the scope\n        // during the callback.\n        if (!this._notifyingListeners) {\n            this._notifyingListeners = true;\n            this._scopeListeners.forEach((callback)=>{\n                callback(this);\n            });\n            this._notifyingListeners = false;\n        }\n    }\n}\n/**\n * Get the global scope.\n * This scope is applied to _all_ events.\n */ function getGlobalScope() {\n    if (!globalScope) {\n        globalScope = new Scope();\n    }\n    return globalScope;\n}\n/**\n * This is mainly needed for tests.\n * DO NOT USE this, as this is an internal API and subject to change.\n * @hidden\n */ function setGlobalScope(scope) {\n    globalScope = scope;\n}\nfunction generatePropagationContext() {\n    return {\n        traceId: (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_5__.uuid4)(),\n        spanId: (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_5__.uuid4)().substring(16)\n    };\n}\n //# sourceMappingURL=scope.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2VzbS9zY29wZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQXFGO0FBQ0U7QUFDMUM7QUFDNEI7QUFFekU7O0NBRUMsR0FDRCxNQUFNUSwwQkFBMEI7QUFFaEM7OztDQUdDLEdBQ0QsSUFBSUM7QUFFSjs7O0NBR0MsR0FDRCxNQUFNQztJQUNKLG9DQUFvQyxHQUVwQyxrREFBa0QsR0FFbEQsa0VBQWtFLEdBRWxFLDBCQUEwQixHQUUxQixTQUFTLEdBRVQsU0FBUyxHQUVULFVBQVUsR0FFVixhQUFhLEdBRWIsZ0JBQWdCLEdBRWhCLGdEQUFnRCxHQUVoRDs7O0dBR0MsR0FFRCxnQkFBZ0IsR0FFaEIsYUFBYSxHQUNiLG1EQUFtRDtJQUVuRDs7R0FFQyxHQUVELFNBQVMsR0FFVCxZQUFZLEdBRVosZ0NBQWdDLEdBRWhDLDZCQUE2QixHQUU3QixxSEFBcUg7SUFFcEhDLGFBQWM7UUFDYixJQUFJLENBQUNDLG1CQUFtQixHQUFHO1FBQzNCLElBQUksQ0FBQ0MsZUFBZSxHQUFHLEVBQUU7UUFDekIsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBRyxFQUFFO1FBQzFCLElBQUksQ0FBQ0MsWUFBWSxHQUFHLEVBQUU7UUFDdEIsSUFBSSxDQUFDQyxZQUFZLEdBQUcsRUFBRTtRQUN0QixJQUFJLENBQUNDLEtBQUssR0FBRyxDQUFDO1FBQ2QsSUFBSSxDQUFDQyxLQUFLLEdBQUcsQ0FBQztRQUNkLElBQUksQ0FBQ0MsTUFBTSxHQUFHLENBQUM7UUFDZixJQUFJLENBQUNDLFNBQVMsR0FBRyxDQUFDO1FBQ2xCLElBQUksQ0FBQ0Msc0JBQXNCLEdBQUcsQ0FBQztRQUMvQixJQUFJLENBQUNDLG1CQUFtQixHQUFHQztJQUM3QjtJQUVBOzs7R0FHQyxHQUNBLE9BQU9DLE1BQU1DLEtBQUssRUFBRTtRQUNuQixPQUFPQSxRQUFRQSxNQUFNRCxLQUFLLEtBQUssSUFBSWQ7SUFDckM7SUFFQTs7R0FFQyxHQUNBYyxRQUFR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UUFBUUEsS0FBS1MsUUFBUSxHQUFHVCxLQUFLUyxRQUFRLEdBQUd2SCxvREFBS0E7UUFFN0QsSUFBSSxDQUFDLElBQUksQ0FBQytCLE9BQU8sRUFBRTtZQUNqQjlCLGlEQUFNQSxDQUFDdUgsSUFBSSxDQUFDO1lBQ1osT0FBT0Y7UUFDVDtRQUVBLElBQUksQ0FBQ3ZGLE9BQU8sQ0FBQytGLFlBQVksQ0FBQ2pCLE9BQU87WUFBRSxHQUFHQyxJQUFJO1lBQUVTLFVBQVVEO1FBQVEsR0FBRyxJQUFJO1FBRXJFLE9BQU9BO0lBQ1Q7SUFFQTs7R0FFQyxHQUNBdkUsd0JBQXdCO1FBQ3ZCLDZGQUE2RjtRQUM3RixrR0FBa0c7UUFDbEcsdUJBQXVCO1FBQ3ZCLElBQUksQ0FBQyxJQUFJLENBQUNyQyxtQkFBbUIsRUFBRTtZQUM3QixJQUFJLENBQUNBLG1CQUFtQixHQUFHO1lBQzNCLElBQUksQ0FBQ0MsZUFBZSxDQUFDb0gsT0FBTyxDQUFDM0YsQ0FBQUE7Z0JBQzNCQSxTQUFTLElBQUk7WUFDZjtZQUNBLElBQUksQ0FBQzFCLG1CQUFtQixHQUFHO1FBQzdCO0lBQ0Y7QUFDRjtBQUVBOzs7Q0FHQyxHQUNELFNBQVNzSDtJQUNQLElBQUksQ0FBQ3pILGFBQWE7UUFDaEJBLGNBQWMsSUFBSUM7SUFDcEI7SUFFQSxPQUFPRDtBQUNUO0FBRUE7Ozs7Q0FJQyxHQUNELFNBQVMwSCxlQUFlMUcsS0FBSztJQUMzQmhCLGNBQWNnQjtBQUNoQjtBQUVBLFNBQVNGO0lBQ1AsT0FBTztRQUNMNkcsU0FBU2xJLG9EQUFLQTtRQUNkbUksUUFBUW5JLG9EQUFLQSxHQUFHb0ksU0FBUyxDQUFDO0lBQzVCO0FBQ0Y7QUFFaUQsQ0FDakQsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb2JyYWxpbmstd2ViLy4vbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9lc20vc2NvcGUuanM/OTVhZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc1BsYWluT2JqZWN0LCBkYXRlVGltZXN0YW1wSW5TZWNvbmRzLCB1dWlkNCwgbG9nZ2VyIH0gZnJvbSAnQHNlbnRyeS91dGlscyc7XG5pbXBvcnQgeyBnZXRHbG9iYWxFdmVudFByb2Nlc3NvcnMsIG5vdGlmeUV2ZW50UHJvY2Vzc29ycyB9IGZyb20gJy4vZXZlbnRQcm9jZXNzb3JzLmpzJztcbmltcG9ydCB7IHVwZGF0ZVNlc3Npb24gfSBmcm9tICcuL3Nlc3Npb24uanMnO1xuaW1wb3J0IHsgYXBwbHlTY29wZURhdGFUb0V2ZW50IH0gZnJvbSAnLi91dGlscy9hcHBseVNjb3BlRGF0YVRvRXZlbnQuanMnO1xuXG4vKipcbiAqIERlZmF1bHQgdmFsdWUgZm9yIG1heGltdW0gbnVtYmVyIG9mIGJyZWFkY3J1bWJzIGFkZGVkIHRvIGFuIGV2ZW50LlxuICovXG5jb25zdCBERUZBVUxUX01BWF9CUkVBRENSVU1CUyA9IDEwMDtcblxuLyoqXG4gKiBUaGUgZ2xvYmFsIHNjb3BlIGlzIGtlcHQgaW4gdGhpcyBtb2R1bGUuXG4gKiBXaGVuIGFjY2Vzc2luZyB0aGlzIHZpYSBgZ2V0R2xvYmFsU2NvcGUoKWAgd2UnbGwgbWFrZSBzdXJlIHRvIHNldCBvbmUgaWYgbm9uZSBpcyBjdXJyZW50bHkgcHJlc2VudC5cbiAqL1xubGV0IGdsb2JhbFNjb3BlO1xuXG4vKipcbiAqIEhvbGRzIGFkZGl0aW9uYWwgZXZlbnQgaW5mb3JtYXRpb24uIHtAbGluayBTY29wZS5hcHBseVRvRXZlbnR9IHdpbGwgYmVcbiAqIGNhbGxlZCBieSB0aGUgY2xpZW50IGJlZm9yZSBhbiBldmVudCB3aWxsIGJlIHNlbnQuXG4gKi9cbmNsYXNzIFNjb3BlICB7XG4gIC8qKiBGbGFnIGlmIG5vdGlmeWluZyBpcyBoYXBwZW5pbmcuICovXG5cbiAgLyoqIENhbGxiYWNrIGZvciBjbGllbnQgdG8gcmVjZWl2ZSBzY29wZSBjaGFuZ2VzLiAqL1xuXG4gIC8qKiBDYWxsYmFjayBsaXN0IHRoYXQgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIge0BsaW5rIGFwcGx5VG9FdmVudH0uICovXG5cbiAgLyoqIEFycmF5IG9mIGJyZWFkY3J1bWJzLiAqL1xuXG4gIC8qKiBVc2VyICovXG5cbiAgLyoqIFRhZ3MgKi9cblxuICAvKiogRXh0cmEgKi9cblxuICAvKiogQ29udGV4dHMgKi9cblxuICAvKiogQXR0YWNobWVudHMgKi9cblxuICAvKiogUHJvcGFnYXRpb24gQ29udGV4dCBmb3IgZGlzdHJpYnV0ZWQgdHJhY2luZyAqL1xuXG4gIC8qKlxuICAgKiBBIHBsYWNlIHRvIHN0YXNoIGRhdGEgd2hpY2ggaXMgbmVlZGVkIGF0IHNvbWUgcG9pbnQgaW4gdGhlIFNESydzIGV2ZW50IHByb2Nlc3NpbmcgcGlwZWxpbmUgYnV0IHdoaWNoIHNob3VsZG4ndCBnZXRcbiAgICogc2VudCB0byBTZW50cnlcbiAgICovXG5cbiAgLyoqIEZpbmdlcnByaW50ICovXG5cbiAgLyoqIFNldmVyaXR5ICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuXG4gIC8qKlxuICAgKiBUcmFuc2FjdGlvbiBOYW1lXG4gICAqL1xuXG4gIC8qKiBTcGFuICovXG5cbiAgLyoqIFNlc3Npb24gKi9cblxuICAvKiogUmVxdWVzdCBNb2RlIFNlc3Npb24gU3RhdHVzICovXG5cbiAgLyoqIFRoZSBjbGllbnQgb24gdGhpcyBzY29wZSAqL1xuXG4gIC8vIE5PVEU6IEFueSBmaWVsZCB3aGljaCBnZXRzIGFkZGVkIGhlcmUgc2hvdWxkIGdldCBhZGRlZCBub3Qgb25seSB0byB0aGUgY29uc3RydWN0b3IgYnV0IGFsc28gdG8gdGhlIGBjbG9uZWAgbWV0aG9kLlxuXG4gICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9ub3RpZnlpbmdMaXN0ZW5lcnMgPSBmYWxzZTtcbiAgICB0aGlzLl9zY29wZUxpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMuX2V2ZW50UHJvY2Vzc29ycyA9IFtdO1xuICAgIHRoaXMuX2JyZWFkY3J1bWJzID0gW107XG4gICAgdGhpcy5fYXR0YWNobWVudHMgPSBbXTtcbiAgICB0aGlzLl91c2VyID0ge307XG4gICAgdGhpcy5fdGFncyA9IHt9O1xuICAgIHRoaXMuX2V4dHJhID0ge307XG4gICAgdGhpcy5fY29udGV4dHMgPSB7fTtcbiAgICB0aGlzLl9zZGtQcm9jZXNzaW5nTWV0YWRhdGEgPSB7fTtcbiAgICB0aGlzLl9wcm9wYWdhdGlvbkNvbnRleHQgPSBnZW5lcmF0ZVByb3BhZ2F0aW9uQ29udGV4dCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaGVyaXQgdmFsdWVzIGZyb20gdGhlIHBhcmVudCBzY29wZS5cbiAgICogQGRlcHJlY2F0ZWQgVXNlIGBzY29wZS5jbG9uZSgpYCBhbmQgYG5ldyBTY29wZSgpYCBpbnN0ZWFkLlxuICAgKi9cbiAgIHN0YXRpYyBjbG9uZShzY29wZSkge1xuICAgIHJldHVybiBzY29wZSA/IHNjb3BlLmNsb25lKCkgOiBuZXcgU2NvcGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9uZSB0aGlzIHNjb3BlIGluc3RhbmNlLlxuICAgKi9cbiAgIGNsb25lKCkge1xuICAgIGNvbnN0IG5ld1Njb3BlID0gbmV3IFNjb3BlKCk7XG4gICAgbmV3U2NvcGUuX2JyZWFkY3J1bWJzID0gWy4uLnRoaXMuX2JyZWFkY3J1bWJzXTtcbiAgICBuZXdTY29wZS5fdGFncyA9IHsgLi4udGhpcy5fdGFncyB9O1xuICAgIG5ld1Njb3BlLl9leHRyYSA9IHsgLi4udGhpcy5fZXh0cmEgfTtcbiAgICBuZXdTY29wZS5fY29udGV4dHMgPSB7IC4uLnRoaXMuX2NvbnRleHRzIH07XG4gICAgbmV3U2NvcGUuX3VzZXIgPSB0aGlzLl91c2VyO1xuICAgIG5ld1Njb3BlLl9sZXZlbCA9IHRoaXMuX2xldmVsO1xuICAgIG5ld1Njb3BlLl9zcGFuID0gdGhpcy5fc3BhbjtcbiAgICBuZXdTY29wZS5fc2Vzc2lvbiA9IHRoaXMuX3Nlc3Npb247XG4gICAgbmV3U2NvcGUuX3RyYW5zYWN0aW9uTmFtZSA9IHRoaXMuX3RyYW5zYWN0aW9uTmFtZTtcbiAgICBuZXdTY29wZS5fZmluZ2VycHJpbnQgPSB0aGlzLl9maW5nZXJwcmludDtcbiAgICBuZXdTY29wZS5fZXZlbnRQcm9jZXNzb3JzID0gWy4uLnRoaXMuX2V2ZW50UHJvY2Vzc29yc107XG4gICAgbmV3U2NvcGUuX3JlcXVlc3RTZXNzaW9uID0gdGhpcy5fcmVxdWVzdFNlc3Npb247XG4gICAgbmV3U2NvcGUuX2F0dGFjaG1lbnRzID0gWy4uLnRoaXMuX2F0dGFjaG1lbnRzXTtcbiAgICBuZXdTY29wZS5fc2RrUHJvY2Vzc2luZ01ldGFkYXRhID0geyAuLi50aGlzLl9zZGtQcm9jZXNzaW5nTWV0YWRhdGEgfTtcbiAgICBuZXdTY29wZS5fcHJvcGFnYXRpb25Db250ZXh0ID0geyAuLi50aGlzLl9wcm9wYWdhdGlvbkNvbnRleHQgfTtcbiAgICBuZXdTY29wZS5fY2xpZW50ID0gdGhpcy5fY2xpZW50O1xuXG4gICAgcmV0dXJuIG5ld1Njb3BlO1xuICB9XG5cbiAgLyoqIFVwZGF0ZSB0aGUgY2xpZW50IG9uIHRoZSBzY29wZS4gKi9cbiAgIHNldENsaWVudChjbGllbnQpIHtcbiAgICB0aGlzLl9jbGllbnQgPSBjbGllbnQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjbGllbnQgYXNzaWduZWQgdG8gdGhpcyBzY29wZS5cbiAgICpcbiAgICogSXQgaXMgZ2VuZXJhbGx5IHJlY29tbWVuZGVkIHRvIHVzZSB0aGUgZ2xvYmFsIGZ1bmN0aW9uIGBTZW50cnkuZ2V0Q2xpZW50KClgIGluc3RlYWQsIHVubGVzcyB5b3Uga25vdyB3aGF0IHlvdSBhcmUgZG9pbmcuXG4gICAqL1xuICAgZ2V0Q2xpZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQ7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGludGVybmFsIG9uIGNoYW5nZSBsaXN0ZW5lci4gVXNlZCBmb3Igc3ViIFNES3MgdGhhdCBuZWVkIHRvIHN0b3JlIHRoZSBzY29wZS5cbiAgICogQGhpZGRlblxuICAgKi9cbiAgIGFkZFNjb3BlTGlzdGVuZXIoY2FsbGJhY2spIHtcbiAgICB0aGlzLl9zY29wZUxpc3RlbmVycy5wdXNoKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgIGFkZEV2ZW50UHJvY2Vzc29yKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fZXZlbnRQcm9jZXNzb3JzLnB1c2goY2FsbGJhY2spO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICAgc2V0VXNlcih1c2VyKSB7XG4gICAgLy8gSWYgbnVsbCBpcyBwYXNzZWQgd2Ugd2FudCB0byB1bnNldCBldmVyeXRoaW5nLCBidXQgc3RpbGwgZGVmaW5lIGtleXMsXG4gICAgLy8gc28gdGhhdCBsYXRlciBkb3duIGluIHRoZSBwaXBlbGluZSBhbnkgZXhpc3RpbmcgdmFsdWVzIGFyZSBjbGVhcmVkLlxuICAgIHRoaXMuX3VzZXIgPSB1c2VyIHx8IHtcbiAgICAgIGVtYWlsOiB1bmRlZmluZWQsXG4gICAgICBpZDogdW5kZWZpbmVkLFxuICAgICAgaXBfYWRkcmVzczogdW5kZWZpbmVkLFxuICAgICAgc2VnbWVudDogdW5kZWZpbmVkLFxuICAgICAgdXNlcm5hbWU6IHVuZGVmaW5lZCxcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMuX3Nlc3Npb24pIHtcbiAgICAgIHVwZGF0ZVNlc3Npb24odGhpcy5fc2Vzc2lvbiwgeyB1c2VyIH0pO1xuICAgIH1cblxuICAgIHRoaXMuX25vdGlmeVNjb3BlTGlzdGVuZXJzKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gICBnZXRVc2VyKCkge1xuICAgIHJldHVybiB0aGlzLl91c2VyO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICAgZ2V0UmVxdWVzdFNlc3Npb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3RTZXNzaW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICAgc2V0UmVxdWVzdFNlc3Npb24ocmVxdWVzdFNlc3Npb24pIHtcbiAgICB0aGlzLl9yZXF1ZXN0U2Vzc2lvbiA9IHJlcXVlc3RTZXNzaW9uO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICAgc2V0VGFncyh0YWdzKSB7XG4gICAgdGhpcy5fdGFncyA9IHtcbiAgICAgIC4uLnRoaXMuX3RhZ3MsXG4gICAgICAuLi50YWdzLFxuICAgIH07XG4gICAgdGhpcy5fbm90aWZ5U2NvcGVMaXN0ZW5lcnMoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgIHNldFRhZyhrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5fdGFncyA9IHsgLi4udGhpcy5fdGFncywgW2tleV06IHZhbHVlIH07XG4gICAgdGhpcy5fbm90aWZ5U2NvcGVMaXN0ZW5lcnMoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgIHNldEV4dHJhcyhleHRyYXMpIHtcbiAgICB0aGlzLl9leHRyYSA9IHtcbiAgICAgIC4uLnRoaXMuX2V4dHJhLFxuICAgICAgLi4uZXh0cmFzLFxuICAgIH07XG4gICAgdGhpcy5fbm90aWZ5U2NvcGVMaXN0ZW5lcnMoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgIHNldEV4dHJhKGtleSwgZXh0cmEpIHtcbiAgICB0aGlzLl9leHRyYSA9IHsgLi4udGhpcy5fZXh0cmEsIFtrZXldOiBleHRyYSB9O1xuICAgIHRoaXMuX25vdGlmeVNjb3BlTGlzdGVuZXJzKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gICBzZXRGaW5nZXJwcmludChmaW5nZXJwcmludCkge1xuICAgIHRoaXMuX2ZpbmdlcnByaW50ID0gZmluZ2VycHJpbnQ7XG4gICAgdGhpcy5fbm90aWZ5U2NvcGVMaXN0ZW5lcnMoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgIHNldExldmVsKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICAgIGxldmVsLFxuICApIHtcbiAgICB0aGlzLl9sZXZlbCA9IGxldmVsO1xuICAgIHRoaXMuX25vdGlmeVNjb3BlTGlzdGVuZXJzKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdHJhbnNhY3Rpb24gbmFtZSBvbiB0aGUgc2NvcGUgZm9yIGZ1dHVyZSBldmVudHMuXG4gICAqIEBkZXByZWNhdGVkIFVzZSBleHRyYSBvciB0YWdzIGluc3RlYWQuXG4gICAqL1xuICAgc2V0VHJhbnNhY3Rpb25OYW1lKG5hbWUpIHtcbiAgICB0aGlzLl90cmFuc2FjdGlvbk5hbWUgPSBuYW1lO1xuICAgIHRoaXMuX25vdGlmeVNjb3BlTGlzdGVuZXJzKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gICBzZXRDb250ZXh0KGtleSwgY29udGV4dCkge1xuICAgIGlmIChjb250ZXh0ID09PSBudWxsKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWR5bmFtaWMtZGVsZXRlXG4gICAgICBkZWxldGUgdGhpcy5fY29udGV4dHNba2V5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fY29udGV4dHNba2V5XSA9IGNvbnRleHQ7XG4gICAgfVxuXG4gICAgdGhpcy5fbm90aWZ5U2NvcGVMaXN0ZW5lcnMoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBTcGFuIG9uIHRoZSBzY29wZS5cbiAgICogQHBhcmFtIHNwYW4gU3BhblxuICAgKiBAZGVwcmVjYXRlZCBJbnN0ZWFkIG9mIHNldHRpbmcgYSBzcGFuIG9uIGEgc2NvcGUsIHVzZSBgc3RhcnRTcGFuKClgL2BzdGFydFNwYW5NYW51YWwoKWAgaW5zdGVhZC5cbiAgICovXG4gICBzZXRTcGFuKHNwYW4pIHtcbiAgICB0aGlzLl9zcGFuID0gc3BhbjtcbiAgICB0aGlzLl9ub3RpZnlTY29wZUxpc3RlbmVycygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGBTcGFuYCBpZiB0aGVyZSBpcyBvbmUuXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgZ2V0QWN0aXZlU3BhbigpYCBpbnN0ZWFkLlxuICAgKi9cbiAgIGdldFNwYW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NwYW47XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYFRyYW5zYWN0aW9uYCBhdHRhY2hlZCB0byB0aGUgc2NvcGUgKGlmIHRoZXJlIGlzIG9uZSkuXG4gICAqIEBkZXByZWNhdGVkIFlvdSBzaG91bGQgbm90IHJlbHkgb24gdGhlIHRyYW5zYWN0aW9uLCBidXQganVzdCB1c2UgYHN0YXJ0U3BhbigpYCBBUElzIGluc3RlYWQuXG4gICAqL1xuICAgZ2V0VHJhbnNhY3Rpb24oKSB7XG4gICAgLy8gT2Z0ZW4sIHRoaXMgc3BhbiAoaWYgaXQgZXhpc3RzIGF0IGFsbCkgd2lsbCBiZSBhIHRyYW5zYWN0aW9uLCBidXQgaXQncyBub3QgZ3VhcmFudGVlZCB0byBiZS4gUmVnYXJkbGVzcywgaXQgd2lsbFxuICAgIC8vIGhhdmUgYSBwb2ludGVyIHRvIHRoZSBjdXJyZW50bHktYWN0aXZlIHRyYW5zYWN0aW9uLlxuICAgIGNvbnN0IHNwYW4gPSB0aGlzLl9zcGFuO1xuICAgIC8vIENhbm5vdCByZXBsYWNlIHdpdGggZ2V0Um9vdFNwYW4gYmVjYXVzZSBnZXRSb290U3BhbiByZXR1cm5zIGEgc3Bhbiwgbm90IGEgdHJhbnNhY3Rpb25cbiAgICAvLyBBbHNvLCB0aGlzIG1ldGhvZCB3aWxsIGJlIHJlbW92ZWQgYW55d2F5LlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICAgIHJldHVybiBzcGFuICYmIHNwYW4udHJhbnNhY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gICBzZXRTZXNzaW9uKHNlc3Npb24pIHtcbiAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9zZXNzaW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zZXNzaW9uID0gc2Vzc2lvbjtcbiAgICB9XG4gICAgdGhpcy5fbm90aWZ5U2NvcGVMaXN0ZW5lcnMoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgIGdldFNlc3Npb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Nlc3Npb247XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gICB1cGRhdGUoY2FwdHVyZUNvbnRleHQpIHtcbiAgICBpZiAoIWNhcHR1cmVDb250ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjb25zdCBzY29wZVRvTWVyZ2UgPSB0eXBlb2YgY2FwdHVyZUNvbnRleHQgPT09ICdmdW5jdGlvbicgPyBjYXB0dXJlQ29udGV4dCh0aGlzKSA6IGNhcHR1cmVDb250ZXh0O1xuXG4gICAgaWYgKHNjb3BlVG9NZXJnZSBpbnN0YW5jZW9mIFNjb3BlKSB7XG4gICAgICBjb25zdCBzY29wZURhdGEgPSBzY29wZVRvTWVyZ2UuZ2V0U2NvcGVEYXRhKCk7XG5cbiAgICAgIHRoaXMuX3RhZ3MgPSB7IC4uLnRoaXMuX3RhZ3MsIC4uLnNjb3BlRGF0YS50YWdzIH07XG4gICAgICB0aGlzLl9leHRyYSA9IHsgLi4udGhpcy5fZXh0cmEsIC4uLnNjb3BlRGF0YS5leHRyYSB9O1xuICAgICAgdGhpcy5fY29udGV4dHMgPSB7IC4uLnRoaXMuX2NvbnRleHRzLCAuLi5zY29wZURhdGEuY29udGV4dHMgfTtcbiAgICAgIGlmIChzY29wZURhdGEudXNlciAmJiBPYmplY3Qua2V5cyhzY29wZURhdGEudXNlcikubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX3VzZXIgPSBzY29wZURhdGEudXNlcjtcbiAgICAgIH1cbiAgICAgIGlmIChzY29wZURhdGEubGV2ZWwpIHtcbiAgICAgICAgdGhpcy5fbGV2ZWwgPSBzY29wZURhdGEubGV2ZWw7XG4gICAgICB9XG4gICAgICBpZiAoc2NvcGVEYXRhLmZpbmdlcnByaW50Lmxlbmd0aCkge1xuICAgICAgICB0aGlzLl9maW5nZXJwcmludCA9IHNjb3BlRGF0YS5maW5nZXJwcmludDtcbiAgICAgIH1cbiAgICAgIGlmIChzY29wZVRvTWVyZ2UuZ2V0UmVxdWVzdFNlc3Npb24oKSkge1xuICAgICAgICB0aGlzLl9yZXF1ZXN0U2Vzc2lvbiA9IHNjb3BlVG9NZXJnZS5nZXRSZXF1ZXN0U2Vzc2lvbigpO1xuICAgICAgfVxuICAgICAgaWYgKHNjb3BlRGF0YS5wcm9wYWdhdGlvbkNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fcHJvcGFnYXRpb25Db250ZXh0ID0gc2NvcGVEYXRhLnByb3BhZ2F0aW9uQ29udGV4dDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3Qoc2NvcGVUb01lcmdlKSkge1xuICAgICAgY29uc3Qgc2NvcGVDb250ZXh0ID0gY2FwdHVyZUNvbnRleHQgO1xuICAgICAgdGhpcy5fdGFncyA9IHsgLi4udGhpcy5fdGFncywgLi4uc2NvcGVDb250ZXh0LnRhZ3MgfTtcbiAgICAgIHRoaXMuX2V4dHJhID0geyAuLi50aGlzLl9leHRyYSwgLi4uc2NvcGVDb250ZXh0LmV4dHJhIH07XG4gICAgICB0aGlzLl9jb250ZXh0cyA9IHsgLi4udGhpcy5fY29udGV4dHMsIC4uLnNjb3BlQ29udGV4dC5jb250ZXh0cyB9O1xuICAgICAgaWYgKHNjb3BlQ29udGV4dC51c2VyKSB7XG4gICAgICAgIHRoaXMuX3VzZXIgPSBzY29wZUNvbnRleHQudXNlcjtcbiAgICAgIH1cbiAgICAgIGlmIChzY29wZUNvbnRleHQubGV2ZWwpIHtcbiAgICAgICAgdGhpcy5fbGV2ZWwgPSBzY29wZUNvbnRleHQubGV2ZWw7XG4gICAgICB9XG4gICAgICBpZiAoc2NvcGVDb250ZXh0LmZpbmdlcnByaW50KSB7XG4gICAgICAgIHRoaXMuX2ZpbmdlcnByaW50ID0gc2NvcGVDb250ZXh0LmZpbmdlcnByaW50O1xuICAgICAgfVxuICAgICAgaWYgKHNjb3BlQ29udGV4dC5yZXF1ZXN0U2Vzc2lvbikge1xuICAgICAgICB0aGlzLl9yZXF1ZXN0U2Vzc2lvbiA9IHNjb3BlQ29udGV4dC5yZXF1ZXN0U2Vzc2lvbjtcbiAgICAgIH1cbiAgICAgIGlmIChzY29wZUNvbnRleHQucHJvcGFnYXRpb25Db250ZXh0KSB7XG4gICAgICAgIHRoaXMuX3Byb3BhZ2F0aW9uQ29udGV4dCA9IHNjb3BlQ29udGV4dC5wcm9wYWdhdGlvbkNvbnRleHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gICBjbGVhcigpIHtcbiAgICB0aGlzLl9icmVhZGNydW1icyA9IFtdO1xuICAgIHRoaXMuX3RhZ3MgPSB7fTtcbiAgICB0aGlzLl9leHRyYSA9IHt9O1xuICAgIHRoaXMuX3VzZXIgPSB7fTtcbiAgICB0aGlzLl9jb250ZXh0cyA9IHt9O1xuICAgIHRoaXMuX2xldmVsID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3RyYW5zYWN0aW9uTmFtZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9maW5nZXJwcmludCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9yZXF1ZXN0U2Vzc2lvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zcGFuID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3Nlc3Npb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fbm90aWZ5U2NvcGVMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLl9hdHRhY2htZW50cyA9IFtdO1xuICAgIHRoaXMuX3Byb3BhZ2F0aW9uQ29udGV4dCA9IGdlbmVyYXRlUHJvcGFnYXRpb25Db250ZXh0KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gICBhZGRCcmVhZGNydW1iKGJyZWFkY3J1bWIsIG1heEJyZWFkY3J1bWJzKSB7XG4gICAgY29uc3QgbWF4Q3J1bWJzID0gdHlwZW9mIG1heEJyZWFkY3J1bWJzID09PSAnbnVtYmVyJyA/IG1heEJyZWFkY3J1bWJzIDogREVGQVVMVF9NQVhfQlJFQURDUlVNQlM7XG5cbiAgICAvLyBObyBkYXRhIGhhcyBiZWVuIGNoYW5nZWQsIHNvIGRvbid0IG5vdGlmeSBzY29wZSBsaXN0ZW5lcnNcbiAgICBpZiAobWF4Q3J1bWJzIDw9IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNvbnN0IG1lcmdlZEJyZWFkY3J1bWIgPSB7XG4gICAgICB0aW1lc3RhbXA6IGRhdGVUaW1lc3RhbXBJblNlY29uZHMoKSxcbiAgICAgIC4uLmJyZWFkY3J1bWIsXG4gICAgfTtcblxuICAgIGNvbnN0IGJyZWFkY3J1bWJzID0gdGhpcy5fYnJlYWRjcnVtYnM7XG4gICAgYnJlYWRjcnVtYnMucHVzaChtZXJnZWRCcmVhZGNydW1iKTtcbiAgICB0aGlzLl9icmVhZGNydW1icyA9IGJyZWFkY3J1bWJzLmxlbmd0aCA+IG1heENydW1icyA/IGJyZWFkY3J1bWJzLnNsaWNlKC1tYXhDcnVtYnMpIDogYnJlYWRjcnVtYnM7XG5cbiAgICB0aGlzLl9ub3RpZnlTY29wZUxpc3RlbmVycygpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gICBnZXRMYXN0QnJlYWRjcnVtYigpIHtcbiAgICByZXR1cm4gdGhpcy5fYnJlYWRjcnVtYnNbdGhpcy5fYnJlYWRjcnVtYnMubGVuZ3RoIC0gMV07XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gICBjbGVhckJyZWFkY3J1bWJzKCkge1xuICAgIHRoaXMuX2JyZWFkY3J1bWJzID0gW107XG4gICAgdGhpcy5fbm90aWZ5U2NvcGVMaXN0ZW5lcnMoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgIGFkZEF0dGFjaG1lbnQoYXR0YWNobWVudCkge1xuICAgIHRoaXMuX2F0dGFjaG1lbnRzLnB1c2goYXR0YWNobWVudCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGBnZXRTY29wZURhdGEoKWAgaW5zdGVhZC5cbiAgICovXG4gICBnZXRBdHRhY2htZW50cygpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5nZXRTY29wZURhdGEoKTtcblxuICAgIHJldHVybiBkYXRhLmF0dGFjaG1lbnRzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICAgY2xlYXJBdHRhY2htZW50cygpIHtcbiAgICB0aGlzLl9hdHRhY2htZW50cyA9IFtdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gICBnZXRTY29wZURhdGEoKSB7XG4gICAgY29uc3Qge1xuICAgICAgX2JyZWFkY3J1bWJzLFxuICAgICAgX2F0dGFjaG1lbnRzLFxuICAgICAgX2NvbnRleHRzLFxuICAgICAgX3RhZ3MsXG4gICAgICBfZXh0cmEsXG4gICAgICBfdXNlcixcbiAgICAgIF9sZXZlbCxcbiAgICAgIF9maW5nZXJwcmludCxcbiAgICAgIF9ldmVudFByb2Nlc3NvcnMsXG4gICAgICBfcHJvcGFnYXRpb25Db250ZXh0LFxuICAgICAgX3Nka1Byb2Nlc3NpbmdNZXRhZGF0YSxcbiAgICAgIF90cmFuc2FjdGlvbk5hbWUsXG4gICAgICBfc3BhbixcbiAgICB9ID0gdGhpcztcblxuICAgIHJldHVybiB7XG4gICAgICBicmVhZGNydW1iczogX2JyZWFkY3J1bWJzLFxuICAgICAgYXR0YWNobWVudHM6IF9hdHRhY2htZW50cyxcbiAgICAgIGNvbnRleHRzOiBfY29udGV4dHMsXG4gICAgICB0YWdzOiBfdGFncyxcbiAgICAgIGV4dHJhOiBfZXh0cmEsXG4gICAgICB1c2VyOiBfdXNlcixcbiAgICAgIGxldmVsOiBfbGV2ZWwsXG4gICAgICBmaW5nZXJwcmludDogX2ZpbmdlcnByaW50IHx8IFtdLFxuICAgICAgZXZlbnRQcm9jZXNzb3JzOiBfZXZlbnRQcm9jZXNzb3JzLFxuICAgICAgcHJvcGFnYXRpb25Db250ZXh0OiBfcHJvcGFnYXRpb25Db250ZXh0LFxuICAgICAgc2RrUHJvY2Vzc2luZ01ldGFkYXRhOiBfc2RrUHJvY2Vzc2luZ01ldGFkYXRhLFxuICAgICAgdHJhbnNhY3Rpb25OYW1lOiBfdHJhbnNhY3Rpb25OYW1lLFxuICAgICAgc3BhbjogX3NwYW4sXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIGRhdGEgZnJvbSB0aGUgc2NvcGUgdG8gdGhlIGV2ZW50IGFuZCBydW5zIGFsbCBldmVudCBwcm9jZXNzb3JzIG9uIGl0LlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgRXZlbnRcbiAgICogQHBhcmFtIGhpbnQgT2JqZWN0IGNvbnRhaW5pbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb3JpZ2luYWwgZXhjZXB0aW9uLCBmb3IgdXNlIGJ5IHRoZSBldmVudCBwcm9jZXNzb3JzLlxuICAgKiBAaGlkZGVuXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgYXBwbHlTY29wZURhdGFUb0V2ZW50KClgIGRpcmVjdGx5XG4gICAqL1xuICAgYXBwbHlUb0V2ZW50KFxuICAgIGV2ZW50LFxuICAgIGhpbnQgPSB7fSxcbiAgICBhZGRpdGlvbmFsRXZlbnRQcm9jZXNzb3JzID0gW10sXG4gICkge1xuICAgIGFwcGx5U2NvcGVEYXRhVG9FdmVudChldmVudCwgdGhpcy5nZXRTY29wZURhdGEoKSk7XG5cbiAgICAvLyBUT0RPICh2OCk6IFVwZGF0ZSB0aGlzIG9yZGVyIHRvIGJlOiBHbG9iYWwgPiBDbGllbnQgPiBTY29wZVxuICAgIGNvbnN0IGV2ZW50UHJvY2Vzc29ycyA9IFtcbiAgICAgIC4uLmFkZGl0aW9uYWxFdmVudFByb2Nlc3NvcnMsXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgICAgIC4uLmdldEdsb2JhbEV2ZW50UHJvY2Vzc29ycygpLFxuICAgICAgLi4udGhpcy5fZXZlbnRQcm9jZXNzb3JzLFxuICAgIF07XG5cbiAgICByZXR1cm4gbm90aWZ5RXZlbnRQcm9jZXNzb3JzKGV2ZW50UHJvY2Vzc29ycywgZXZlbnQsIGhpbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBkYXRhIHdoaWNoIHdpbGwgYmUgYWNjZXNzaWJsZSBkdXJpbmcgZXZlbnQgcHJvY2Vzc2luZyBidXQgd29uJ3QgZ2V0IHNlbnQgdG8gU2VudHJ5XG4gICAqL1xuICAgc2V0U0RLUHJvY2Vzc2luZ01ldGFkYXRhKG5ld0RhdGEpIHtcbiAgICB0aGlzLl9zZGtQcm9jZXNzaW5nTWV0YWRhdGEgPSB7IC4uLnRoaXMuX3Nka1Byb2Nlc3NpbmdNZXRhZGF0YSwgLi4ubmV3RGF0YSB9O1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gICBzZXRQcm9wYWdhdGlvbkNvbnRleHQoY29udGV4dCkge1xuICAgIHRoaXMuX3Byb3BhZ2F0aW9uQ29udGV4dCA9IGNvbnRleHQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gICBnZXRQcm9wYWdhdGlvbkNvbnRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb3BhZ2F0aW9uQ29udGV4dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYXB0dXJlIGFuIGV4Y2VwdGlvbiBmb3IgdGhpcyBzY29wZS5cbiAgICpcbiAgICogQHBhcmFtIGV4Y2VwdGlvbiBUaGUgZXhjZXB0aW9uIHRvIGNhcHR1cmUuXG4gICAqIEBwYXJhbSBoaW50IE9wdGluYWwgYWRkaXRpb25hbCBkYXRhIHRvIGF0dGFjaCB0byB0aGUgU2VudHJ5IGV2ZW50LlxuICAgKiBAcmV0dXJucyB0aGUgaWQgb2YgdGhlIGNhcHR1cmVkIFNlbnRyeSBldmVudC5cbiAgICovXG4gICBjYXB0dXJlRXhjZXB0aW9uKGV4Y2VwdGlvbiwgaGludCkge1xuICAgIGNvbnN0IGV2ZW50SWQgPSBoaW50ICYmIGhpbnQuZXZlbnRfaWQgPyBoaW50LmV2ZW50X2lkIDogdXVpZDQoKTtcblxuICAgIGlmICghdGhpcy5fY2xpZW50KSB7XG4gICAgICBsb2dnZXIud2FybignTm8gY2xpZW50IGNvbmZpZ3VyZWQgb24gc2NvcGUgLSB3aWxsIG5vdCBjYXB0dXJlIGV4Y2VwdGlvbiEnKTtcbiAgICAgIHJldHVybiBldmVudElkO1xuICAgIH1cblxuICAgIGNvbnN0IHN5bnRoZXRpY0V4Y2VwdGlvbiA9IG5ldyBFcnJvcignU2VudHJ5IHN5bnRoZXRpY0V4Y2VwdGlvbicpO1xuXG4gICAgdGhpcy5fY2xpZW50LmNhcHR1cmVFeGNlcHRpb24oXG4gICAgICBleGNlcHRpb24sXG4gICAgICB7XG4gICAgICAgIG9yaWdpbmFsRXhjZXB0aW9uOiBleGNlcHRpb24sXG4gICAgICAgIHN5bnRoZXRpY0V4Y2VwdGlvbixcbiAgICAgICAgLi4uaGludCxcbiAgICAgICAgZXZlbnRfaWQ6IGV2ZW50SWQsXG4gICAgICB9LFxuICAgICAgdGhpcyxcbiAgICApO1xuXG4gICAgcmV0dXJuIGV2ZW50SWQ7XG4gIH1cblxuICAvKipcbiAgICogQ2FwdHVyZSBhIG1lc3NhZ2UgZm9yIHRoaXMgc2NvcGUuXG4gICAqXG4gICAqIEBwYXJhbSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGNhcHR1cmUuXG4gICAqIEBwYXJhbSBsZXZlbCBBbiBvcHRpb25hbCBzZXZlcml0eSBsZXZlbCB0byByZXBvcnQgdGhlIG1lc3NhZ2Ugd2l0aC5cbiAgICogQHBhcmFtIGhpbnQgT3B0aW9uYWwgYWRkaXRpb25hbCBkYXRhIHRvIGF0dGFjaCB0byB0aGUgU2VudHJ5IGV2ZW50LlxuICAgKiBAcmV0dXJucyB0aGUgaWQgb2YgdGhlIGNhcHR1cmVkIG1lc3NhZ2UuXG4gICAqL1xuICAgY2FwdHVyZU1lc3NhZ2UobWVzc2FnZSwgbGV2ZWwsIGhpbnQpIHtcbiAgICBjb25zdCBldmVudElkID0gaGludCAmJiBoaW50LmV2ZW50X2lkID8gaGludC5ldmVudF9pZCA6IHV1aWQ0KCk7XG5cbiAgICBpZiAoIXRoaXMuX2NsaWVudCkge1xuICAgICAgbG9nZ2VyLndhcm4oJ05vIGNsaWVudCBjb25maWd1cmVkIG9uIHNjb3BlIC0gd2lsbCBub3QgY2FwdHVyZSBtZXNzYWdlIScpO1xuICAgICAgcmV0dXJuIGV2ZW50SWQ7XG4gICAgfVxuXG4gICAgY29uc3Qgc3ludGhldGljRXhjZXB0aW9uID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuXG4gICAgdGhpcy5fY2xpZW50LmNhcHR1cmVNZXNzYWdlKFxuICAgICAgbWVzc2FnZSxcbiAgICAgIGxldmVsLFxuICAgICAge1xuICAgICAgICBvcmlnaW5hbEV4Y2VwdGlvbjogbWVzc2FnZSxcbiAgICAgICAgc3ludGhldGljRXhjZXB0aW9uLFxuICAgICAgICAuLi5oaW50LFxuICAgICAgICBldmVudF9pZDogZXZlbnRJZCxcbiAgICAgIH0sXG4gICAgICB0aGlzLFxuICAgICk7XG5cbiAgICByZXR1cm4gZXZlbnRJZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYXB0dXJlcyBhIG1hbnVhbGx5IGNyZWF0ZWQgZXZlbnQgZm9yIHRoaXMgc2NvcGUgYW5kIHNlbmRzIGl0IHRvIFNlbnRyeS5cbiAgICpcbiAgICogQHBhcmFtIGV4Y2VwdGlvbiBUaGUgZXZlbnQgdG8gY2FwdHVyZS5cbiAgICogQHBhcmFtIGhpbnQgT3B0aW9uYWwgYWRkaXRpb25hbCBkYXRhIHRvIGF0dGFjaCB0byB0aGUgU2VudHJ5IGV2ZW50LlxuICAgKiBAcmV0dXJucyB0aGUgaWQgb2YgdGhlIGNhcHR1cmVkIGV2ZW50LlxuICAgKi9cbiAgIGNhcHR1cmVFdmVudChldmVudCwgaGludCkge1xuICAgIGNvbnN0IGV2ZW50SWQgPSBoaW50ICYmIGhpbnQuZXZlbnRfaWQgPyBoaW50LmV2ZW50X2lkIDogdXVpZDQoKTtcblxuICAgIGlmICghdGhpcy5fY2xpZW50KSB7XG4gICAgICBsb2dnZXIud2FybignTm8gY2xpZW50IGNvbmZpZ3VyZWQgb24gc2NvcGUgLSB3aWxsIG5vdCBjYXB0dXJlIGV2ZW50IScpO1xuICAgICAgcmV0dXJuIGV2ZW50SWQ7XG4gICAgfVxuXG4gICAgdGhpcy5fY2xpZW50LmNhcHR1cmVFdmVudChldmVudCwgeyAuLi5oaW50LCBldmVudF9pZDogZXZlbnRJZCB9LCB0aGlzKTtcblxuICAgIHJldHVybiBldmVudElkO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgd2lsbCBiZSBjYWxsZWQgb24gZXZlcnkgc2V0IGNhbGwuXG4gICAqL1xuICAgX25vdGlmeVNjb3BlTGlzdGVuZXJzKCkge1xuICAgIC8vIFdlIG5lZWQgdGhpcyBjaGVjayBmb3IgdGhpcy5fbm90aWZ5aW5nTGlzdGVuZXJzIHRvIGJlIGFibGUgdG8gd29yayBvbiBzY29wZSBkdXJpbmcgdXBkYXRlc1xuICAgIC8vIElmIHRoaXMgY2hlY2sgaXMgbm90IGhlcmUgd2UnbGwgcHJvZHVjZSBlbmRsZXNzIHJlY3Vyc2lvbiB3aGVuIHNvbWV0aGluZyBpcyBkb25lIHdpdGggdGhlIHNjb3BlXG4gICAgLy8gZHVyaW5nIHRoZSBjYWxsYmFjay5cbiAgICBpZiAoIXRoaXMuX25vdGlmeWluZ0xpc3RlbmVycykge1xuICAgICAgdGhpcy5fbm90aWZ5aW5nTGlzdGVuZXJzID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3Njb3BlTGlzdGVuZXJzLmZvckVhY2goY2FsbGJhY2sgPT4ge1xuICAgICAgICBjYWxsYmFjayh0aGlzKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fbm90aWZ5aW5nTGlzdGVuZXJzID0gZmFsc2U7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2V0IHRoZSBnbG9iYWwgc2NvcGUuXG4gKiBUaGlzIHNjb3BlIGlzIGFwcGxpZWQgdG8gX2FsbF8gZXZlbnRzLlxuICovXG5mdW5jdGlvbiBnZXRHbG9iYWxTY29wZSgpIHtcbiAgaWYgKCFnbG9iYWxTY29wZSkge1xuICAgIGdsb2JhbFNjb3BlID0gbmV3IFNjb3BlKCk7XG4gIH1cblxuICByZXR1cm4gZ2xvYmFsU2NvcGU7XG59XG5cbi8qKlxuICogVGhpcyBpcyBtYWlubHkgbmVlZGVkIGZvciB0ZXN0cy5cbiAqIERPIE5PVCBVU0UgdGhpcywgYXMgdGhpcyBpcyBhbiBpbnRlcm5hbCBBUEkgYW5kIHN1YmplY3QgdG8gY2hhbmdlLlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBzZXRHbG9iYWxTY29wZShzY29wZSkge1xuICBnbG9iYWxTY29wZSA9IHNjb3BlO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVByb3BhZ2F0aW9uQ29udGV4dCgpIHtcbiAgcmV0dXJuIHtcbiAgICB0cmFjZUlkOiB1dWlkNCgpLFxuICAgIHNwYW5JZDogdXVpZDQoKS5zdWJzdHJpbmcoMTYpLFxuICB9O1xufVxuXG5leHBvcnQgeyBTY29wZSwgZ2V0R2xvYmFsU2NvcGUsIHNldEdsb2JhbFNjb3BlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY29wZS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJpc1BsYWluT2JqZWN0IiwiZGF0ZVRpbWVzdGFtcEluU2Vjb25kcyIsInV1aWQ0IiwibG9nZ2VyIiwiZ2V0R2xvYmFsRXZlbnRQcm9jZXNzb3JzIiwibm90aWZ5RXZlbnRQcm9jZXNzb3JzIiwidXBkYXRlU2Vzc2lvbiIsImFwcGx5U2NvcGVEYXRhVG9FdmVudCIsIkRFRkFVTFRfTUFYX0JSRUFEQ1JVTUJTIiwiZ2xvYmFsU2NvcGUiLCJTY29wZSIsImNvbnN0cnVjdG9yIiwiX25vdGlmeWluZ0xpc3RlbmVycyIsIl9zY29wZUxpc3RlbmVycyIsIl9ldmVudFByb2Nlc3NvcnMiLCJfYnJlYWRjcnVtYnMiLCJfYXR0YWNobWVudHMiLCJfdXNlciIsIl90YWdzIiwiX2V4dHJhIiwiX2NvbnRleHRzIiwiX3Nka1Byb2Nlc3NpbmdNZXRhZGF0YSIsIl9wcm9wYWdhdGlvbkNvbnRleHQiLCJnZW5lcmF0ZVByb3BhZ2F0aW9uQ29udGV4dCIsImNsb25lIiwic2NvcGUiLCJuZXdTY29wZSIsIl9sZXZlbCIsIl9zcGFuIiwiX3Nlc3Npb24iLCJfdHJhbnNhY3Rpb25OYW1lIiwiX2ZpbmdlcnByaW50IiwiX3JlcXVlc3RTZXNzaW9uIiwiX2NsaWVudCIsInNldENsaWVudCIsImNsaWVudCIsImdldENsaWVudCIsImFkZFNjb3BlTGlzdGVuZXIiLCJjYWxsYmFjayIsInB1c2giLCJhZGRFdmVudFByb2Nlc3NvciIsInNldFVzZXIiLCJ1c2VyIiwiZW1haWwiLCJ1bmRlZmluZWQiLCJpZCIsImlwX2FkZHJlc3MiLCJzZWdtZW50IiwidXNlcm5hbWUiLCJfbm90aWZ5U2NvcGVMaXN0ZW5lcnMiLCJnZXRVc2VyIiwiZ2V0UmVxdWVzdFNlc3Npb24iLCJzZXRSZXF1ZXN0U2Vzc2lvbiIsInJlcXVlc3RTZXNzaW9uIiwic2V0VGFncyIsInRhZ3MiLCJzZXRUYWciLCJrZXkiLCJ2YWx1ZSIsInNldEV4dHJhcyIsImV4dHJhcyIsInNldEV4dHJhIiwiZXh0cmEiLCJzZXRGaW5nZXJwcmludCIsImZpbmdlcnByaW50Iiwic2V0TGV2ZWwiLCJsZXZlbCIsInNldFRyYW5zYWN0aW9uTmFtZSIsIm5hbWUiLCJzZXRDb250ZXh0IiwiY29udGV4dCIsInNldFNwYW4iLCJzcGFuIiwiZ2V0U3BhbiIsImdldFRyYW5zYWN0aW9uIiwidHJhbnNhY3Rpb24iLCJzZXRTZXNzaW9uIiwic2Vzc2lvbiIsImdldFNlc3Npb24iLCJ1cGRhdGUiLCJjYXB0dXJlQ29udGV4dCIsInNjb3BlVG9NZXJnZSIsInNjb3BlRGF0YSIsImdldFNjb3BlRGF0YSIsImNvbnRleHRzIiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsInByb3BhZ2F0aW9uQ29udGV4dCIsInNjb3BlQ29udGV4dCIsImNsZWFyIiwiYWRkQnJlYWRjcnVtYiIsImJyZWFkY3J1bWIiLCJtYXhCcmVhZGNydW1icyIsIm1heENydW1icyIsIm1lcmdlZEJyZWFkY3J1bWIiLCJ0aW1lc3RhbXAiLCJicmVhZGNydW1icyIsInNsaWNlIiwiZ2V0TGFzdEJyZWFkY3J1bWIiLCJjbGVhckJyZWFkY3J1bWJzIiwiYWRkQXR0YWNobWVudCIsImF0dGFjaG1lbnQiLCJnZXRBdHRhY2htZW50cyIsImRhdGEiLCJhdHRhY2htZW50cyIsImNsZWFyQXR0YWNobWVudHMiLCJldmVudFByb2Nlc3NvcnMiLCJzZGtQcm9jZXNzaW5nTWV0YWRhdGEiLCJ0cmFuc2FjdGlvbk5hbWUiLCJhcHBseVRvRXZlbnQiLCJldmVudCIsImhpbnQiLCJhZGRpdGlvbmFsRXZlbnRQcm9jZXNzb3JzIiwic2V0U0RLUHJvY2Vzc2luZ01ldGFkYXRhIiwibmV3RGF0YSIsInNldFByb3BhZ2F0aW9uQ29udGV4dCIsImdldFByb3BhZ2F0aW9uQ29udGV4dCIsImNhcHR1cmVFeGNlcHRpb24iLCJleGNlcHRpb24iLCJldmVudElkIiwiZXZlbnRfaWQiLCJ3YXJuIiwic3ludGhldGljRXhjZXB0aW9uIiwiRXJyb3IiLCJvcmlnaW5hbEV4Y2VwdGlvbiIsImNhcHR1cmVNZXNzYWdlIiwibWVzc2FnZSIsImNhcHR1cmVFdmVudCIsImZvckVhY2giLCJnZXRHbG9iYWxTY29wZSIsInNldEdsb2JhbFNjb3BlIiwidHJhY2VJZCIsInNwYW5JZCIsInN1YnN0cmluZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/core/esm/scope.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sentry/core/esm/session.js":
/*!**************************************************!*\
  !*** ./node_modules/@sentry/core/esm/session.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   closeSession: () => (/* binding */ closeSession),\n/* harmony export */   makeSession: () => (/* binding */ makeSession),\n/* harmony export */   updateSession: () => (/* binding */ updateSession)\n/* harmony export */ });\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sentry/utils */ \"(ssr)/./node_modules/@sentry/utils/esm/time.js\");\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @sentry/utils */ \"(ssr)/./node_modules/@sentry/utils/esm/misc.js\");\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sentry/utils */ \"(ssr)/./node_modules/@sentry/utils/esm/object.js\");\n\n/**\n * Creates a new `Session` object by setting certain default parameters. If optional @param context\n * is passed, the passed properties are applied to the session object.\n *\n * @param context (optional) additional properties to be applied to the returned session object\n *\n * @returns a new `Session` object\n */ function makeSession(context) {\n    // Both timestamp and started are in seconds since the UNIX epoch.\n    const startingTime = (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_0__.timestampInSeconds)();\n    const session = {\n        sid: (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_1__.uuid4)(),\n        init: true,\n        timestamp: startingTime,\n        started: startingTime,\n        duration: 0,\n        status: \"ok\",\n        errors: 0,\n        ignoreDuration: false,\n        toJSON: ()=>sessionToJSON(session)\n    };\n    if (context) {\n        updateSession(session, context);\n    }\n    return session;\n}\n/**\n * Updates a session object with the properties passed in the context.\n *\n * Note that this function mutates the passed object and returns void.\n * (Had to do this instead of returning a new and updated session because closing and sending a session\n * makes an update to the session after it was passed to the sending logic.\n * @see BaseClient.captureSession )\n *\n * @param session the `Session` to update\n * @param context the `SessionContext` holding the properties that should be updated in @param session\n */ // eslint-disable-next-line complexity\nfunction updateSession(session, context = {}) {\n    if (context.user) {\n        if (!session.ipAddress && context.user.ip_address) {\n            session.ipAddress = context.user.ip_address;\n        }\n        if (!session.did && !context.did) {\n            session.did = context.user.id || context.user.email || context.user.username;\n        }\n    }\n    session.timestamp = context.timestamp || (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_0__.timestampInSeconds)();\n    if (context.abnormal_mechanism) {\n        session.abnormal_mechanism = context.abnormal_mechanism;\n    }\n    if (context.ignoreDuration) {\n        session.ignoreDuration = context.ignoreDuration;\n    }\n    if (context.sid) {\n        // Good enough uuid validation. — Kamil\n        session.sid = context.sid.length === 32 ? context.sid : (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_1__.uuid4)();\n    }\n    if (context.init !== undefined) {\n        session.init = context.init;\n    }\n    if (!session.did && context.did) {\n        session.did = `${context.did}`;\n    }\n    if (typeof context.started === \"number\") {\n        session.started = context.started;\n    }\n    if (session.ignoreDuration) {\n        session.duration = undefined;\n    } else if (typeof context.duration === \"number\") {\n        session.duration = context.duration;\n    } else {\n        const duration = session.timestamp - session.started;\n        session.duration = duration >= 0 ? duration : 0;\n    }\n    if (context.release) {\n        session.release = context.release;\n    }\n    if (context.environment) {\n        session.environment = context.environment;\n    }\n    if (!session.ipAddress && context.ipAddress) {\n        session.ipAddress = context.ipAddress;\n    }\n    if (!session.userAgent && context.userAgent) {\n        session.userAgent = context.userAgent;\n    }\n    if (typeof context.errors === \"number\") {\n        session.errors = context.errors;\n    }\n    if (context.status) {\n        session.status = context.status;\n    }\n}\n/**\n * Closes a session by setting its status and updating the session object with it.\n * Internally calls `updateSession` to update the passed session object.\n *\n * Note that this function mutates the passed session (@see updateSession for explanation).\n *\n * @param session the `Session` object to be closed\n * @param status the `SessionStatus` with which the session was closed. If you don't pass a status,\n *               this function will keep the previously set status, unless it was `'ok'` in which case\n *               it is changed to `'exited'`.\n */ function closeSession(session, status) {\n    let context = {};\n    if (status) {\n        context = {\n            status\n        };\n    } else if (session.status === \"ok\") {\n        context = {\n            status: \"exited\"\n        };\n    }\n    updateSession(session, context);\n}\n/**\n * Serializes a passed session object to a JSON object with a slightly different structure.\n * This is necessary because the Sentry backend requires a slightly different schema of a session\n * than the one the JS SDKs use internally.\n *\n * @param session the session to be converted\n *\n * @returns a JSON object of the passed session\n */ function sessionToJSON(session) {\n    return (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_2__.dropUndefinedKeys)({\n        sid: `${session.sid}`,\n        init: session.init,\n        // Make sure that sec is converted to ms for date constructor\n        started: new Date(session.started * 1000).toISOString(),\n        timestamp: new Date(session.timestamp * 1000).toISOString(),\n        status: session.status,\n        errors: session.errors,\n        did: typeof session.did === \"number\" || typeof session.did === \"string\" ? `${session.did}` : undefined,\n        duration: session.duration,\n        abnormal_mechanism: session.abnormal_mechanism,\n        attrs: {\n            release: session.release,\n            environment: session.environment,\n            ip_address: session.ipAddress,\n            user_agent: session.userAgent\n        }\n    });\n}\n //# sourceMappingURL=session.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2VzbS9zZXNzaW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUE2RTtBQUU3RTs7Ozs7OztDQU9DLEdBQ0QsU0FBU0csWUFBWUMsT0FBTztJQUMxQixrRUFBa0U7SUFDbEUsTUFBTUMsZUFBZUwsaUVBQWtCQTtJQUV2QyxNQUFNTSxVQUFVO1FBQ2RDLEtBQUtOLG9EQUFLQTtRQUNWTyxNQUFNO1FBQ05DLFdBQVdKO1FBQ1hLLFNBQVNMO1FBQ1RNLFVBQVU7UUFDVkMsUUFBUTtRQUNSQyxRQUFRO1FBQ1JDLGdCQUFnQjtRQUNoQkMsUUFBUSxJQUFNQyxjQUFjVjtJQUM5QjtJQUVBLElBQUlGLFNBQVM7UUFDWGEsY0FBY1gsU0FBU0Y7SUFDekI7SUFFQSxPQUFPRTtBQUNUO0FBRUE7Ozs7Ozs7Ozs7Q0FVQyxHQUNELHNDQUFzQztBQUN0QyxTQUFTVyxjQUFjWCxPQUFPLEVBQUVGLFVBQVUsQ0FBQyxDQUFDO0lBQzFDLElBQUlBLFFBQVFjLElBQUksRUFBRTtRQUNoQixJQUFJLENBQUNaLFFBQVFhLFNBQVMsSUFBSWYsUUFBUWMsSUFBSSxDQUFDRSxVQUFVLEVBQUU7WUFDakRkLFFBQVFhLFNBQVMsR0FBR2YsUUFBUWMsSUFBSSxDQUFDRSxVQUFVO1FBQzdDO1FBRUEsSUFBSSxDQUFDZCxRQUFRZSxHQUFHLElBQUksQ0FBQ2pCLFFBQVFpQixHQUFHLEVBQUU7WUFDaENmLFFBQVFlLEdBQUcsR0FBR2pCLFFBQVFjLElBQUksQ0FBQ0ksRUFBRSxJQUFJbEIsUUFBUWMsSUFBSSxDQUFDSyxLQUFLLElBQUluQixRQUFRYyxJQUFJLENBQUNNLFFBQVE7UUFDOUU7SUFDRjtJQUVBbEIsUUFBUUcsU0FBUyxHQUFHTCxRQUFRSyxTQUFTLElBQUlULGlFQUFrQkE7SUFFM0QsSUFBSUksUUFBUXFCLGtCQUFrQixFQUFFO1FBQzlCbkIsUUFBUW1CLGtCQUFrQixHQUFHckIsUUFBUXFCLGtCQUFrQjtJQUN6RDtJQUVB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QUM3RmhCLFVBQVVMLFFBQVFLLFFBQVE7UUFDMUJjLG9CQUFvQm5CLFFBQVFtQixrQkFBa0I7UUFDOUNTLE9BQU87WUFDTE4sU0FBU3RCLFFBQVFzQixPQUFPO1lBQ3hCQyxhQUFhdkIsUUFBUXVCLFdBQVc7WUFDaENULFlBQVlkLFFBQVFhLFNBQVM7WUFDN0JnQixZQUFZN0IsUUFBUXdCLFNBQVM7UUFDL0I7SUFDRjtBQUNGO0FBRW9ELENBQ3BELG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL29icmFsaW5rLXdlYi8uL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvZXNtL3Nlc3Npb24uanM/ODQ4NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB0aW1lc3RhbXBJblNlY29uZHMsIHV1aWQ0LCBkcm9wVW5kZWZpbmVkS2V5cyB9IGZyb20gJ0BzZW50cnkvdXRpbHMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYFNlc3Npb25gIG9iamVjdCBieSBzZXR0aW5nIGNlcnRhaW4gZGVmYXVsdCBwYXJhbWV0ZXJzLiBJZiBvcHRpb25hbCBAcGFyYW0gY29udGV4dFxuICogaXMgcGFzc2VkLCB0aGUgcGFzc2VkIHByb3BlcnRpZXMgYXJlIGFwcGxpZWQgdG8gdGhlIHNlc3Npb24gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBjb250ZXh0IChvcHRpb25hbCkgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIHJldHVybmVkIHNlc3Npb24gb2JqZWN0XG4gKlxuICogQHJldHVybnMgYSBuZXcgYFNlc3Npb25gIG9iamVjdFxuICovXG5mdW5jdGlvbiBtYWtlU2Vzc2lvbihjb250ZXh0KSB7XG4gIC8vIEJvdGggdGltZXN0YW1wIGFuZCBzdGFydGVkIGFyZSBpbiBzZWNvbmRzIHNpbmNlIHRoZSBVTklYIGVwb2NoLlxuICBjb25zdCBzdGFydGluZ1RpbWUgPSB0aW1lc3RhbXBJblNlY29uZHMoKTtcblxuICBjb25zdCBzZXNzaW9uID0ge1xuICAgIHNpZDogdXVpZDQoKSxcbiAgICBpbml0OiB0cnVlLFxuICAgIHRpbWVzdGFtcDogc3RhcnRpbmdUaW1lLFxuICAgIHN0YXJ0ZWQ6IHN0YXJ0aW5nVGltZSxcbiAgICBkdXJhdGlvbjogMCxcbiAgICBzdGF0dXM6ICdvaycsXG4gICAgZXJyb3JzOiAwLFxuICAgIGlnbm9yZUR1cmF0aW9uOiBmYWxzZSxcbiAgICB0b0pTT046ICgpID0+IHNlc3Npb25Ub0pTT04oc2Vzc2lvbiksXG4gIH07XG5cbiAgaWYgKGNvbnRleHQpIHtcbiAgICB1cGRhdGVTZXNzaW9uKHNlc3Npb24sIGNvbnRleHQpO1xuICB9XG5cbiAgcmV0dXJuIHNlc3Npb247XG59XG5cbi8qKlxuICogVXBkYXRlcyBhIHNlc3Npb24gb2JqZWN0IHdpdGggdGhlIHByb3BlcnRpZXMgcGFzc2VkIGluIHRoZSBjb250ZXh0LlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIG11dGF0ZXMgdGhlIHBhc3NlZCBvYmplY3QgYW5kIHJldHVybnMgdm9pZC5cbiAqIChIYWQgdG8gZG8gdGhpcyBpbnN0ZWFkIG9mIHJldHVybmluZyBhIG5ldyBhbmQgdXBkYXRlZCBzZXNzaW9uIGJlY2F1c2UgY2xvc2luZyBhbmQgc2VuZGluZyBhIHNlc3Npb25cbiAqIG1ha2VzIGFuIHVwZGF0ZSB0byB0aGUgc2Vzc2lvbiBhZnRlciBpdCB3YXMgcGFzc2VkIHRvIHRoZSBzZW5kaW5nIGxvZ2ljLlxuICogQHNlZSBCYXNlQ2xpZW50LmNhcHR1cmVTZXNzaW9uIClcbiAqXG4gKiBAcGFyYW0gc2Vzc2lvbiB0aGUgYFNlc3Npb25gIHRvIHVwZGF0ZVxuICogQHBhcmFtIGNvbnRleHQgdGhlIGBTZXNzaW9uQ29udGV4dGAgaG9sZGluZyB0aGUgcHJvcGVydGllcyB0aGF0IHNob3VsZCBiZSB1cGRhdGVkIGluIEBwYXJhbSBzZXNzaW9uXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5mdW5jdGlvbiB1cGRhdGVTZXNzaW9uKHNlc3Npb24sIGNvbnRleHQgPSB7fSkge1xuICBpZiAoY29udGV4dC51c2VyKSB7XG4gICAgaWYgKCFzZXNzaW9uLmlwQWRkcmVzcyAmJiBjb250ZXh0LnVzZXIuaXBfYWRkcmVzcykge1xuICAgICAgc2Vzc2lvbi5pcEFkZHJlc3MgPSBjb250ZXh0LnVzZXIuaXBfYWRkcmVzcztcbiAgICB9XG5cbiAgICBpZiAoIXNlc3Npb24uZGlkICYmICFjb250ZXh0LmRpZCkge1xuICAgICAgc2Vzc2lvbi5kaWQgPSBjb250ZXh0LnVzZXIuaWQgfHwgY29udGV4dC51c2VyLmVtYWlsIHx8IGNvbnRleHQudXNlci51c2VybmFtZTtcbiAgICB9XG4gIH1cblxuICBzZXNzaW9uLnRpbWVzdGFtcCA9IGNvbnRleHQudGltZXN0YW1wIHx8IHRpbWVzdGFtcEluU2Vjb25kcygpO1xuXG4gIGlmIChjb250ZXh0LmFibm9ybWFsX21lY2hhbmlzbSkge1xuICAgIHNlc3Npb24uYWJub3JtYWxfbWVjaGFuaXNtID0gY29udGV4dC5hYm5vcm1hbF9tZWNoYW5pc207XG4gIH1cblxuICBpZiAoY29udGV4dC5pZ25vcmVEdXJhdGlvbikge1xuICAgIHNlc3Npb24uaWdub3JlRHVyYXRpb24gPSBjb250ZXh0Lmlnbm9yZUR1cmF0aW9uO1xuICB9XG4gIGlmIChjb250ZXh0LnNpZCkge1xuICAgIC8vIEdvb2QgZW5vdWdoIHV1aWQgdmFsaWRhdGlvbi4g4oCUIEthbWlsXG4gICAgc2Vzc2lvbi5zaWQgPSBjb250ZXh0LnNpZC5sZW5ndGggPT09IDMyID8gY29udGV4dC5zaWQgOiB1dWlkNCgpO1xuICB9XG4gIGlmIChjb250ZXh0LmluaXQgIT09IHVuZGVmaW5lZCkge1xuICAgIHNlc3Npb24uaW5pdCA9IGNvbnRleHQuaW5pdDtcbiAgfVxuICBpZiAoIXNlc3Npb24uZGlkICYmIGNvbnRleHQuZGlkKSB7XG4gICAgc2Vzc2lvbi5kaWQgPSBgJHtjb250ZXh0LmRpZH1gO1xuICB9XG4gIGlmICh0eXBlb2YgY29udGV4dC5zdGFydGVkID09PSAnbnVtYmVyJykge1xuICAgIHNlc3Npb24uc3RhcnRlZCA9IGNvbnRleHQuc3RhcnRlZDtcbiAgfVxuICBpZiAoc2Vzc2lvbi5pZ25vcmVEdXJhdGlvbikge1xuICAgIHNlc3Npb24uZHVyYXRpb24gPSB1bmRlZmluZWQ7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNvbnRleHQuZHVyYXRpb24gPT09ICdudW1iZXInKSB7XG4gICAgc2Vzc2lvbi5kdXJhdGlvbiA9IGNvbnRleHQuZHVyYXRpb247XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZHVyYXRpb24gPSBzZXNzaW9uLnRpbWVzdGFtcCAtIHNlc3Npb24uc3RhcnRlZDtcbiAgICBzZXNzaW9uLmR1cmF0aW9uID0gZHVyYXRpb24gPj0gMCA/IGR1cmF0aW9uIDogMDtcbiAgfVxuICBpZiAoY29udGV4dC5yZWxlYXNlKSB7XG4gICAgc2Vzc2lvbi5yZWxlYXNlID0gY29udGV4dC5yZWxlYXNlO1xuICB9XG4gIGlmIChjb250ZXh0LmVudmlyb25tZW50KSB7XG4gICAgc2Vzc2lvbi5lbnZpcm9ubWVudCA9IGNvbnRleHQuZW52aXJvbm1lbnQ7XG4gIH1cbiAgaWYgKCFzZXNzaW9uLmlwQWRkcmVzcyAmJiBjb250ZXh0LmlwQWRkcmVzcykge1xuICAgIHNlc3Npb24uaXBBZGRyZXNzID0gY29udGV4dC5pcEFkZHJlc3M7XG4gIH1cbiAgaWYgKCFzZXNzaW9uLnVzZXJBZ2VudCAmJiBjb250ZXh0LnVzZXJBZ2VudCkge1xuICAgIHNlc3Npb24udXNlckFnZW50ID0gY29udGV4dC51c2VyQWdlbnQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb250ZXh0LmVycm9ycyA9PT0gJ251bWJlcicpIHtcbiAgICBzZXNzaW9uLmVycm9ycyA9IGNvbnRleHQuZXJyb3JzO1xuICB9XG4gIGlmIChjb250ZXh0LnN0YXR1cykge1xuICAgIHNlc3Npb24uc3RhdHVzID0gY29udGV4dC5zdGF0dXM7XG4gIH1cbn1cblxuLyoqXG4gKiBDbG9zZXMgYSBzZXNzaW9uIGJ5IHNldHRpbmcgaXRzIHN0YXR1cyBhbmQgdXBkYXRpbmcgdGhlIHNlc3Npb24gb2JqZWN0IHdpdGggaXQuXG4gKiBJbnRlcm5hbGx5IGNhbGxzIGB1cGRhdGVTZXNzaW9uYCB0byB1cGRhdGUgdGhlIHBhc3NlZCBzZXNzaW9uIG9iamVjdC5cbiAqXG4gKiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBtdXRhdGVzIHRoZSBwYXNzZWQgc2Vzc2lvbiAoQHNlZSB1cGRhdGVTZXNzaW9uIGZvciBleHBsYW5hdGlvbikuXG4gKlxuICogQHBhcmFtIHNlc3Npb24gdGhlIGBTZXNzaW9uYCBvYmplY3QgdG8gYmUgY2xvc2VkXG4gKiBAcGFyYW0gc3RhdHVzIHRoZSBgU2Vzc2lvblN0YXR1c2Agd2l0aCB3aGljaCB0aGUgc2Vzc2lvbiB3YXMgY2xvc2VkLiBJZiB5b3UgZG9uJ3QgcGFzcyBhIHN0YXR1cyxcbiAqICAgICAgICAgICAgICAgdGhpcyBmdW5jdGlvbiB3aWxsIGtlZXAgdGhlIHByZXZpb3VzbHkgc2V0IHN0YXR1cywgdW5sZXNzIGl0IHdhcyBgJ29rJ2AgaW4gd2hpY2ggY2FzZVxuICogICAgICAgICAgICAgICBpdCBpcyBjaGFuZ2VkIHRvIGAnZXhpdGVkJ2AuXG4gKi9cbmZ1bmN0aW9uIGNsb3NlU2Vzc2lvbihzZXNzaW9uLCBzdGF0dXMpIHtcbiAgbGV0IGNvbnRleHQgPSB7fTtcbiAgaWYgKHN0YXR1cykge1xuICAgIGNvbnRleHQgPSB7IHN0YXR1cyB9O1xuICB9IGVsc2UgaWYgKHNlc3Npb24uc3RhdHVzID09PSAnb2snKSB7XG4gICAgY29udGV4dCA9IHsgc3RhdHVzOiAnZXhpdGVkJyB9O1xuICB9XG5cbiAgdXBkYXRlU2Vzc2lvbihzZXNzaW9uLCBjb250ZXh0KTtcbn1cblxuLyoqXG4gKiBTZXJpYWxpemVzIGEgcGFzc2VkIHNlc3Npb24gb2JqZWN0IHRvIGEgSlNPTiBvYmplY3Qgd2l0aCBhIHNsaWdodGx5IGRpZmZlcmVudCBzdHJ1Y3R1cmUuXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHRoZSBTZW50cnkgYmFja2VuZCByZXF1aXJlcyBhIHNsaWdodGx5IGRpZmZlcmVudCBzY2hlbWEgb2YgYSBzZXNzaW9uXG4gKiB0aGFuIHRoZSBvbmUgdGhlIEpTIFNES3MgdXNlIGludGVybmFsbHkuXG4gKlxuICogQHBhcmFtIHNlc3Npb24gdGhlIHNlc3Npb24gdG8gYmUgY29udmVydGVkXG4gKlxuICogQHJldHVybnMgYSBKU09OIG9iamVjdCBvZiB0aGUgcGFzc2VkIHNlc3Npb25cbiAqL1xuZnVuY3Rpb24gc2Vzc2lvblRvSlNPTihzZXNzaW9uKSB7XG4gIHJldHVybiBkcm9wVW5kZWZpbmVkS2V5cyh7XG4gICAgc2lkOiBgJHtzZXNzaW9uLnNpZH1gLFxuICAgIGluaXQ6IHNlc3Npb24uaW5pdCxcbiAgICAvLyBNYWtlIHN1cmUgdGhhdCBzZWMgaXMgY29udmVydGVkIHRvIG1zIGZvciBkYXRlIGNvbnN0cnVjdG9yXG4gICAgc3RhcnRlZDogbmV3IERhdGUoc2Vzc2lvbi5zdGFydGVkICogMTAwMCkudG9JU09TdHJpbmcoKSxcbiAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKHNlc3Npb24udGltZXN0YW1wICogMTAwMCkudG9JU09TdHJpbmcoKSxcbiAgICBzdGF0dXM6IHNlc3Npb24uc3RhdHVzLFxuICAgIGVycm9yczogc2Vzc2lvbi5lcnJvcnMsXG4gICAgZGlkOiB0eXBlb2Ygc2Vzc2lvbi5kaWQgPT09ICdudW1iZXInIHx8IHR5cGVvZiBzZXNzaW9uLmRpZCA9PT0gJ3N0cmluZycgPyBgJHtzZXNzaW9uLmRpZH1gIDogdW5kZWZpbmVkLFxuICAgIGR1cmF0aW9uOiBzZXNzaW9uLmR1cmF0aW9uLFxuICAgIGFibm9ybWFsX21lY2hhbmlzbTogc2Vzc2lvbi5hYm5vcm1hbF9tZWNoYW5pc20sXG4gICAgYXR0cnM6IHtcbiAgICAgIHJlbGVhc2U6IHNlc3Npb24ucmVsZWFzZSxcbiAgICAgIGVudmlyb25tZW50OiBzZXNzaW9uLmVudmlyb25tZW50LFxuICAgICAgaXBfYWRkcmVzczogc2Vzc2lvbi5pcEFkZHJlc3MsXG4gICAgICB1c2VyX2FnZW50OiBzZXNzaW9uLnVzZXJBZ2VudCxcbiAgICB9LFxuICB9KTtcbn1cblxuZXhwb3J0IHsgY2xvc2VTZXNzaW9uLCBtYWtlU2Vzc2lvbiwgdXBkYXRlU2Vzc2lvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2Vzc2lvbi5qcy5tYXBcbiJdLCJuYW1lcyI6WyJ0aW1lc3RhbXBJblNlY29uZHMiLCJ1dWlkNCIsImRyb3BVbmRlZmluZWRLZXlzIiwibWFrZVNlc3Npb24iLCJjb250ZXh0Iiwic3RhcnRpbmdUaW1lIiwic2Vzc2lvbiIsInNpZCIsImluaXQiLCJ0aW1lc3RhbXAiLCJzdGFydGVkIiwiZHVyYXRpb24iLCJzdGF0dXMiLCJlcnJvcnMiLCJpZ25vcmVEdXJhdGlvbiIsInRvSlNPTiIsInNlc3Npb25Ub0pTT04iLCJ1cGRhdGVTZXNzaW9uIiwidXNlciIsImlwQWRkcmVzcyIsImlwX2FkZHJlc3MiLCJkaWQiLCJpZCIsImVtYWlsIiwidXNlcm5hbWUiLCJhYm5vcm1hbF9tZWNoYW5pc20iLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJyZWxlYXNlIiwiZW52aXJvbm1lbnQiLCJ1c2VyQWdlbnQiLCJjbG9zZVNlc3Npb24iLCJEYXRlIiwidG9JU09TdHJpbmciLCJhdHRycyIsInVzZXJfYWdlbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/core/esm/session.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sentry/core/esm/tracing/dynamicSamplingContext.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@sentry/core/esm/tracing/dynamicSamplingContext.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getDynamicSamplingContextFromClient: () => (/* binding */ getDynamicSamplingContextFromClient),\n/* harmony export */   getDynamicSamplingContextFromSpan: () => (/* binding */ getDynamicSamplingContextFromSpan)\n/* harmony export */ });\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sentry/utils */ \"(ssr)/./node_modules/@sentry/utils/esm/object.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants.js */ \"(ssr)/./node_modules/@sentry/core/esm/constants.js\");\n/* harmony import */ var _exports_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../exports.js */ \"(ssr)/./node_modules/@sentry/core/esm/exports.js\");\n/* harmony import */ var _utils_getRootSpan_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/getRootSpan.js */ \"(ssr)/./node_modules/@sentry/core/esm/utils/getRootSpan.js\");\n/* harmony import */ var _utils_spanUtils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/spanUtils.js */ \"(ssr)/./node_modules/@sentry/core/esm/utils/spanUtils.js\");\n\n\n\n\n\n/**\n * Creates a dynamic sampling context from a client.\n *\n * Dispatches the `createDsc` lifecycle hook as a side effect.\n */ function getDynamicSamplingContextFromClient(trace_id, client, scope) {\n    const options = client.getOptions();\n    const { publicKey: public_key } = client.getDsn() || {};\n    // TODO(v8): Remove segment from User\n    // eslint-disable-next-line deprecation/deprecation\n    const { segment: user_segment } = scope && scope.getUser() || {};\n    const dsc = (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_0__.dropUndefinedKeys)({\n        environment: options.environment || _constants_js__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_ENVIRONMENT,\n        release: options.release,\n        user_segment,\n        public_key,\n        trace_id\n    });\n    client.emit && client.emit(\"createDsc\", dsc);\n    return dsc;\n}\n/**\n * A Span with a frozen dynamic sampling context.\n */ /**\n * Creates a dynamic sampling context from a span (and client and scope)\n *\n * @param span the span from which a few values like the root span name and sample rate are extracted.\n *\n * @returns a dynamic sampling context\n */ function getDynamicSamplingContextFromSpan(span) {\n    const client = (0,_exports_js__WEBPACK_IMPORTED_MODULE_2__.getClient)();\n    if (!client) {\n        return {};\n    }\n    // passing emit=false here to only emit later once the DSC is actually populated\n    const dsc = getDynamicSamplingContextFromClient((0,_utils_spanUtils_js__WEBPACK_IMPORTED_MODULE_3__.spanToJSON)(span).trace_id || \"\", client, (0,_exports_js__WEBPACK_IMPORTED_MODULE_2__.getCurrentScope)());\n    // TODO (v8): Remove v7FrozenDsc as a Transaction will no longer have _frozenDynamicSamplingContext\n    const txn = (0,_utils_getRootSpan_js__WEBPACK_IMPORTED_MODULE_4__.getRootSpan)(span);\n    if (!txn) {\n        return dsc;\n    }\n    // TODO (v8): Remove v7FrozenDsc as a Transaction will no longer have _frozenDynamicSamplingContext\n    // For now we need to avoid breaking users who directly created a txn with a DSC, where this field is still set.\n    // @see Transaction class constructor\n    const v7FrozenDsc = txn && txn._frozenDynamicSamplingContext;\n    if (v7FrozenDsc) {\n        return v7FrozenDsc;\n    }\n    // TODO (v8): Replace txn.metadata with txn.attributes[]\n    // We can't do this yet because attributes aren't always set yet.\n    // eslint-disable-next-line deprecation/deprecation\n    const { sampleRate: maybeSampleRate, source } = txn.metadata;\n    if (maybeSampleRate != null) {\n        dsc.sample_rate = `${maybeSampleRate}`;\n    }\n    // We don't want to have a transaction name in the DSC if the source is \"url\" because URLs might contain PII\n    const jsonSpan = (0,_utils_spanUtils_js__WEBPACK_IMPORTED_MODULE_3__.spanToJSON)(txn);\n    // after JSON conversion, txn.name becomes jsonSpan.description\n    if (source && source !== \"url\") {\n        dsc.transaction = jsonSpan.description;\n    }\n    dsc.sampled = String((0,_utils_spanUtils_js__WEBPACK_IMPORTED_MODULE_3__.spanIsSampled)(txn));\n    client.emit && client.emit(\"createDsc\", dsc);\n    return dsc;\n}\n //# sourceMappingURL=dynamicSamplingContext.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2VzbS90cmFjaW5nL2R5bmFtaWNTYW1wbGluZ0NvbnRleHQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFrRDtBQUNJO0FBQ0s7QUFDTDtBQUNZO0FBRWxFOzs7O0NBSUMsR0FDRCxTQUFTTyxvQ0FDUEMsUUFBUSxFQUNSQyxNQUFNLEVBQ05DLEtBQUs7SUFFTCxNQUFNQyxVQUFVRixPQUFPRyxVQUFVO0lBRWpDLE1BQU0sRUFBRUMsV0FBV0MsVUFBVSxFQUFFLEdBQUdMLE9BQU9NLE1BQU0sTUFBTSxDQUFDO0lBQ3RELHFDQUFxQztJQUNyQyxtREFBbUQ7SUFDbkQsTUFBTSxFQUFFQyxTQUFTQyxZQUFZLEVBQUUsR0FBRyxTQUFVUCxNQUFNUSxPQUFPLE1BQU8sQ0FBQztJQUVqRSxNQUFNQyxNQUFNbkIsZ0VBQWlCQSxDQUFDO1FBQzVCb0IsYUFBYVQsUUFBUVMsV0FBVyxJQUFJbkIsOERBQW1CQTtRQUN2RG9CLFNBQVNWLFFBQVFVLE9BQU87UUFDeEJKO1FBQ0FIO1FBQ0FOO0lBQ0Y7SUFFQUMsT0FBT2EsSUFBSSxJQUFJYixPQUFPYSxJQUFJLENBQUMsYUFBYUg7SUFFeEMsT0FBT0E7QUFDVDtBQUVBOztDQUVDLEdBRUQ7Ozs7OztDQU1DLEdBQ0QsU0FBU0ksa0NBQWtDQyxJQUFJO0lBQzdDLE1BQU1mLFNBQVNQLHNEQUFTQTtJQUN4QixJQUFJLENBQUNPLFFBQVE7UUFDWCxPQUFPLENBQUM7SUFDVjtJQUVBLGdGQUFnRjtJQUNoRixNQUFNVSxNQUFNWixvQ0FBb0NGLCtEQUFVQSxDQUFDbUIsTUFBTWhCLFFBQVEsSUFBSSxJQUFJQyxRQUFRTiw0REFBZUE7SUFFeEcsbUdBQW1HO0lBQ25HLE1BQU1zQixNQUFNckIsa0VBQVdBLENBQUNvQjtJQUN4QixJQUFJLENBQUNDLEtBQUs7UUFDUixPQUFPTjtJQUNUO0lBRUEsbUdBQW1HO0lBQ25HLGdIQUFnSDtJQUNoSCxxQ0FBcUM7SUFDckMsTUFBTU8sY0FBY0QsT0FBT0EsSUFBSUUsNkJBQTZCO0lBQzVELElBQUlELGFBQWE7UUFDZixPQUFPQTtJQUNUO0lBRUEsd0RBQXdEO0lBQ3hELGlFQUFpRTtJQUNqRSxtREFBbUQ7SUFDbkQsTUFBTSxFQUFFRSxZQUFZQyxlQUFlLEVBQUVDLE1BQU0sRUFBRSxHQUFHTCxJQUFJTSxRQUFRO0lBQzVELElBQUlGLG1CQUFtQixNQUFNO1FBQzNCVixJQUFJYSxXQUFXLEdBQUcsQ0FBQyxFQUFFSCxnQkFBZ0IsQ0FBQztJQUN4QztJQUVBLDRHQUE0RztJQUM1RyxNQUFNSSxXQUFXNUIsK0RBQVVBLENBQUNvQjtJQUU1QiwrREFBK0Q7SUFDL0QsSUFBSUssVUFBVUEsV0FBVyxPQUFPO1FBQzlCWCxJQUFJZSxXQUFXLEdBQUdELFNBQVNFLFdBQVc7SUFDeEM7SUFFQWhCLElBQUlpQixPQUFPLEdBQUdDLE9BQU8vQixrRUFBYUEsQ0FBQ21CO0lBRW5DaEIsT0FBT2EsSUFBSSxJQUFJYixPQUFPYSxJQUFJLENBQUMsYUFBYUg7SUFFeEMsT0FBT0E7QUFDVDtBQUVrRixDQUNsRixrREFBa0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vYnJhbGluay13ZWIvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2VzbS90cmFjaW5nL2R5bmFtaWNTYW1wbGluZ0NvbnRleHQuanM/YjdmYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkcm9wVW5kZWZpbmVkS2V5cyB9IGZyb20gJ0BzZW50cnkvdXRpbHMnO1xuaW1wb3J0IHsgREVGQVVMVF9FTlZJUk9OTUVOVCB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBnZXRDbGllbnQsIGdldEN1cnJlbnRTY29wZSB9IGZyb20gJy4uL2V4cG9ydHMuanMnO1xuaW1wb3J0IHsgZ2V0Um9vdFNwYW4gfSBmcm9tICcuLi91dGlscy9nZXRSb290U3Bhbi5qcyc7XG5pbXBvcnQgeyBzcGFuVG9KU09OLCBzcGFuSXNTYW1wbGVkIH0gZnJvbSAnLi4vdXRpbHMvc3BhblV0aWxzLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZHluYW1pYyBzYW1wbGluZyBjb250ZXh0IGZyb20gYSBjbGllbnQuXG4gKlxuICogRGlzcGF0Y2hlcyB0aGUgYGNyZWF0ZURzY2AgbGlmZWN5Y2xlIGhvb2sgYXMgYSBzaWRlIGVmZmVjdC5cbiAqL1xuZnVuY3Rpb24gZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21DbGllbnQoXG4gIHRyYWNlX2lkLFxuICBjbGllbnQsXG4gIHNjb3BlLFxuKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBjbGllbnQuZ2V0T3B0aW9ucygpO1xuXG4gIGNvbnN0IHsgcHVibGljS2V5OiBwdWJsaWNfa2V5IH0gPSBjbGllbnQuZ2V0RHNuKCkgfHwge307XG4gIC8vIFRPRE8odjgpOiBSZW1vdmUgc2VnbWVudCBmcm9tIFVzZXJcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gIGNvbnN0IHsgc2VnbWVudDogdXNlcl9zZWdtZW50IH0gPSAoc2NvcGUgJiYgc2NvcGUuZ2V0VXNlcigpKSB8fCB7fTtcblxuICBjb25zdCBkc2MgPSBkcm9wVW5kZWZpbmVkS2V5cyh7XG4gICAgZW52aXJvbm1lbnQ6IG9wdGlvbnMuZW52aXJvbm1lbnQgfHwgREVGQVVMVF9FTlZJUk9OTUVOVCxcbiAgICByZWxlYXNlOiBvcHRpb25zLnJlbGVhc2UsXG4gICAgdXNlcl9zZWdtZW50LFxuICAgIHB1YmxpY19rZXksXG4gICAgdHJhY2VfaWQsXG4gIH0pIDtcblxuICBjbGllbnQuZW1pdCAmJiBjbGllbnQuZW1pdCgnY3JlYXRlRHNjJywgZHNjKTtcblxuICByZXR1cm4gZHNjO1xufVxuXG4vKipcbiAqIEEgU3BhbiB3aXRoIGEgZnJvemVuIGR5bmFtaWMgc2FtcGxpbmcgY29udGV4dC5cbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkeW5hbWljIHNhbXBsaW5nIGNvbnRleHQgZnJvbSBhIHNwYW4gKGFuZCBjbGllbnQgYW5kIHNjb3BlKVxuICpcbiAqIEBwYXJhbSBzcGFuIHRoZSBzcGFuIGZyb20gd2hpY2ggYSBmZXcgdmFsdWVzIGxpa2UgdGhlIHJvb3Qgc3BhbiBuYW1lIGFuZCBzYW1wbGUgcmF0ZSBhcmUgZXh0cmFjdGVkLlxuICpcbiAqIEByZXR1cm5zIGEgZHluYW1pYyBzYW1wbGluZyBjb250ZXh0XG4gKi9cbmZ1bmN0aW9uIGdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tU3BhbihzcGFuKSB7XG4gIGNvbnN0IGNsaWVudCA9IGdldENsaWVudCgpO1xuICBpZiAoIWNsaWVudCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8vIHBhc3NpbmcgZW1pdD1mYWxzZSBoZXJlIHRvIG9ubHkgZW1pdCBsYXRlciBvbmNlIHRoZSBEU0MgaXMgYWN0dWFsbHkgcG9wdWxhdGVkXG4gIGNvbnN0IGRzYyA9IGdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tQ2xpZW50KHNwYW5Ub0pTT04oc3BhbikudHJhY2VfaWQgfHwgJycsIGNsaWVudCwgZ2V0Q3VycmVudFNjb3BlKCkpO1xuXG4gIC8vIFRPRE8gKHY4KTogUmVtb3ZlIHY3RnJvemVuRHNjIGFzIGEgVHJhbnNhY3Rpb24gd2lsbCBubyBsb25nZXIgaGF2ZSBfZnJvemVuRHluYW1pY1NhbXBsaW5nQ29udGV4dFxuICBjb25zdCB0eG4gPSBnZXRSb290U3BhbihzcGFuKSA7XG4gIGlmICghdHhuKSB7XG4gICAgcmV0dXJuIGRzYztcbiAgfVxuXG4gIC8vIFRPRE8gKHY4KTogUmVtb3ZlIHY3RnJvemVuRHNjIGFzIGEgVHJhbnNhY3Rpb24gd2lsbCBubyBsb25nZXIgaGF2ZSBfZnJvemVuRHluYW1pY1NhbXBsaW5nQ29udGV4dFxuICAvLyBGb3Igbm93IHdlIG5lZWQgdG8gYXZvaWQgYnJlYWtpbmcgdXNlcnMgd2hvIGRpcmVjdGx5IGNyZWF0ZWQgYSB0eG4gd2l0aCBhIERTQywgd2hlcmUgdGhpcyBmaWVsZCBpcyBzdGlsbCBzZXQuXG4gIC8vIEBzZWUgVHJhbnNhY3Rpb24gY2xhc3MgY29uc3RydWN0b3JcbiAgY29uc3QgdjdGcm96ZW5Ec2MgPSB0eG4gJiYgdHhuLl9mcm96ZW5EeW5hbWljU2FtcGxpbmdDb250ZXh0O1xuICBpZiAodjdGcm96ZW5Ec2MpIHtcbiAgICByZXR1cm4gdjdGcm96ZW5Ec2M7XG4gIH1cblxuICAvLyBUT0RPICh2OCk6IFJlcGxhY2UgdHhuLm1ldGFkYXRhIHdpdGggdHhuLmF0dHJpYnV0ZXNbXVxuICAvLyBXZSBjYW4ndCBkbyB0aGlzIHlldCBiZWNhdXNlIGF0dHJpYnV0ZXMgYXJlbid0IGFsd2F5cyBzZXQgeWV0LlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgY29uc3QgeyBzYW1wbGVSYXRlOiBtYXliZVNhbXBsZVJhdGUsIHNvdXJjZSB9ID0gdHhuLm1ldGFkYXRhO1xuICBpZiAobWF5YmVTYW1wbGVSYXRlICE9IG51bGwpIHtcbiAgICBkc2Muc2FtcGxlX3JhdGUgPSBgJHttYXliZVNhbXBsZVJhdGV9YDtcbiAgfVxuXG4gIC8vIFdlIGRvbid0IHdhbnQgdG8gaGF2ZSBhIHRyYW5zYWN0aW9uIG5hbWUgaW4gdGhlIERTQyBpZiB0aGUgc291cmNlIGlzIFwidXJsXCIgYmVjYXVzZSBVUkxzIG1pZ2h0IGNvbnRhaW4gUElJXG4gIGNvbnN0IGpzb25TcGFuID0gc3BhblRvSlNPTih0eG4pO1xuXG4gIC8vIGFmdGVyIEpTT04gY29udmVyc2lvbiwgdHhuLm5hbWUgYmVjb21lcyBqc29uU3Bhbi5kZXNjcmlwdGlvblxuICBpZiAoc291cmNlICYmIHNvdXJjZSAhPT0gJ3VybCcpIHtcbiAgICBkc2MudHJhbnNhY3Rpb24gPSBqc29uU3Bhbi5kZXNjcmlwdGlvbjtcbiAgfVxuXG4gIGRzYy5zYW1wbGVkID0gU3RyaW5nKHNwYW5Jc1NhbXBsZWQodHhuKSk7XG5cbiAgY2xpZW50LmVtaXQgJiYgY2xpZW50LmVtaXQoJ2NyZWF0ZURzYycsIGRzYyk7XG5cbiAgcmV0dXJuIGRzYztcbn1cblxuZXhwb3J0IHsgZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21DbGllbnQsIGdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tU3BhbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZHluYW1pY1NhbXBsaW5nQ29udGV4dC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJkcm9wVW5kZWZpbmVkS2V5cyIsIkRFRkFVTFRfRU5WSVJPTk1FTlQiLCJnZXRDbGllbnQiLCJnZXRDdXJyZW50U2NvcGUiLCJnZXRSb290U3BhbiIsInNwYW5Ub0pTT04iLCJzcGFuSXNTYW1wbGVkIiwiZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21DbGllbnQiLCJ0cmFjZV9pZCIsImNsaWVudCIsInNjb3BlIiwib3B0aW9ucyIsImdldE9wdGlvbnMiLCJwdWJsaWNLZXkiLCJwdWJsaWNfa2V5IiwiZ2V0RHNuIiwic2VnbWVudCIsInVzZXJfc2VnbWVudCIsImdldFVzZXIiLCJkc2MiLCJlbnZpcm9ubWVudCIsInJlbGVhc2UiLCJlbWl0IiwiZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21TcGFuIiwic3BhbiIsInR4biIsInY3RnJvemVuRHNjIiwiX2Zyb3plbkR5bmFtaWNTYW1wbGluZ0NvbnRleHQiLCJzYW1wbGVSYXRlIiwibWF5YmVTYW1wbGVSYXRlIiwic291cmNlIiwibWV0YWRhdGEiLCJzYW1wbGVfcmF0ZSIsImpzb25TcGFuIiwidHJhbnNhY3Rpb24iLCJkZXNjcmlwdGlvbiIsInNhbXBsZWQiLCJTdHJpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/core/esm/tracing/dynamicSamplingContext.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sentry/core/esm/utils/applyScopeDataToEvent.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@sentry/core/esm/utils/applyScopeDataToEvent.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyScopeDataToEvent: () => (/* binding */ applyScopeDataToEvent),\n/* harmony export */   mergeAndOverwriteScopeData: () => (/* binding */ mergeAndOverwriteScopeData),\n/* harmony export */   mergeScopeData: () => (/* binding */ mergeScopeData)\n/* harmony export */ });\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sentry/utils */ \"(ssr)/./node_modules/@sentry/utils/esm/object.js\");\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @sentry/utils */ \"(ssr)/./node_modules/@sentry/utils/esm/misc.js\");\n/* harmony import */ var _tracing_dynamicSamplingContext_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../tracing/dynamicSamplingContext.js */ \"(ssr)/./node_modules/@sentry/core/esm/tracing/dynamicSamplingContext.js\");\n/* harmony import */ var _getRootSpan_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getRootSpan.js */ \"(ssr)/./node_modules/@sentry/core/esm/utils/getRootSpan.js\");\n/* harmony import */ var _spanUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./spanUtils.js */ \"(ssr)/./node_modules/@sentry/core/esm/utils/spanUtils.js\");\n\n\n\n\n/**\n * Applies data from the scope to the event and runs all event processors on it.\n */ function applyScopeDataToEvent(event, data) {\n    const { fingerprint, span, breadcrumbs, sdkProcessingMetadata } = data;\n    // Apply general data\n    applyDataToEvent(event, data);\n    // We want to set the trace context for normal events only if there isn't already\n    // a trace context on the event. There is a product feature in place where we link\n    // errors with transaction and it relies on that.\n    if (span) {\n        applySpanToEvent(event, span);\n    }\n    applyFingerprintToEvent(event, fingerprint);\n    applyBreadcrumbsToEvent(event, breadcrumbs);\n    applySdkMetadataToEvent(event, sdkProcessingMetadata);\n}\n/** Merge data of two scopes together. */ function mergeScopeData(data, mergeData) {\n    const { extra, tags, user, contexts, level, sdkProcessingMetadata, breadcrumbs, fingerprint, eventProcessors, attachments, propagationContext, // eslint-disable-next-line deprecation/deprecation\n    transactionName, span } = mergeData;\n    mergeAndOverwriteScopeData(data, \"extra\", extra);\n    mergeAndOverwriteScopeData(data, \"tags\", tags);\n    mergeAndOverwriteScopeData(data, \"user\", user);\n    mergeAndOverwriteScopeData(data, \"contexts\", contexts);\n    mergeAndOverwriteScopeData(data, \"sdkProcessingMetadata\", sdkProcessingMetadata);\n    if (level) {\n        data.level = level;\n    }\n    if (transactionName) {\n        // eslint-disable-next-line deprecation/deprecation\n        data.transactionName = transactionName;\n    }\n    if (span) {\n        data.span = span;\n    }\n    if (breadcrumbs.length) {\n        data.breadcrumbs = [\n            ...data.breadcrumbs,\n            ...breadcrumbs\n        ];\n    }\n    if (fingerprint.length) {\n        data.fingerprint = [\n            ...data.fingerprint,\n            ...fingerprint\n        ];\n    }\n    if (eventProcessors.length) {\n        data.eventProcessors = [\n            ...data.eventProcessors,\n            ...eventProcessors\n        ];\n    }\n    if (attachments.length) {\n        data.attachments = [\n            ...data.attachments,\n            ...attachments\n        ];\n    }\n    data.propagationContext = {\n        ...data.propagationContext,\n        ...propagationContext\n    };\n}\n/**\n * Merges certain scope data. Undefined values will overwrite any existing values.\n * Exported only for tests.\n */ function mergeAndOverwriteScopeData(data, prop, mergeVal) {\n    if (mergeVal && Object.keys(mergeVal).length) {\n        // Clone object\n        data[prop] = {\n            ...data[prop]\n        };\n        for(const key in mergeVal){\n            if (Object.prototype.hasOwnProperty.call(mergeVal, key)) {\n                data[prop][key] = mergeVal[key];\n            }\n        }\n    }\n}\nfunction applyDataToEvent(event, data) {\n    const { extra, tags, user, contexts, level, // eslint-disable-next-line deprecation/deprecation\n    transactionName } = data;\n    const cleanedExtra = (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_0__.dropUndefinedKeys)(extra);\n    if (cleanedExtra && Object.keys(cleanedExtra).length) {\n        event.extra = {\n            ...cleanedExtra,\n            ...event.extra\n        };\n    }\n    const cleanedTags = (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_0__.dropUndefinedKeys)(tags);\n    if (cleanedTags && Object.keys(cleanedTags).length) {\n        event.tags = {\n            ...cleanedTags,\n            ...event.tags\n        };\n    }\n    const cleanedUser = (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_0__.dropUndefinedKeys)(user);\n    if (cleanedUser && Object.keys(cleanedUser).length) {\n        event.user = {\n            ...cleanedUser,\n            ...event.user\n        };\n    }\n    const cleanedContexts = (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_0__.dropUndefinedKeys)(contexts);\n    if (cleanedContexts && Object.keys(cleanedContexts).length) {\n        event.contexts = {\n            ...cleanedContexts,\n            ...event.contexts\n        };\n    }\n    if (level) {\n        event.level = level;\n    }\n    if (transactionName) {\n        event.transaction = transactionName;\n    }\n}\nfunction applyBreadcrumbsToEvent(event, breadcrumbs) {\n    const mergedBreadcrumbs = [\n        ...event.breadcrumbs || [],\n        ...breadcrumbs\n    ];\n    event.breadcrumbs = mergedBreadcrumbs.length ? mergedBreadcrumbs : undefined;\n}\nfunction applySdkMetadataToEvent(event, sdkProcessingMetadata) {\n    event.sdkProcessingMetadata = {\n        ...event.sdkProcessingMetadata,\n        ...sdkProcessingMetadata\n    };\n}\nfunction applySpanToEvent(event, span) {\n    event.contexts = {\n        trace: (0,_spanUtils_js__WEBPACK_IMPORTED_MODULE_1__.spanToTraceContext)(span),\n        ...event.contexts\n    };\n    const rootSpan = (0,_getRootSpan_js__WEBPACK_IMPORTED_MODULE_2__.getRootSpan)(span);\n    if (rootSpan) {\n        event.sdkProcessingMetadata = {\n            dynamicSamplingContext: (0,_tracing_dynamicSamplingContext_js__WEBPACK_IMPORTED_MODULE_3__.getDynamicSamplingContextFromSpan)(span),\n            ...event.sdkProcessingMetadata\n        };\n        const transactionName = (0,_spanUtils_js__WEBPACK_IMPORTED_MODULE_1__.spanToJSON)(rootSpan).description;\n        if (transactionName) {\n            event.tags = {\n                transaction: transactionName,\n                ...event.tags\n            };\n        }\n    }\n}\n/**\n * Applies fingerprint from the scope to the event if there's one,\n * uses message if there's one instead or get rid of empty fingerprint\n */ function applyFingerprintToEvent(event, fingerprint) {\n    // Make sure it's an array first and we actually have something in place\n    event.fingerprint = event.fingerprint ? (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_4__.arrayify)(event.fingerprint) : [];\n    // If we have something on the scope, then merge it with event\n    if (fingerprint) {\n        event.fingerprint = event.fingerprint.concat(fingerprint);\n    }\n    // If we have no data at all, remove empty array default\n    if (event.fingerprint && !event.fingerprint.length) {\n        delete event.fingerprint;\n    }\n}\n //# sourceMappingURL=applyScopeDataToEvent.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2VzbS91dGlscy9hcHBseVNjb3BlRGF0YVRvRXZlbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBNEQ7QUFDNkI7QUFDMUM7QUFDaUI7QUFFaEU7O0NBRUMsR0FDRCxTQUFTTSxzQkFBc0JDLEtBQUssRUFBRUMsSUFBSTtJQUN4QyxNQUFNLEVBQUVDLFdBQVcsRUFBRUMsSUFBSSxFQUFFQyxXQUFXLEVBQUVDLHFCQUFxQixFQUFFLEdBQUdKO0lBRWxFLHFCQUFxQjtJQUNyQkssaUJBQWlCTixPQUFPQztJQUV4QixpRkFBaUY7SUFDakYsa0ZBQWtGO0lBQ2xGLGlEQUFpRDtJQUNqRCxJQUFJRSxNQUFNO1FBQ1JJLGlCQUFpQlAsT0FBT0c7SUFDMUI7SUFFQUssd0JBQXdCUixPQUFPRTtJQUMvQk8sd0JBQXdCVCxPQUFPSTtJQUMvQk0sd0JBQXdCVixPQUFPSztBQUNqQztBQUVBLHVDQUF1QyxHQUN2QyxTQUFTTSxlQUFlVixJQUFJLEVBQUVXLFNBQVM7SUFDckMsTUFBTSxFQUNKQyxLQUFLLEVBQ0xDLElBQUksRUFDSkMsSUFBSSxFQUNKQyxRQUFRLEVBQ1JDLEtBQUssRUFDTFoscUJBQXFCLEVBQ3JCRCxXQUFXLEVBQ1hGLFdBQVcsRUFDWGdCLGVBQWUsRUFDZkMsV0FBVyxFQUNYQyxrQkFBa0IsRUFDbEIsbURBQW1EO0lBQ25EQyxlQUFlLEVBQ2ZsQixJQUFJLEVBQ0wsR0FBR1M7SUFFSlUsMkJBQTJCckIsTUFBTSxTQUFTWTtJQUMxQ1MsMkJBQTJCckIsTUFBTSxRQUFRYTtJQUN6Q1EsMkJBQTJCckIsTUFBTSxRQUFRYztJQUN6Q08sMkJBQTJCckIsTUFBTSxZQUFZZTtJQUM3Q00sMkJBQTJCckIsTUFBTSx5QkFBeUJJO0lBRTFELElBQUlZLE9BQU87UUFDVGhCLEtBQUtnQixLQUFLLEdBQUdBO0lBQ2Y7SUFFQSxJQUFJSSxpQkFBaUI7UUFDbkIsbURBQW1EO1FBQ25EcEIsS0FBS29CLGVB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cUIsTUFBTSxFQUFFO1FBQ2xELE9BQU92QixNQUFNRSxXQUFXO0lBQzFCO0FBQ0Y7QUFFNkUsQ0FDN0UsaURBQWlEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb2JyYWxpbmstd2ViLy4vbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9lc20vdXRpbHMvYXBwbHlTY29wZURhdGFUb0V2ZW50LmpzP2Q5ODciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZHJvcFVuZGVmaW5lZEtleXMsIGFycmF5aWZ5IH0gZnJvbSAnQHNlbnRyeS91dGlscyc7XG5pbXBvcnQgeyBnZXREeW5hbWljU2FtcGxpbmdDb250ZXh0RnJvbVNwYW4gfSBmcm9tICcuLi90cmFjaW5nL2R5bmFtaWNTYW1wbGluZ0NvbnRleHQuanMnO1xuaW1wb3J0IHsgZ2V0Um9vdFNwYW4gfSBmcm9tICcuL2dldFJvb3RTcGFuLmpzJztcbmltcG9ydCB7IHNwYW5Ub1RyYWNlQ29udGV4dCwgc3BhblRvSlNPTiB9IGZyb20gJy4vc3BhblV0aWxzLmpzJztcblxuLyoqXG4gKiBBcHBsaWVzIGRhdGEgZnJvbSB0aGUgc2NvcGUgdG8gdGhlIGV2ZW50IGFuZCBydW5zIGFsbCBldmVudCBwcm9jZXNzb3JzIG9uIGl0LlxuICovXG5mdW5jdGlvbiBhcHBseVNjb3BlRGF0YVRvRXZlbnQoZXZlbnQsIGRhdGEpIHtcbiAgY29uc3QgeyBmaW5nZXJwcmludCwgc3BhbiwgYnJlYWRjcnVtYnMsIHNka1Byb2Nlc3NpbmdNZXRhZGF0YSB9ID0gZGF0YTtcblxuICAvLyBBcHBseSBnZW5lcmFsIGRhdGFcbiAgYXBwbHlEYXRhVG9FdmVudChldmVudCwgZGF0YSk7XG5cbiAgLy8gV2Ugd2FudCB0byBzZXQgdGhlIHRyYWNlIGNvbnRleHQgZm9yIG5vcm1hbCBldmVudHMgb25seSBpZiB0aGVyZSBpc24ndCBhbHJlYWR5XG4gIC8vIGEgdHJhY2UgY29udGV4dCBvbiB0aGUgZXZlbnQuIFRoZXJlIGlzIGEgcHJvZHVjdCBmZWF0dXJlIGluIHBsYWNlIHdoZXJlIHdlIGxpbmtcbiAgLy8gZXJyb3JzIHdpdGggdHJhbnNhY3Rpb24gYW5kIGl0IHJlbGllcyBvbiB0aGF0LlxuICBpZiAoc3Bhbikge1xuICAgIGFwcGx5U3BhblRvRXZlbnQoZXZlbnQsIHNwYW4pO1xuICB9XG5cbiAgYXBwbHlGaW5nZXJwcmludFRvRXZlbnQoZXZlbnQsIGZpbmdlcnByaW50KTtcbiAgYXBwbHlCcmVhZGNydW1ic1RvRXZlbnQoZXZlbnQsIGJyZWFkY3J1bWJzKTtcbiAgYXBwbHlTZGtNZXRhZGF0YVRvRXZlbnQoZXZlbnQsIHNka1Byb2Nlc3NpbmdNZXRhZGF0YSk7XG59XG5cbi8qKiBNZXJnZSBkYXRhIG9mIHR3byBzY29wZXMgdG9nZXRoZXIuICovXG5mdW5jdGlvbiBtZXJnZVNjb3BlRGF0YShkYXRhLCBtZXJnZURhdGEpIHtcbiAgY29uc3Qge1xuICAgIGV4dHJhLFxuICAgIHRhZ3MsXG4gICAgdXNlcixcbiAgICBjb250ZXh0cyxcbiAgICBsZXZlbCxcbiAgICBzZGtQcm9jZXNzaW5nTWV0YWRhdGEsXG4gICAgYnJlYWRjcnVtYnMsXG4gICAgZmluZ2VycHJpbnQsXG4gICAgZXZlbnRQcm9jZXNzb3JzLFxuICAgIGF0dGFjaG1lbnRzLFxuICAgIHByb3BhZ2F0aW9uQ29udGV4dCxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgICB0cmFuc2FjdGlvbk5hbWUsXG4gICAgc3BhbixcbiAgfSA9IG1lcmdlRGF0YTtcblxuICBtZXJnZUFuZE92ZXJ3cml0ZVNjb3BlRGF0YShkYXRhLCAnZXh0cmEnLCBleHRyYSk7XG4gIG1lcmdlQW5kT3ZlcndyaXRlU2NvcGVEYXRhKGRhdGEsICd0YWdzJywgdGFncyk7XG4gIG1lcmdlQW5kT3ZlcndyaXRlU2NvcGVEYXRhKGRhdGEsICd1c2VyJywgdXNlcik7XG4gIG1lcmdlQW5kT3ZlcndyaXRlU2NvcGVEYXRhKGRhdGEsICdjb250ZXh0cycsIGNvbnRleHRzKTtcbiAgbWVyZ2VBbmRPdmVyd3JpdGVTY29wZURhdGEoZGF0YSwgJ3Nka1Byb2Nlc3NpbmdNZXRhZGF0YScsIHNka1Byb2Nlc3NpbmdNZXRhZGF0YSk7XG5cbiAgaWYgKGxldmVsKSB7XG4gICAgZGF0YS5sZXZlbCA9IGxldmVsO1xuICB9XG5cbiAgaWYgKHRyYW5zYWN0aW9uTmFtZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICAgIGRhdGEudHJhbnNhY3Rpb25OYW1lID0gdHJhbnNhY3Rpb25OYW1lO1xuICB9XG5cbiAgaWYgKHNwYW4pIHtcbiAgICBkYXRhLnNwYW4gPSBzcGFuO1xuICB9XG5cbiAgaWYgKGJyZWFkY3J1bWJzLmxlbmd0aCkge1xuICAgIGRhdGEuYnJlYWRjcnVtYnMgPSBbLi4uZGF0YS5icmVhZGNydW1icywgLi4uYnJlYWRjcnVtYnNdO1xuICB9XG5cbiAgaWYgKGZpbmdlcnByaW50Lmxlbmd0aCkge1xuICAgIGRhdGEuZmluZ2VycHJpbnQgPSBbLi4uZGF0YS5maW5nZXJwcmludCwgLi4uZmluZ2VycHJpbnRdO1xuICB9XG5cbiAgaWYgKGV2ZW50UHJvY2Vzc29ycy5sZW5ndGgpIHtcbiAgICBkYXRhLmV2ZW50UHJvY2Vzc29ycyA9IFsuLi5kYXRhLmV2ZW50UHJvY2Vzc29ycywgLi4uZXZlbnRQcm9jZXNzb3JzXTtcbiAgfVxuXG4gIGlmIChhdHRhY2htZW50cy5sZW5ndGgpIHtcbiAgICBkYXRhLmF0dGFjaG1lbnRzID0gWy4uLmRhdGEuYXR0YWNobWVudHMsIC4uLmF0dGFjaG1lbnRzXTtcbiAgfVxuXG4gIGRhdGEucHJvcGFnYXRpb25Db250ZXh0ID0geyAuLi5kYXRhLnByb3BhZ2F0aW9uQ29udGV4dCwgLi4ucHJvcGFnYXRpb25Db250ZXh0IH07XG59XG5cbi8qKlxuICogTWVyZ2VzIGNlcnRhaW4gc2NvcGUgZGF0YS4gVW5kZWZpbmVkIHZhbHVlcyB3aWxsIG92ZXJ3cml0ZSBhbnkgZXhpc3RpbmcgdmFsdWVzLlxuICogRXhwb3J0ZWQgb25seSBmb3IgdGVzdHMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlQW5kT3ZlcndyaXRlU2NvcGVEYXRhXG5cbihkYXRhLCBwcm9wLCBtZXJnZVZhbCkge1xuICBpZiAobWVyZ2VWYWwgJiYgT2JqZWN0LmtleXMobWVyZ2VWYWwpLmxlbmd0aCkge1xuICAgIC8vIENsb25lIG9iamVjdFxuICAgIGRhdGFbcHJvcF0gPSB7IC4uLmRhdGFbcHJvcF0gfTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBtZXJnZVZhbCkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtZXJnZVZhbCwga2V5KSkge1xuICAgICAgICBkYXRhW3Byb3BdW2tleV0gPSBtZXJnZVZhbFtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseURhdGFUb0V2ZW50KGV2ZW50LCBkYXRhKSB7XG4gIGNvbnN0IHtcbiAgICBleHRyYSxcbiAgICB0YWdzLFxuICAgIHVzZXIsXG4gICAgY29udGV4dHMsXG4gICAgbGV2ZWwsXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gICAgdHJhbnNhY3Rpb25OYW1lLFxuICB9ID0gZGF0YTtcblxuICBjb25zdCBjbGVhbmVkRXh0cmEgPSBkcm9wVW5kZWZpbmVkS2V5cyhleHRyYSk7XG4gIGlmIChjbGVhbmVkRXh0cmEgJiYgT2JqZWN0LmtleXMoY2xlYW5lZEV4dHJhKS5sZW5ndGgpIHtcbiAgICBldmVudC5leHRyYSA9IHsgLi4uY2xlYW5lZEV4dHJhLCAuLi5ldmVudC5leHRyYSB9O1xuICB9XG5cbiAgY29uc3QgY2xlYW5lZFRhZ3MgPSBkcm9wVW5kZWZpbmVkS2V5cyh0YWdzKTtcbiAgaWYgKGNsZWFuZWRUYWdzICYmIE9iamVjdC5rZXlzKGNsZWFuZWRUYWdzKS5sZW5ndGgpIHtcbiAgICBldmVudC50YWdzID0geyAuLi5jbGVhbmVkVGFncywgLi4uZXZlbnQudGFncyB9O1xuICB9XG5cbiAgY29uc3QgY2xlYW5lZFVzZXIgPSBkcm9wVW5kZWZpbmVkS2V5cyh1c2VyKTtcbiAgaWYgKGNsZWFuZWRVc2VyICYmIE9iamVjdC5rZXlzKGNsZWFuZWRVc2VyKS5sZW5ndGgpIHtcbiAgICBldmVudC51c2VyID0geyAuLi5jbGVhbmVkVXNlciwgLi4uZXZlbnQudXNlciB9O1xuICB9XG5cbiAgY29uc3QgY2xlYW5lZENvbnRleHRzID0gZHJvcFVuZGVmaW5lZEtleXMoY29udGV4dHMpO1xuICBpZiAoY2xlYW5lZENvbnRleHRzICYmIE9iamVjdC5rZXlzKGNsZWFuZWRDb250ZXh0cykubGVuZ3RoKSB7XG4gICAgZXZlbnQuY29udGV4dHMgPSB7IC4uLmNsZWFuZWRDb250ZXh0cywgLi4uZXZlbnQuY29udGV4dHMgfTtcbiAgfVxuXG4gIGlmIChsZXZlbCkge1xuICAgIGV2ZW50LmxldmVsID0gbGV2ZWw7XG4gIH1cblxuICBpZiAodHJhbnNhY3Rpb25OYW1lKSB7XG4gICAgZXZlbnQudHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbk5hbWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlCcmVhZGNydW1ic1RvRXZlbnQoZXZlbnQsIGJyZWFkY3J1bWJzKSB7XG4gIGNvbnN0IG1lcmdlZEJyZWFkY3J1bWJzID0gWy4uLihldmVudC5icmVhZGNydW1icyB8fCBbXSksIC4uLmJyZWFkY3J1bWJzXTtcbiAgZXZlbnQuYnJlYWRjcnVtYnMgPSBtZXJnZWRCcmVhZGNydW1icy5sZW5ndGggPyBtZXJnZWRCcmVhZGNydW1icyA6IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gYXBwbHlTZGtNZXRhZGF0YVRvRXZlbnQoZXZlbnQsIHNka1Byb2Nlc3NpbmdNZXRhZGF0YSkge1xuICBldmVudC5zZGtQcm9jZXNzaW5nTWV0YWRhdGEgPSB7XG4gICAgLi4uZXZlbnQuc2RrUHJvY2Vzc2luZ01ldGFkYXRhLFxuICAgIC4uLnNka1Byb2Nlc3NpbmdNZXRhZGF0YSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXBwbHlTcGFuVG9FdmVudChldmVudCwgc3Bhbikge1xuICBldmVudC5jb250ZXh0cyA9IHsgdHJhY2U6IHNwYW5Ub1RyYWNlQ29udGV4dChzcGFuKSwgLi4uZXZlbnQuY29udGV4dHMgfTtcbiAgY29uc3Qgcm9vdFNwYW4gPSBnZXRSb290U3BhbihzcGFuKTtcbiAgaWYgKHJvb3RTcGFuKSB7XG4gICAgZXZlbnQuc2RrUHJvY2Vzc2luZ01ldGFkYXRhID0ge1xuICAgICAgZHluYW1pY1NhbXBsaW5nQ29udGV4dDogZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21TcGFuKHNwYW4pLFxuICAgICAgLi4uZXZlbnQuc2RrUHJvY2Vzc2luZ01ldGFkYXRhLFxuICAgIH07XG4gICAgY29uc3QgdHJhbnNhY3Rpb25OYW1lID0gc3BhblRvSlNPTihyb290U3BhbikuZGVzY3JpcHRpb247XG4gICAgaWYgKHRyYW5zYWN0aW9uTmFtZSkge1xuICAgICAgZXZlbnQudGFncyA9IHsgdHJhbnNhY3Rpb246IHRyYW5zYWN0aW9uTmFtZSwgLi4uZXZlbnQudGFncyB9O1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFwcGxpZXMgZmluZ2VycHJpbnQgZnJvbSB0aGUgc2NvcGUgdG8gdGhlIGV2ZW50IGlmIHRoZXJlJ3Mgb25lLFxuICogdXNlcyBtZXNzYWdlIGlmIHRoZXJlJ3Mgb25lIGluc3RlYWQgb3IgZ2V0IHJpZCBvZiBlbXB0eSBmaW5nZXJwcmludFxuICovXG5mdW5jdGlvbiBhcHBseUZpbmdlcnByaW50VG9FdmVudChldmVudCwgZmluZ2VycHJpbnQpIHtcbiAgLy8gTWFrZSBzdXJlIGl0J3MgYW4gYXJyYXkgZmlyc3QgYW5kIHdlIGFjdHVhbGx5IGhhdmUgc29tZXRoaW5nIGluIHBsYWNlXG4gIGV2ZW50LmZpbmdlcnByaW50ID0gZXZlbnQuZmluZ2VycHJpbnQgPyBhcnJheWlmeShldmVudC5maW5nZXJwcmludCkgOiBbXTtcblxuICAvLyBJZiB3ZSBoYXZlIHNvbWV0aGluZyBvbiB0aGUgc2NvcGUsIHRoZW4gbWVyZ2UgaXQgd2l0aCBldmVudFxuICBpZiAoZmluZ2VycHJpbnQpIHtcbiAgICBldmVudC5maW5nZXJwcmludCA9IGV2ZW50LmZpbmdlcnByaW50LmNvbmNhdChmaW5nZXJwcmludCk7XG4gIH1cblxuICAvLyBJZiB3ZSBoYXZlIG5vIGRhdGEgYXQgYWxsLCByZW1vdmUgZW1wdHkgYXJyYXkgZGVmYXVsdFxuICBpZiAoZXZlbnQuZmluZ2VycHJpbnQgJiYgIWV2ZW50LmZpbmdlcnByaW50Lmxlbmd0aCkge1xuICAgIGRlbGV0ZSBldmVudC5maW5nZXJwcmludDtcbiAgfVxufVxuXG5leHBvcnQgeyBhcHBseVNjb3BlRGF0YVRvRXZlbnQsIG1lcmdlQW5kT3ZlcndyaXRlU2NvcGVEYXRhLCBtZXJnZVNjb3BlRGF0YSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwbHlTY29wZURhdGFUb0V2ZW50LmpzLm1hcFxuIl0sIm5hbWVzIjpbImRyb3BVbmRlZmluZWRLZXlzIiwiYXJyYXlpZnkiLCJnZXREeW5hbWljU2FtcGxpbmdDb250ZXh0RnJvbVNwYW4iLCJnZXRSb290U3BhbiIsInNwYW5Ub1RyYWNlQ29udGV4dCIsInNwYW5Ub0pTT04iLCJhcHBseVNjb3BlRGF0YVRvRXZlbnQiLCJldmVudCIsImRhdGEiLCJmaW5nZXJwcmludCIsInNwYW4iLCJicmVhZGNydW1icyIsInNka1Byb2Nlc3NpbmdNZXRhZGF0YSIsImFwcGx5RGF0YVRvRXZlbnQiLCJhcHBseVNwYW5Ub0V2ZW50IiwiYXBwbHlGaW5nZXJwcmludFRvRXZlbnQiLCJhcHBseUJyZWFkY3J1bWJzVG9FdmVudCIsImFwcGx5U2RrTWV0YWRhdGFUb0V2ZW50IiwibWVyZ2VTY29wZURhdGEiLCJtZXJnZURhdGEiLCJleHRyYSIsInRhZ3MiLCJ1c2VyIiwiY29udGV4dHMiLCJsZXZlbCIsImV2ZW50UHJvY2Vzc29ycyIsImF0dGFjaG1lbnRzIiwicHJvcGFnYXRpb25Db250ZXh0IiwidHJhbnNhY3Rpb25OYW1lIiwibWVyZ2VBbmRPdmVyd3JpdGVTY29wZURhdGEiLCJsZW5ndGgiLCJwcm9wIiwibWVyZ2VWYWwiLCJPYmplY3QiLCJrZXlzIiwia2V5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiY2xlYW5lZEV4dHJhIiwiY2xlYW5lZFRhZ3MiLCJjbGVhbmVkVXNlciIsImNsZWFuZWRDb250ZXh0cyIsInRyYW5zYWN0aW9uIiwibWVyZ2VkQnJlYWRjcnVtYnMiLCJ1bmRlZmluZWQiLCJ0cmFjZSIsInJvb3RTcGFuIiwiZHluYW1pY1NhbXBsaW5nQ29udGV4dCIsImRlc2NyaXB0aW9uIiwiY29uY2F0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/core/esm/utils/applyScopeDataToEvent.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sentry/core/esm/utils/getRootSpan.js":
/*!************************************************************!*\
  !*** ./node_modules/@sentry/core/esm/utils/getRootSpan.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getRootSpan: () => (/* binding */ getRootSpan)\n/* harmony export */ });\n/**\n * Returns the root span of a given span.\n *\n * As long as we use `Transaction`s internally, the returned root span\n * will be a `Transaction` but be aware that this might change in the future.\n *\n * If the given span has no root span or transaction, `undefined` is returned.\n */ function getRootSpan(span) {\n    // TODO (v8): Remove this check and just return span\n    // eslint-disable-next-line deprecation/deprecation\n    return span.transaction;\n}\n //# sourceMappingURL=getRootSpan.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2VzbS91dGlscy9nZXRSb290U3Bhbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7Ozs7Ozs7Q0FPQyxHQUNELFNBQVNBLFlBQVlDLElBQUk7SUFDdkIsb0RBQW9EO0lBQ3BELG1EQUFtRDtJQUNuRCxPQUFPQSxLQUFLQyxXQUFXO0FBQ3pCO0FBRXVCLENBQ3ZCLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL29icmFsaW5rLXdlYi8uL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvZXNtL3V0aWxzL2dldFJvb3RTcGFuLmpzP2Y2MjEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBSZXR1cm5zIHRoZSByb290IHNwYW4gb2YgYSBnaXZlbiBzcGFuLlxuICpcbiAqIEFzIGxvbmcgYXMgd2UgdXNlIGBUcmFuc2FjdGlvbmBzIGludGVybmFsbHksIHRoZSByZXR1cm5lZCByb290IHNwYW5cbiAqIHdpbGwgYmUgYSBgVHJhbnNhY3Rpb25gIGJ1dCBiZSBhd2FyZSB0aGF0IHRoaXMgbWlnaHQgY2hhbmdlIGluIHRoZSBmdXR1cmUuXG4gKlxuICogSWYgdGhlIGdpdmVuIHNwYW4gaGFzIG5vIHJvb3Qgc3BhbiBvciB0cmFuc2FjdGlvbiwgYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQuXG4gKi9cbmZ1bmN0aW9uIGdldFJvb3RTcGFuKHNwYW4pIHtcbiAgLy8gVE9ETyAodjgpOiBSZW1vdmUgdGhpcyBjaGVjayBhbmQganVzdCByZXR1cm4gc3BhblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgcmV0dXJuIHNwYW4udHJhbnNhY3Rpb247XG59XG5cbmV4cG9ydCB7IGdldFJvb3RTcGFuIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRSb290U3Bhbi5qcy5tYXBcbiJdLCJuYW1lcyI6WyJnZXRSb290U3BhbiIsInNwYW4iLCJ0cmFuc2FjdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/core/esm/utils/getRootSpan.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sentry/core/esm/utils/prepareEvent.js":
/*!*************************************************************!*\
  !*** ./node_modules/@sentry/core/esm/utils/prepareEvent.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyDebugIds: () => (/* binding */ applyDebugIds),\n/* harmony export */   applyDebugMeta: () => (/* binding */ applyDebugMeta),\n/* harmony export */   parseEventHintOrCaptureContext: () => (/* binding */ parseEventHintOrCaptureContext),\n/* harmony export */   prepareEvent: () => (/* binding */ prepareEvent)\n/* harmony export */ });\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sentry/utils */ \"(ssr)/./node_modules/@sentry/utils/esm/misc.js\");\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @sentry/utils */ \"(ssr)/./node_modules/@sentry/utils/esm/time.js\");\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @sentry/utils */ \"(ssr)/./node_modules/@sentry/utils/esm/string.js\");\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @sentry/utils */ \"(ssr)/./node_modules/@sentry/utils/esm/worldwide.js\");\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @sentry/utils */ \"(ssr)/./node_modules/@sentry/utils/esm/normalize.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../constants.js */ \"(ssr)/./node_modules/@sentry/core/esm/constants.js\");\n/* harmony import */ var _eventProcessors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../eventProcessors.js */ \"(ssr)/./node_modules/@sentry/core/esm/eventProcessors.js\");\n/* harmony import */ var _scope_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../scope.js */ \"(ssr)/./node_modules/@sentry/core/esm/scope.js\");\n/* harmony import */ var _applyScopeDataToEvent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./applyScopeDataToEvent.js */ \"(ssr)/./node_modules/@sentry/core/esm/utils/applyScopeDataToEvent.js\");\n/* harmony import */ var _spanUtils_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./spanUtils.js */ \"(ssr)/./node_modules/@sentry/core/esm/utils/spanUtils.js\");\n\n\n\n\n\n\n/**\n * This type makes sure that we get either a CaptureContext, OR an EventHint.\n * It does not allow mixing them, which could lead to unexpected outcomes, e.g. this is disallowed:\n * { user: { id: '123' }, mechanism: { handled: false } }\n */ /**\n * Adds common information to events.\n *\n * The information includes release and environment from `options`,\n * breadcrumbs and context (extra, tags and user) from the scope.\n *\n * Information that is already present in the event is never overwritten. For\n * nested objects, such as the context, keys are merged.\n *\n * Note: This also triggers callbacks for `addGlobalEventProcessor`, but not `beforeSend`.\n *\n * @param event The original event.\n * @param hint May contain additional information about the original exception.\n * @param scope A scope containing event metadata.\n * @returns A new event with more information.\n * @hidden\n */ function prepareEvent(options, event, hint, scope, client, isolationScope) {\n    const { normalizeDepth = 3, normalizeMaxBreadth = 1000 } = options;\n    const prepared = {\n        ...event,\n        event_id: event.event_id || hint.event_id || (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_0__.uuid4)(),\n        timestamp: event.timestamp || (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_1__.dateTimestampInSeconds)()\n    };\n    const integrations = hint.integrations || options.integrations.map((i)=>i.name);\n    applyClientOptions(prepared, options);\n    applyIntegrationsMetadata(prepared, integrations);\n    // Only put debug IDs onto frames for error events.\n    if (event.type === undefined) {\n        applyDebugIds(prepared, options.stackParser);\n    }\n    // If we have scope given to us, use it as the base for further modifications.\n    // This allows us to prevent unnecessary copying of data if `captureContext` is not provided.\n    const finalScope = getFinalScope(scope, hint.captureContext);\n    if (hint.mechanism) {\n        (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_0__.addExceptionMechanism)(prepared, hint.mechanism);\n    }\n    const clientEventProcessors = client && client.getEventProcessors ? client.getEventProcessors() : [];\n    // This should be the last thing called, since we want that\n    // {@link Hub.addEventProcessor} gets the finished prepared event.\n    // Merge scope data together\n    const data = (0,_scope_js__WEBPACK_IMPORTED_MODULE_2__.getGlobalScope)().getScopeData();\n    if (isolationScope) {\n        const isolationData = isolationScope.getScopeData();\n        (0,_applyScopeDataToEvent_js__WEBPACK_IMPORTED_MODULE_3__.mergeScopeData)(data, isolationData);\n    }\n    if (finalScope) {\n        const finalScopeData = finalScope.getScopeData();\n        (0,_applyScopeDataToEvent_js__WEBPACK_IMPORTED_MODULE_3__.mergeScopeData)(data, finalScopeData);\n    }\n    const attachments = [\n        ...hint.attachments || [],\n        ...data.attachments\n    ];\n    if (attachments.length) {\n        hint.attachments = attachments;\n    }\n    (0,_applyScopeDataToEvent_js__WEBPACK_IMPORTED_MODULE_3__.applyScopeDataToEvent)(prepared, data);\n    // TODO (v8): Update this order to be: Global > Client > Scope\n    const eventProcessors = [\n        ...clientEventProcessors,\n        // eslint-disable-next-line deprecation/deprecation\n        ...(0,_eventProcessors_js__WEBPACK_IMPORTED_MODULE_4__.getGlobalEventProcessors)(),\n        // Run scope event processors _after_ all other processors\n        ...data.eventProcessors\n    ];\n    const result = (0,_eventProcessors_js__WEBPACK_IMPORTED_MODULE_4__.notifyEventProcessors)(eventProcessors, prepared, hint);\n    return result.then((evt)=>{\n        if (evt) {\n            // We apply the debug_meta field only after all event processors have ran, so that if any event processors modified\n            // file names (e.g.the RewriteFrames integration) the filename -> debug ID relationship isn't destroyed.\n            // This should not cause any PII issues, since we're only moving data that is already on the event and not adding\n            // any new data\n            applyDebugMeta(evt);\n        }\n        if (typeof normalizeDepth === \"number\" && normalizeDepth > 0) {\n            return normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);\n        }\n        return evt;\n    });\n}\n/**\n *  Enhances event using the client configuration.\n *  It takes care of all \"static\" values like environment, release and `dist`,\n *  as well as truncating overly long values.\n * @param event event instance to be enhanced\n */ function applyClientOptions(event, options) {\n    const { environment, release, dist, maxValueLength = 250 } = options;\n    if (!(\"environment\" in event)) {\n        event.environment = \"environment\" in options ? environment : _constants_js__WEBPACK_IMPORTED_MODULE_5__.DEFAULT_ENVIRONMENT;\n    }\n    if (event.release === undefined && release !== undefined) {\n        event.release = release;\n    }\n    if (event.dist === undefined && dist !== undefined) {\n        event.dist = dist;\n    }\n    if (event.message) {\n        event.message = (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_6__.truncate)(event.message, maxValueLength);\n    }\n    const exception = event.exception && event.exception.values && event.exception.values[0];\n    if (exception && exception.value) {\n        exception.value = (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_6__.truncate)(exception.value, maxValueLength);\n    }\n    const request = event.request;\n    if (request && request.url) {\n        request.url = (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_6__.truncate)(request.url, maxValueLength);\n    }\n}\nconst debugIdStackParserCache = new WeakMap();\n/**\n * Puts debug IDs into the stack frames of an error event.\n */ function applyDebugIds(event, stackParser) {\n    const debugIdMap = _sentry_utils__WEBPACK_IMPORTED_MODULE_7__.GLOBAL_OBJ._sentryDebugIds;\n    if (!debugIdMap) {\n        return;\n    }\n    let debugIdStackFramesCache;\n    const cachedDebugIdStackFrameCache = debugIdStackParserCache.get(stackParser);\n    if (cachedDebugIdStackFrameCache) {\n        debugIdStackFramesCache = cachedDebugIdStackFrameCache;\n    } else {\n        debugIdStackFramesCache = new Map();\n        debugIdStackParserCache.set(stackParser, debugIdStackFramesCache);\n    }\n    // Build a map of filename -> debug_id\n    const filenameDebugIdMap = Object.keys(debugIdMap).reduce((acc, debugIdStackTrace)=>{\n        let parsedStack;\n        const cachedParsedStack = debugIdStackFramesCache.get(debugIdStackTrace);\n        if (cachedParsedStack) {\n            parsedStack = cachedParsedStack;\n        } else {\n            parsedStack = stackParser(debugIdStackTrace);\n            debugIdStackFramesCache.set(debugIdStackTrace, parsedStack);\n        }\n        for(let i = parsedStack.length - 1; i >= 0; i--){\n            const stackFrame = parsedStack[i];\n            if (stackFrame.filename) {\n                acc[stackFrame.filename] = debugIdMap[debugIdStackTrace];\n                break;\n            }\n        }\n        return acc;\n    }, {});\n    try {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        event.exception.values.forEach((exception)=>{\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            exception.stacktrace.frames.forEach((frame)=>{\n                if (frame.filename) {\n                    frame.debug_id = filenameDebugIdMap[frame.filename];\n                }\n            });\n        });\n    } catch (e) {\n    // To save bundle size we're just try catching here instead of checking for the existence of all the different objects.\n    }\n}\n/**\n * Moves debug IDs from the stack frames of an error event into the debug_meta field.\n */ function applyDebugMeta(event) {\n    // Extract debug IDs and filenames from the stack frames on the event.\n    const filenameDebugIdMap = {};\n    try {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        event.exception.values.forEach((exception)=>{\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            exception.stacktrace.frames.forEach((frame)=>{\n                if (frame.debug_id) {\n                    if (frame.abs_path) {\n                        filenameDebugIdMap[frame.abs_path] = frame.debug_id;\n                    } else if (frame.filename) {\n                        filenameDebugIdMap[frame.filename] = frame.debug_id;\n                    }\n                    delete frame.debug_id;\n                }\n            });\n        });\n    } catch (e) {\n    // To save bundle size we're just try catching here instead of checking for the existence of all the different objects.\n    }\n    if (Object.keys(filenameDebugIdMap).length === 0) {\n        return;\n    }\n    // Fill debug_meta information\n    event.debug_meta = event.debug_meta || {};\n    event.debug_meta.images = event.debug_meta.images || [];\n    const images = event.debug_meta.images;\n    Object.keys(filenameDebugIdMap).forEach((filename)=>{\n        images.push({\n            type: \"sourcemap\",\n            code_file: filename,\n            debug_id: filenameDebugIdMap[filename]\n        });\n    });\n}\n/**\n * This function adds all used integrations to the SDK info in the event.\n * @param event The event that will be filled with all integrations.\n */ function applyIntegrationsMetadata(event, integrationNames) {\n    if (integrationNames.length > 0) {\n        event.sdk = event.sdk || {};\n        event.sdk.integrations = [\n            ...event.sdk.integrations || [],\n            ...integrationNames\n        ];\n    }\n}\n/**\n * Applies `normalize` function on necessary `Event` attributes to make them safe for serialization.\n * Normalized keys:\n * - `breadcrumbs.data`\n * - `user`\n * - `contexts`\n * - `extra`\n * @param event Event\n * @returns Normalized event\n */ function normalizeEvent(event, depth, maxBreadth) {\n    if (!event) {\n        return null;\n    }\n    const normalized = {\n        ...event,\n        ...event.breadcrumbs && {\n            breadcrumbs: event.breadcrumbs.map((b)=>({\n                    ...b,\n                    ...b.data && {\n                        data: (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_8__.normalize)(b.data, depth, maxBreadth)\n                    }\n                }))\n        },\n        ...event.user && {\n            user: (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_8__.normalize)(event.user, depth, maxBreadth)\n        },\n        ...event.contexts && {\n            contexts: (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_8__.normalize)(event.contexts, depth, maxBreadth)\n        },\n        ...event.extra && {\n            extra: (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_8__.normalize)(event.extra, depth, maxBreadth)\n        }\n    };\n    // event.contexts.trace stores information about a Transaction. Similarly,\n    // event.spans[] stores information about child Spans. Given that a\n    // Transaction is conceptually a Span, normalization should apply to both\n    // Transactions and Spans consistently.\n    // For now the decision is to skip normalization of Transactions and Spans,\n    // so this block overwrites the normalized event to add back the original\n    // Transaction information prior to normalization.\n    if (event.contexts && event.contexts.trace && normalized.contexts) {\n        normalized.contexts.trace = event.contexts.trace;\n        // event.contexts.trace.data may contain circular/dangerous data so we need to normalize it\n        if (event.contexts.trace.data) {\n            normalized.contexts.trace.data = (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_8__.normalize)(event.contexts.trace.data, depth, maxBreadth);\n        }\n    }\n    // event.spans[].data may contain circular/dangerous data so we need to normalize it\n    if (event.spans) {\n        normalized.spans = event.spans.map((span)=>{\n            const data = (0,_spanUtils_js__WEBPACK_IMPORTED_MODULE_9__.spanToJSON)(span).data;\n            if (data) {\n                // This is a bit weird, as we generally have `Span` instances here, but to be safe we do not assume so\n                // eslint-disable-next-line deprecation/deprecation\n                span.data = (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_8__.normalize)(data, depth, maxBreadth);\n            }\n            return span;\n        });\n    }\n    return normalized;\n}\nfunction getFinalScope(scope, captureContext) {\n    if (!captureContext) {\n        return scope;\n    }\n    const finalScope = scope ? scope.clone() : new _scope_js__WEBPACK_IMPORTED_MODULE_2__.Scope();\n    finalScope.update(captureContext);\n    return finalScope;\n}\n/**\n * Parse either an `EventHint` directly, or convert a `CaptureContext` to an `EventHint`.\n * This is used to allow to update method signatures that used to accept a `CaptureContext` but should now accept an `EventHint`.\n */ function parseEventHintOrCaptureContext(hint) {\n    if (!hint) {\n        return undefined;\n    }\n    // If you pass a Scope or `() => Scope` as CaptureContext, we just return this as captureContext\n    if (hintIsScopeOrFunction(hint)) {\n        return {\n            captureContext: hint\n        };\n    }\n    if (hintIsScopeContext(hint)) {\n        return {\n            captureContext: hint\n        };\n    }\n    return hint;\n}\nfunction hintIsScopeOrFunction(hint) {\n    return hint instanceof _scope_js__WEBPACK_IMPORTED_MODULE_2__.Scope || typeof hint === \"function\";\n}\nconst captureContextKeys = [\n    \"user\",\n    \"level\",\n    \"extra\",\n    \"contexts\",\n    \"tags\",\n    \"fingerprint\",\n    \"requestSession\",\n    \"propagationContext\"\n];\nfunction hintIsScopeContext(hint) {\n    return Object.keys(hint).some((key)=>captureContextKeys.includes(key));\n}\n //# sourceMappingURL=prepareEvent.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2VzbS91dGlscy9wcmVwYXJlRXZlbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBc0g7QUFDaEU7QUFDa0M7QUFDcEM7QUFDK0I7QUFDdkM7QUFFNUM7Ozs7Q0FJQyxHQUVEOzs7Ozs7Ozs7Ozs7Ozs7O0NBZ0JDLEdBQ0QsU0FBU2MsYUFDUEMsT0FBTyxFQUNQQyxLQUFLLEVBQ0xDLElBQUksRUFDSkMsS0FBSyxFQUNMQyxNQUFNLEVBQ05DLGNBQWM7SUFFZCxNQUFNLEVBQUVDLGlCQUFpQixDQUFDLEVBQUVDLHNCQUFzQixJQUFJLEVBQUUsR0FBR1A7SUFDM0QsTUFBTVEsV0FBVztRQUNmLEdBQUdQLEtBQUs7UUFDUlEsVUFBVVIsTUFBTVEsUUFBUSxJQUFJUCxLQUFLTyxRQUFRLElBQUl4QixvREFBS0E7UUFDbER5QixXQUFXVCxNQUFNUyxTQUFTLElBQUl4QixxRUFBc0JBO0lBQ3REO0lBQ0EsTUFBTXlCLGVBQWVULEtBQUtTLFlBQVksSUFBSVgsUUFBUVcsWUFBWSxDQUFDQyxHQUFHLENBQUNDLENBQUFBLElBQUtBLEVBQUVDLElBQUk7SUFFOUVDLG1CQUFtQlAsVUFBVVI7SUFDN0JnQiwwQkFBMEJSLFVBQVVHO0lBRXBDLG1EQUFtRDtJQUNuRCxJQUFJVixNQUFNZ0IsSUFBSSxLQUFLQyxXQUFXO1FBQzVCQyxjQUFjWCxVQUFVUixRQUFRb0IsV0FBVztJQUM3QztJQUVBLDhFQUE4RTtJQUM5RSw2RkFBNkY7SUFDN0YsTUFBTUMsYUFBYUMsY0FBY25CLE9BQU9ELEtBQUtxQixjQUFjO0lBRTNELElBQUlyQixLQUFLc0IsU0FBUyxFQUFFO1FBQ2xCckMsb0VBQXFCQSxDQUFDcUIsVUFBVU4sS0FBS3NCLFNBQVM7SUFDaEQ7SUFFQSxNQUFNQyx3QkFBd0JyQixVQUFVQSxPQUFPc0Isa0JBQWtCLEdBQUd0QixPQUFPc0Isa0JBQWtCLEtBQUssRUFBRTtJQUVwRywyREFBMkQ7SUFD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LElBQUk4RixtQkFBbUI5RixPQUFPO1FBQzVCLE9BQU87WUFDTHFCLGdCQUFnQnJCO1FBQ2xCO0lBQ0Y7SUFFQSxPQUFPQTtBQUNUO0FBRUEsU0FBUzZGLHNCQUNQN0YsSUFBSTtJQUVKLE9BQU9BLGdCQUFnQlAsNENBQUtBLElBQUksT0FBT08sU0FBUztBQUNsRDtBQUVBLE1BQU0rRixxQkFBcUI7SUFDekI7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBRUQsU0FBU0QsbUJBQW1COUYsSUFBSTtJQUM5QixPQUFPeUQsT0FBT0MsSUFBSSxDQUFDMUQsTUFBTWdHLElBQUksQ0FBQ0MsQ0FBQUEsTUFBT0YsbUJBQW1CRyxRQUFRLENBQUNEO0FBQ25FO0FBRXVGLENBQ3ZGLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL29icmFsaW5rLXdlYi8uL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvZXNtL3V0aWxzL3ByZXBhcmVFdmVudC5qcz9lN2I4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHV1aWQ0LCBkYXRlVGltZXN0YW1wSW5TZWNvbmRzLCBhZGRFeGNlcHRpb25NZWNoYW5pc20sIHRydW5jYXRlLCBHTE9CQUxfT0JKLCBub3JtYWxpemUgfSBmcm9tICdAc2VudHJ5L3V0aWxzJztcbmltcG9ydCB7IERFRkFVTFRfRU5WSVJPTk1FTlQgfSBmcm9tICcuLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgZ2V0R2xvYmFsRXZlbnRQcm9jZXNzb3JzLCBub3RpZnlFdmVudFByb2Nlc3NvcnMgfSBmcm9tICcuLi9ldmVudFByb2Nlc3NvcnMuanMnO1xuaW1wb3J0IHsgZ2V0R2xvYmFsU2NvcGUsIFNjb3BlIH0gZnJvbSAnLi4vc2NvcGUuanMnO1xuaW1wb3J0IHsgbWVyZ2VTY29wZURhdGEsIGFwcGx5U2NvcGVEYXRhVG9FdmVudCB9IGZyb20gJy4vYXBwbHlTY29wZURhdGFUb0V2ZW50LmpzJztcbmltcG9ydCB7IHNwYW5Ub0pTT04gfSBmcm9tICcuL3NwYW5VdGlscy5qcyc7XG5cbi8qKlxuICogVGhpcyB0eXBlIG1ha2VzIHN1cmUgdGhhdCB3ZSBnZXQgZWl0aGVyIGEgQ2FwdHVyZUNvbnRleHQsIE9SIGFuIEV2ZW50SGludC5cbiAqIEl0IGRvZXMgbm90IGFsbG93IG1peGluZyB0aGVtLCB3aGljaCBjb3VsZCBsZWFkIHRvIHVuZXhwZWN0ZWQgb3V0Y29tZXMsIGUuZy4gdGhpcyBpcyBkaXNhbGxvd2VkOlxuICogeyB1c2VyOiB7IGlkOiAnMTIzJyB9LCBtZWNoYW5pc206IHsgaGFuZGxlZDogZmFsc2UgfSB9XG4gKi9cblxuLyoqXG4gKiBBZGRzIGNvbW1vbiBpbmZvcm1hdGlvbiB0byBldmVudHMuXG4gKlxuICogVGhlIGluZm9ybWF0aW9uIGluY2x1ZGVzIHJlbGVhc2UgYW5kIGVudmlyb25tZW50IGZyb20gYG9wdGlvbnNgLFxuICogYnJlYWRjcnVtYnMgYW5kIGNvbnRleHQgKGV4dHJhLCB0YWdzIGFuZCB1c2VyKSBmcm9tIHRoZSBzY29wZS5cbiAqXG4gKiBJbmZvcm1hdGlvbiB0aGF0IGlzIGFscmVhZHkgcHJlc2VudCBpbiB0aGUgZXZlbnQgaXMgbmV2ZXIgb3ZlcndyaXR0ZW4uIEZvclxuICogbmVzdGVkIG9iamVjdHMsIHN1Y2ggYXMgdGhlIGNvbnRleHQsIGtleXMgYXJlIG1lcmdlZC5cbiAqXG4gKiBOb3RlOiBUaGlzIGFsc28gdHJpZ2dlcnMgY2FsbGJhY2tzIGZvciBgYWRkR2xvYmFsRXZlbnRQcm9jZXNzb3JgLCBidXQgbm90IGBiZWZvcmVTZW5kYC5cbiAqXG4gKiBAcGFyYW0gZXZlbnQgVGhlIG9yaWdpbmFsIGV2ZW50LlxuICogQHBhcmFtIGhpbnQgTWF5IGNvbnRhaW4gYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb3JpZ2luYWwgZXhjZXB0aW9uLlxuICogQHBhcmFtIHNjb3BlIEEgc2NvcGUgY29udGFpbmluZyBldmVudCBtZXRhZGF0YS5cbiAqIEByZXR1cm5zIEEgbmV3IGV2ZW50IHdpdGggbW9yZSBpbmZvcm1hdGlvbi5cbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gcHJlcGFyZUV2ZW50KFxuICBvcHRpb25zLFxuICBldmVudCxcbiAgaGludCxcbiAgc2NvcGUsXG4gIGNsaWVudCxcbiAgaXNvbGF0aW9uU2NvcGUsXG4pIHtcbiAgY29uc3QgeyBub3JtYWxpemVEZXB0aCA9IDMsIG5vcm1hbGl6ZU1heEJyZWFkdGggPSAxMDAwIH0gPSBvcHRpb25zO1xuICBjb25zdCBwcmVwYXJlZCA9IHtcbiAgICAuLi5ldmVudCxcbiAgICBldmVudF9pZDogZXZlbnQuZXZlbnRfaWQgfHwgaGludC5ldmVudF9pZCB8fCB1dWlkNCgpLFxuICAgIHRpbWVzdGFtcDogZXZlbnQudGltZXN0YW1wIHx8IGRhdGVUaW1lc3RhbXBJblNlY29uZHMoKSxcbiAgfTtcbiAgY29uc3QgaW50ZWdyYXRpb25zID0gaGludC5pbnRlZ3JhdGlvbnMgfHwgb3B0aW9ucy5pbnRlZ3JhdGlvbnMubWFwKGkgPT4gaS5uYW1lKTtcblxuICBhcHBseUNsaWVudE9wdGlvbnMocHJlcGFyZWQsIG9wdGlvbnMpO1xuICBhcHBseUludGVncmF0aW9uc01ldGFkYXRhKHByZXBhcmVkLCBpbnRlZ3JhdGlvbnMpO1xuXG4gIC8vIE9ubHkgcHV0IGRlYnVnIElEcyBvbnRvIGZyYW1lcyBmb3IgZXJyb3IgZXZlbnRzLlxuICBpZiAoZXZlbnQudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXBwbHlEZWJ1Z0lkcyhwcmVwYXJlZCwgb3B0aW9ucy5zdGFja1BhcnNlcik7XG4gIH1cblxuICAvLyBJZiB3ZSBoYXZlIHNjb3BlIGdpdmVuIHRvIHVzLCB1c2UgaXQgYXMgdGhlIGJhc2UgZm9yIGZ1cnRoZXIgbW9kaWZpY2F0aW9ucy5cbiAgLy8gVGhpcyBhbGxvd3MgdXMgdG8gcHJldmVudCB1bm5lY2Vzc2FyeSBjb3B5aW5nIG9mIGRhdGEgaWYgYGNhcHR1cmVDb250ZXh0YCBpcyBub3QgcHJvdmlkZWQuXG4gIGNvbnN0IGZpbmFsU2NvcGUgPSBnZXRGaW5hbFNjb3BlKHNjb3BlLCBoaW50LmNhcHR1cmVDb250ZXh0KTtcblxuICBpZiAoaGludC5tZWNoYW5pc20pIHtcbiAgICBhZGRFeGNlcHRpb25NZWNoYW5pc20ocHJlcGFyZWQsIGhpbnQubWVjaGFuaXNtKTtcbiAgfVxuXG4gIGNvbnN0IGNsaWVudEV2ZW50UHJvY2Vzc29ycyA9IGNsaWVudCAmJiBjbGllbnQuZ2V0RXZlbnRQcm9jZXNzb3JzID8gY2xpZW50LmdldEV2ZW50UHJvY2Vzc29ycygpIDogW107XG5cbiAgLy8gVGhpcyBzaG91bGQgYmUgdGhlIGxhc3QgdGhpbmcgY2FsbGVkLCBzaW5jZSB3ZSB3YW50IHRoYXRcbiAgLy8ge0BsaW5rIEh1Yi5hZGRFdmVudFByb2Nlc3Nvcn0gZ2V0cyB0aGUgZmluaXNoZWQgcHJlcGFyZWQgZXZlbnQuXG4gIC8vIE1lcmdlIHNjb3BlIGRhdGEgdG9nZXRoZXJcbiAgY29uc3QgZGF0YSA9IGdldEdsb2JhbFNjb3BlKCkuZ2V0U2NvcGVEYXRhKCk7XG5cbiAgaWYgKGlzb2xhdGlvblNjb3BlKSB7XG4gICAgY29uc3QgaXNvbGF0aW9uRGF0YSA9IGlzb2xhdGlvblNjb3BlLmdldFNjb3BlRGF0YSgpO1xuICAgIG1lcmdlU2NvcGVEYXRhKGRhdGEsIGlzb2xhdGlvbkRhdGEpO1xuICB9XG5cbiAgaWYgKGZpbmFsU2NvcGUpIHtcbiAgICBjb25zdCBmaW5hbFNjb3BlRGF0YSA9IGZpbmFsU2NvcGUuZ2V0U2NvcGVEYXRhKCk7XG4gICAgbWVyZ2VTY29wZURhdGEoZGF0YSwgZmluYWxTY29wZURhdGEpO1xuICB9XG5cbiAgY29uc3QgYXR0YWNobWVudHMgPSBbLi4uKGhpbnQuYXR0YWNobWVudHMgfHwgW10pLCAuLi5kYXRhLmF0dGFjaG1lbnRzXTtcbiAgaWYgKGF0dGFjaG1lbnRzLmxlbmd0aCkge1xuICAgIGhpbnQuYXR0YWNobWVudHMgPSBhdHRhY2htZW50cztcbiAgfVxuXG4gIGFwcGx5U2NvcGVEYXRhVG9FdmVudChwcmVwYXJlZCwgZGF0YSk7XG5cbiAgLy8gVE9ETyAodjgpOiBVcGRhdGUgdGhpcyBvcmRlciB0byBiZTogR2xvYmFsID4gQ2xpZW50ID4gU2NvcGVcbiAgY29uc3QgZXZlbnRQcm9jZXNzb3JzID0gW1xuICAgIC4uLmNsaWVudEV2ZW50UHJvY2Vzc29ycyxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgICAuLi5nZXRHbG9iYWxFdmVudFByb2Nlc3NvcnMoKSxcbiAgICAvLyBSdW4gc2NvcGUgZXZlbnQgcHJvY2Vzc29ycyBfYWZ0ZXJfIGFsbCBvdGhlciBwcm9jZXNzb3JzXG4gICAgLi4uZGF0YS5ldmVudFByb2Nlc3NvcnMsXG4gIF07XG5cbiAgY29uc3QgcmVzdWx0ID0gbm90aWZ5RXZlbnRQcm9jZXNzb3JzKGV2ZW50UHJvY2Vzc29ycywgcHJlcGFyZWQsIGhpbnQpO1xuXG4gIHJldHVybiByZXN1bHQudGhlbihldnQgPT4ge1xuICAgIGlmIChldnQpIHtcbiAgICAgIC8vIFdlIGFwcGx5IHRoZSBkZWJ1Z19tZXRhIGZpZWxkIG9ubHkgYWZ0ZXIgYWxsIGV2ZW50IHByb2Nlc3NvcnMgaGF2ZSByYW4sIHNvIHRoYXQgaWYgYW55IGV2ZW50IHByb2Nlc3NvcnMgbW9kaWZpZWRcbiAgICAgIC8vIGZpbGUgbmFtZXMgKGUuZy50aGUgUmV3cml0ZUZyYW1lcyBpbnRlZ3JhdGlvbikgdGhlIGZpbGVuYW1lIC0+IGRlYnVnIElEIHJlbGF0aW9uc2hpcCBpc24ndCBkZXN0cm95ZWQuXG4gICAgICAvLyBUaGlzIHNob3VsZCBub3QgY2F1c2UgYW55IFBJSSBpc3N1ZXMsIHNpbmNlIHdlJ3JlIG9ubHkgbW92aW5nIGRhdGEgdGhhdCBpcyBhbHJlYWR5IG9uIHRoZSBldmVudCBhbmQgbm90IGFkZGluZ1xuICAgICAgLy8gYW55IG5ldyBkYXRhXG4gICAgICBhcHBseURlYnVnTWV0YShldnQpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygbm9ybWFsaXplRGVwdGggPT09ICdudW1iZXInICYmIG5vcm1hbGl6ZURlcHRoID4gMCkge1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZUV2ZW50KGV2dCwgbm9ybWFsaXplRGVwdGgsIG5vcm1hbGl6ZU1heEJyZWFkdGgpO1xuICAgIH1cbiAgICByZXR1cm4gZXZ0O1xuICB9KTtcbn1cblxuLyoqXG4gKiAgRW5oYW5jZXMgZXZlbnQgdXNpbmcgdGhlIGNsaWVudCBjb25maWd1cmF0aW9uLlxuICogIEl0IHRha2VzIGNhcmUgb2YgYWxsIFwic3RhdGljXCIgdmFsdWVzIGxpa2UgZW52aXJvbm1lbnQsIHJlbGVhc2UgYW5kIGBkaXN0YCxcbiAqICBhcyB3ZWxsIGFzIHRydW5jYXRpbmcgb3Zlcmx5IGxvbmcgdmFsdWVzLlxuICogQHBhcmFtIGV2ZW50IGV2ZW50IGluc3RhbmNlIHRvIGJlIGVuaGFuY2VkXG4gKi9cbmZ1bmN0aW9uIGFwcGx5Q2xpZW50T3B0aW9ucyhldmVudCwgb3B0aW9ucykge1xuICBjb25zdCB7IGVudmlyb25tZW50LCByZWxlYXNlLCBkaXN0LCBtYXhWYWx1ZUxlbmd0aCA9IDI1MCB9ID0gb3B0aW9ucztcblxuICBpZiAoISgnZW52aXJvbm1lbnQnIGluIGV2ZW50KSkge1xuICAgIGV2ZW50LmVudmlyb25tZW50ID0gJ2Vudmlyb25tZW50JyBpbiBvcHRpb25zID8gZW52aXJvbm1lbnQgOiBERUZBVUxUX0VOVklST05NRU5UO1xuICB9XG5cbiAgaWYgKGV2ZW50LnJlbGVhc2UgPT09IHVuZGVmaW5lZCAmJiByZWxlYXNlICE9PSB1bmRlZmluZWQpIHtcbiAgICBldmVudC5yZWxlYXNlID0gcmVsZWFzZTtcbiAgfVxuXG4gIGlmIChldmVudC5kaXN0ID09PSB1bmRlZmluZWQgJiYgZGlzdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZXZlbnQuZGlzdCA9IGRpc3Q7XG4gIH1cblxuICBpZiAoZXZlbnQubWVzc2FnZSkge1xuICAgIGV2ZW50Lm1lc3NhZ2UgPSB0cnVuY2F0ZShldmVudC5tZXNzYWdlLCBtYXhWYWx1ZUxlbmd0aCk7XG4gIH1cblxuICBjb25zdCBleGNlcHRpb24gPSBldmVudC5leGNlcHRpb24gJiYgZXZlbnQuZXhjZXB0aW9uLnZhbHVlcyAmJiBldmVudC5leGNlcHRpb24udmFsdWVzWzBdO1xuICBpZiAoZXhjZXB0aW9uICYmIGV4Y2VwdGlvbi52YWx1ZSkge1xuICAgIGV4Y2VwdGlvbi52YWx1ZSA9IHRydW5jYXRlKGV4Y2VwdGlvbi52YWx1ZSwgbWF4VmFsdWVMZW5ndGgpO1xuICB9XG5cbiAgY29uc3QgcmVxdWVzdCA9IGV2ZW50LnJlcXVlc3Q7XG4gIGlmIChyZXF1ZXN0ICYmIHJlcXVlc3QudXJsKSB7XG4gICAgcmVxdWVzdC51cmwgPSB0cnVuY2F0ZShyZXF1ZXN0LnVybCwgbWF4VmFsdWVMZW5ndGgpO1xuICB9XG59XG5cbmNvbnN0IGRlYnVnSWRTdGFja1BhcnNlckNhY2hlID0gbmV3IFdlYWtNYXAoKTtcblxuLyoqXG4gKiBQdXRzIGRlYnVnIElEcyBpbnRvIHRoZSBzdGFjayBmcmFtZXMgb2YgYW4gZXJyb3IgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5RGVidWdJZHMoZXZlbnQsIHN0YWNrUGFyc2VyKSB7XG4gIGNvbnN0IGRlYnVnSWRNYXAgPSBHTE9CQUxfT0JKLl9zZW50cnlEZWJ1Z0lkcztcblxuICBpZiAoIWRlYnVnSWRNYXApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQgZGVidWdJZFN0YWNrRnJhbWVzQ2FjaGU7XG4gIGNvbnN0IGNhY2hlZERlYnVnSWRTdGFja0ZyYW1lQ2FjaGUgPSBkZWJ1Z0lkU3RhY2tQYXJzZXJDYWNoZS5nZXQoc3RhY2tQYXJzZXIpO1xuICBpZiAoY2FjaGVkRGVidWdJZFN0YWNrRnJhbWVDYWNoZSkge1xuICAgIGRlYnVnSWRTdGFja0ZyYW1lc0NhY2hlID0gY2FjaGVkRGVidWdJZFN0YWNrRnJhbWVDYWNoZTtcbiAgfSBlbHNlIHtcbiAgICBkZWJ1Z0lkU3RhY2tGcmFtZXNDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICBkZWJ1Z0lkU3RhY2tQYXJzZXJDYWNoZS5zZXQoc3RhY2tQYXJzZXIsIGRlYnVnSWRTdGFja0ZyYW1lc0NhY2hlKTtcbiAgfVxuXG4gIC8vIEJ1aWxkIGEgbWFwIG9mIGZpbGVuYW1lIC0+IGRlYnVnX2lkXG4gIGNvbnN0IGZpbGVuYW1lRGVidWdJZE1hcCA9IE9iamVjdC5rZXlzKGRlYnVnSWRNYXApLnJlZHVjZSgoYWNjLCBkZWJ1Z0lkU3RhY2tUcmFjZSkgPT4ge1xuICAgIGxldCBwYXJzZWRTdGFjaztcbiAgICBjb25zdCBjYWNoZWRQYXJzZWRTdGFjayA9IGRlYnVnSWRTdGFja0ZyYW1lc0NhY2hlLmdldChkZWJ1Z0lkU3RhY2tUcmFjZSk7XG4gICAgaWYgKGNhY2hlZFBhcnNlZFN0YWNrKSB7XG4gICAgICBwYXJzZWRTdGFjayA9IGNhY2hlZFBhcnNlZFN0YWNrO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJzZWRTdGFjayA9IHN0YWNrUGFyc2VyKGRlYnVnSWRTdGFja1RyYWNlKTtcbiAgICAgIGRlYnVnSWRTdGFja0ZyYW1lc0NhY2hlLnNldChkZWJ1Z0lkU3RhY2tUcmFjZSwgcGFyc2VkU3RhY2spO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSBwYXJzZWRTdGFjay5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3Qgc3RhY2tGcmFtZSA9IHBhcnNlZFN0YWNrW2ldO1xuICAgICAgaWYgKHN0YWNrRnJhbWUuZmlsZW5hbWUpIHtcbiAgICAgICAgYWNjW3N0YWNrRnJhbWUuZmlsZW5hbWVdID0gZGVidWdJZE1hcFtkZWJ1Z0lkU3RhY2tUcmFjZV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG5cbiAgdHJ5IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgIGV2ZW50LmV4Y2VwdGlvbi52YWx1ZXMuZm9yRWFjaChleGNlcHRpb24gPT4ge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgIGV4Y2VwdGlvbi5zdGFja3RyYWNlLmZyYW1lcy5mb3JFYWNoKGZyYW1lID0+IHtcbiAgICAgICAgaWYgKGZyYW1lLmZpbGVuYW1lKSB7XG4gICAgICAgICAgZnJhbWUuZGVidWdfaWQgPSBmaWxlbmFtZURlYnVnSWRNYXBbZnJhbWUuZmlsZW5hbWVdO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFRvIHNhdmUgYnVuZGxlIHNpemUgd2UncmUganVzdCB0cnkgY2F0Y2hpbmcgaGVyZSBpbnN0ZWFkIG9mIGNoZWNraW5nIGZvciB0aGUgZXhpc3RlbmNlIG9mIGFsbCB0aGUgZGlmZmVyZW50IG9iamVjdHMuXG4gIH1cbn1cblxuLyoqXG4gKiBNb3ZlcyBkZWJ1ZyBJRHMgZnJvbSB0aGUgc3RhY2sgZnJhbWVzIG9mIGFuIGVycm9yIGV2ZW50IGludG8gdGhlIGRlYnVnX21ldGEgZmllbGQuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5RGVidWdNZXRhKGV2ZW50KSB7XG4gIC8vIEV4dHJhY3QgZGVidWcgSURzIGFuZCBmaWxlbmFtZXMgZnJvbSB0aGUgc3RhY2sgZnJhbWVzIG9uIHRoZSBldmVudC5cbiAgY29uc3QgZmlsZW5hbWVEZWJ1Z0lkTWFwID0ge307XG4gIHRyeSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICBldmVudC5leGNlcHRpb24udmFsdWVzLmZvckVhY2goZXhjZXB0aW9uID0+IHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICBleGNlcHRpb24uc3RhY2t0cmFjZS5mcmFtZXMuZm9yRWFjaChmcmFtZSA9PiB7XG4gICAgICAgIGlmIChmcmFtZS5kZWJ1Z19pZCkge1xuICAgICAgICAgIGlmIChmcmFtZS5hYnNfcGF0aCkge1xuICAgICAgICAgICAgZmlsZW5hbWVEZWJ1Z0lkTWFwW2ZyYW1lLmFic19wYXRoXSA9IGZyYW1lLmRlYnVnX2lkO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZnJhbWUuZmlsZW5hbWUpIHtcbiAgICAgICAgICAgIGZpbGVuYW1lRGVidWdJZE1hcFtmcmFtZS5maWxlbmFtZV0gPSBmcmFtZS5kZWJ1Z19pZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVsZXRlIGZyYW1lLmRlYnVnX2lkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFRvIHNhdmUgYnVuZGxlIHNpemUgd2UncmUganVzdCB0cnkgY2F0Y2hpbmcgaGVyZSBpbnN0ZWFkIG9mIGNoZWNraW5nIGZvciB0aGUgZXhpc3RlbmNlIG9mIGFsbCB0aGUgZGlmZmVyZW50IG9iamVjdHMuXG4gIH1cblxuICBpZiAoT2JqZWN0LmtleXMoZmlsZW5hbWVEZWJ1Z0lkTWFwKS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBGaWxsIGRlYnVnX21ldGEgaW5mb3JtYXRpb25cbiAgZXZlbnQuZGVidWdfbWV0YSA9IGV2ZW50LmRlYnVnX21ldGEgfHwge307XG4gIGV2ZW50LmRlYnVnX21ldGEuaW1hZ2VzID0gZXZlbnQuZGVidWdfbWV0YS5pbWFnZXMgfHwgW107XG4gIGNvbnN0IGltYWdlcyA9IGV2ZW50LmRlYnVnX21ldGEuaW1hZ2VzO1xuICBPYmplY3Qua2V5cyhmaWxlbmFtZURlYnVnSWRNYXApLmZvckVhY2goZmlsZW5hbWUgPT4ge1xuICAgIGltYWdlcy5wdXNoKHtcbiAgICAgIHR5cGU6ICdzb3VyY2VtYXAnLFxuICAgICAgY29kZV9maWxlOiBmaWxlbmFtZSxcbiAgICAgIGRlYnVnX2lkOiBmaWxlbmFtZURlYnVnSWRNYXBbZmlsZW5hbWVdLFxuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGFkZHMgYWxsIHVzZWQgaW50ZWdyYXRpb25zIHRvIHRoZSBTREsgaW5mbyBpbiB0aGUgZXZlbnQuXG4gKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IHRoYXQgd2lsbCBiZSBmaWxsZWQgd2l0aCBhbGwgaW50ZWdyYXRpb25zLlxuICovXG5mdW5jdGlvbiBhcHBseUludGVncmF0aW9uc01ldGFkYXRhKGV2ZW50LCBpbnRlZ3JhdGlvbk5hbWVzKSB7XG4gIGlmIChpbnRlZ3JhdGlvbk5hbWVzLmxlbmd0aCA+IDApIHtcbiAgICBldmVudC5zZGsgPSBldmVudC5zZGsgfHwge307XG4gICAgZXZlbnQuc2RrLmludGVncmF0aW9ucyA9IFsuLi4oZXZlbnQuc2RrLmludGVncmF0aW9ucyB8fCBbXSksIC4uLmludGVncmF0aW9uTmFtZXNdO1xuICB9XG59XG5cbi8qKlxuICogQXBwbGllcyBgbm9ybWFsaXplYCBmdW5jdGlvbiBvbiBuZWNlc3NhcnkgYEV2ZW50YCBhdHRyaWJ1dGVzIHRvIG1ha2UgdGhlbSBzYWZlIGZvciBzZXJpYWxpemF0aW9uLlxuICogTm9ybWFsaXplZCBrZXlzOlxuICogLSBgYnJlYWRjcnVtYnMuZGF0YWBcbiAqIC0gYHVzZXJgXG4gKiAtIGBjb250ZXh0c2BcbiAqIC0gYGV4dHJhYFxuICogQHBhcmFtIGV2ZW50IEV2ZW50XG4gKiBAcmV0dXJucyBOb3JtYWxpemVkIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50KGV2ZW50LCBkZXB0aCwgbWF4QnJlYWR0aCkge1xuICBpZiAoIWV2ZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBub3JtYWxpemVkID0ge1xuICAgIC4uLmV2ZW50LFxuICAgIC4uLihldmVudC5icmVhZGNydW1icyAmJiB7XG4gICAgICBicmVhZGNydW1iczogZXZlbnQuYnJlYWRjcnVtYnMubWFwKGIgPT4gKHtcbiAgICAgICAgLi4uYixcbiAgICAgICAgLi4uKGIuZGF0YSAmJiB7XG4gICAgICAgICAgZGF0YTogbm9ybWFsaXplKGIuZGF0YSwgZGVwdGgsIG1heEJyZWFkdGgpLFxuICAgICAgICB9KSxcbiAgICAgIH0pKSxcbiAgICB9KSxcbiAgICAuLi4oZXZlbnQudXNlciAmJiB7XG4gICAgICB1c2VyOiBub3JtYWxpemUoZXZlbnQudXNlciwgZGVwdGgsIG1heEJyZWFkdGgpLFxuICAgIH0pLFxuICAgIC4uLihldmVudC5jb250ZXh0cyAmJiB7XG4gICAgICBjb250ZXh0czogbm9ybWFsaXplKGV2ZW50LmNvbnRleHRzLCBkZXB0aCwgbWF4QnJlYWR0aCksXG4gICAgfSksXG4gICAgLi4uKGV2ZW50LmV4dHJhICYmIHtcbiAgICAgIGV4dHJhOiBub3JtYWxpemUoZXZlbnQuZXh0cmEsIGRlcHRoLCBtYXhCcmVhZHRoKSxcbiAgICB9KSxcbiAgfTtcblxuICAvLyBldmVudC5jb250ZXh0cy50cmFjZSBzdG9yZXMgaW5mb3JtYXRpb24gYWJvdXQgYSBUcmFuc2FjdGlvbi4gU2ltaWxhcmx5LFxuICAvLyBldmVudC5zcGFuc1tdIHN0b3JlcyBpbmZvcm1hdGlvbiBhYm91dCBjaGlsZCBTcGFucy4gR2l2ZW4gdGhhdCBhXG4gIC8vIFRyYW5zYWN0aW9uIGlzIGNvbmNlcHR1YWxseSBhIFNwYW4sIG5vcm1hbGl6YXRpb24gc2hvdWxkIGFwcGx5IHRvIGJvdGhcbiAgLy8gVHJhbnNhY3Rpb25zIGFuZCBTcGFucyBjb25zaXN0ZW50bHkuXG4gIC8vIEZvciBub3cgdGhlIGRlY2lzaW9uIGlzIHRvIHNraXAgbm9ybWFsaXphdGlvbiBvZiBUcmFuc2FjdGlvbnMgYW5kIFNwYW5zLFxuICAvLyBzbyB0aGlzIGJsb2NrIG92ZXJ3cml0ZXMgdGhlIG5vcm1hbGl6ZWQgZXZlbnQgdG8gYWRkIGJhY2sgdGhlIG9yaWdpbmFsXG4gIC8vIFRyYW5zYWN0aW9uIGluZm9ybWF0aW9uIHByaW9yIHRvIG5vcm1hbGl6YXRpb24uXG4gIGlmIChldmVudC5jb250ZXh0cyAmJiBldmVudC5jb250ZXh0cy50cmFjZSAmJiBub3JtYWxpemVkLmNvbnRleHRzKSB7XG4gICAgbm9ybWFsaXplZC5jb250ZXh0cy50cmFjZSA9IGV2ZW50LmNvbnRleHRzLnRyYWNlO1xuXG4gICAgLy8gZXZlbnQuY29udGV4dHMudHJhY2UuZGF0YSBtYXkgY29udGFpbiBjaXJjdWxhci9kYW5nZXJvdXMgZGF0YSBzbyB3ZSBuZWVkIHRvIG5vcm1hbGl6ZSBpdFxuICAgIGlmIChldmVudC5jb250ZXh0cy50cmFjZS5kYXRhKSB7XG4gICAgICBub3JtYWxpemVkLmNvbnRleHRzLnRyYWNlLmRhdGEgPSBub3JtYWxpemUoZXZlbnQuY29udGV4dHMudHJhY2UuZGF0YSwgZGVwdGgsIG1heEJyZWFkdGgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGV2ZW50LnNwYW5zW10uZGF0YSBtYXkgY29udGFpbiBjaXJjdWxhci9kYW5nZXJvdXMgZGF0YSBzbyB3ZSBuZWVkIHRvIG5vcm1hbGl6ZSBpdFxuICBpZiAoZXZlbnQuc3BhbnMpIHtcbiAgICBub3JtYWxpemVkLnNwYW5zID0gZXZlbnQuc3BhbnMubWFwKHNwYW4gPT4ge1xuICAgICAgY29uc3QgZGF0YSA9IHNwYW5Ub0pTT04oc3BhbikuZGF0YTtcblxuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIGJpdCB3ZWlyZCwgYXMgd2UgZ2VuZXJhbGx5IGhhdmUgYFNwYW5gIGluc3RhbmNlcyBoZXJlLCBidXQgdG8gYmUgc2FmZSB3ZSBkbyBub3QgYXNzdW1lIHNvXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICAgICAgICBzcGFuLmRhdGEgPSBub3JtYWxpemUoZGF0YSwgZGVwdGgsIG1heEJyZWFkdGgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3BhbjtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBub3JtYWxpemVkO1xufVxuXG5mdW5jdGlvbiBnZXRGaW5hbFNjb3BlKHNjb3BlLCBjYXB0dXJlQ29udGV4dCkge1xuICBpZiAoIWNhcHR1cmVDb250ZXh0KSB7XG4gICAgcmV0dXJuIHNjb3BlO1xuICB9XG5cbiAgY29uc3QgZmluYWxTY29wZSA9IHNjb3BlID8gc2NvcGUuY2xvbmUoKSA6IG5ldyBTY29wZSgpO1xuICBmaW5hbFNjb3BlLnVwZGF0ZShjYXB0dXJlQ29udGV4dCk7XG4gIHJldHVybiBmaW5hbFNjb3BlO1xufVxuXG4vKipcbiAqIFBhcnNlIGVpdGhlciBhbiBgRXZlbnRIaW50YCBkaXJlY3RseSwgb3IgY29udmVydCBhIGBDYXB0dXJlQ29udGV4dGAgdG8gYW4gYEV2ZW50SGludGAuXG4gKiBUaGlzIGlzIHVzZWQgdG8gYWxsb3cgdG8gdXBkYXRlIG1ldGhvZCBzaWduYXR1cmVzIHRoYXQgdXNlZCB0byBhY2NlcHQgYSBgQ2FwdHVyZUNvbnRleHRgIGJ1dCBzaG91bGQgbm93IGFjY2VwdCBhbiBgRXZlbnRIaW50YC5cbiAqL1xuZnVuY3Rpb24gcGFyc2VFdmVudEhpbnRPckNhcHR1cmVDb250ZXh0KFxuICBoaW50LFxuKSB7XG4gIGlmICghaGludCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvLyBJZiB5b3UgcGFzcyBhIFNjb3BlIG9yIGAoKSA9PiBTY29wZWAgYXMgQ2FwdHVyZUNvbnRleHQsIHdlIGp1c3QgcmV0dXJuIHRoaXMgYXMgY2FwdHVyZUNvbnRleHRcbiAgaWYgKGhpbnRJc1Njb3BlT3JGdW5jdGlvbihoaW50KSkge1xuICAgIHJldHVybiB7IGNhcHR1cmVDb250ZXh0OiBoaW50IH07XG4gIH1cblxuICBpZiAoaGludElzU2NvcGVDb250ZXh0KGhpbnQpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhcHR1cmVDb250ZXh0OiBoaW50LFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gaGludDtcbn1cblxuZnVuY3Rpb24gaGludElzU2NvcGVPckZ1bmN0aW9uKFxuICBoaW50LFxuKSB7XG4gIHJldHVybiBoaW50IGluc3RhbmNlb2YgU2NvcGUgfHwgdHlwZW9mIGhpbnQgPT09ICdmdW5jdGlvbic7XG59XG5cbmNvbnN0IGNhcHR1cmVDb250ZXh0S2V5cyA9IFtcbiAgJ3VzZXInLFxuICAnbGV2ZWwnLFxuICAnZXh0cmEnLFxuICAnY29udGV4dHMnLFxuICAndGFncycsXG4gICdmaW5nZXJwcmludCcsXG4gICdyZXF1ZXN0U2Vzc2lvbicsXG4gICdwcm9wYWdhdGlvbkNvbnRleHQnLFxuXSA7XG5cbmZ1bmN0aW9uIGhpbnRJc1Njb3BlQ29udGV4dChoaW50KSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhoaW50KS5zb21lKGtleSA9PiBjYXB0dXJlQ29udGV4dEtleXMuaW5jbHVkZXMoa2V5ICkpO1xufVxuXG5leHBvcnQgeyBhcHBseURlYnVnSWRzLCBhcHBseURlYnVnTWV0YSwgcGFyc2VFdmVudEhpbnRPckNhcHR1cmVDb250ZXh0LCBwcmVwYXJlRXZlbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByZXBhcmVFdmVudC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJ1dWlkNCIsImRhdGVUaW1lc3RhbXBJblNlY29uZHMiLCJhZGRFeGNlcHRpb25NZWNoYW5pc20iLCJ0cnVuY2F0ZSIsIkdMT0JBTF9PQkoiLCJub3JtYWxpemUiLCJERUZBVUxUX0VOVklST05NRU5UIiwiZ2V0R2xvYmFsRXZlbnRQcm9jZXNzb3JzIiwibm90aWZ5RXZlbnRQcm9jZXNzb3JzIiwiZ2V0R2xvYmFsU2NvcGUiLCJTY29wZSIsIm1lcmdlU2NvcGVEYXRhIiwiYXBwbHlTY29wZURhdGFUb0V2ZW50Iiwic3BhblRvSlNPTiIsInByZXBhcmVFdmVudCIsIm9wdGlvbnMiLCJldmVudCIsImhpbnQiLCJzY29wZSIsImNsaWVudCIsImlzb2xhdGlvblNjb3BlIiwibm9ybWFsaXplRGVwdGgiLCJub3JtYWxpemVNYXhCcmVhZHRoIiwicHJlcGFyZWQiLCJldmVudF9pZCIsInRpbWVzdGFtcCIsImludGVncmF0aW9ucyIsIm1hcCIsImkiLCJuYW1lIiwiYXBwbHlDbGllbnRPcHRpb25zIiwiYXBwbHlJbnRlZ3JhdGlvbnNNZXRhZGF0YSIsInR5cGUiLCJ1bmRlZmluZWQiLCJhcHBseURlYnVnSWRzIiwic3RhY2tQYXJzZXIiLCJmaW5hbFNjb3BlIiwiZ2V0RmluYWxTY29wZSIsImNhcHR1cmVDb250ZXh0IiwibWVjaGFuaXNtIiwiY2xpZW50RXZlbnRQcm9jZXNzb3JzIiwiZ2V0RXZlbnRQcm9jZXNzb3JzIiwiZGF0YSIsImdldFNjb3BlRGF0YSIsImlzb2xhdGlvbkRhdGEiLCJmaW5hbFNjb3BlRGF0YSIsImF0dGFjaG1lbnRzIiwibGVuZ3RoIiwiZXZlbnRQcm9jZXNzb3JzIiwicmVzdWx0IiwidGhlbiIsImV2dCIsImFwcGx5RGVidWdNZXRhIiwibm9ybWFsaXplRXZlbnQiLCJlbnZpcm9ubWVudCIsInJlbGVhc2UiLCJkaXN0IiwibWF4VmFsdWVMZW5ndGgiLCJtZXNzYWdlIiwiZXhjZXB0aW9uIiwidmFsdWVzIiwidmFsdWUiLCJyZXF1ZXN0IiwidXJsIiwiZGVidWdJZFN0YWNrUGFyc2VyQ2FjaGUiLCJXZWFrTWFwIiwiZGVidWdJZE1hcCIsIl9zZW50cnlEZWJ1Z0lkcyIsImRlYnVnSWRTdGFja0ZyYW1lc0NhY2hlIiwiY2FjaGVkRGVidWdJZFN0YWNrRnJhbWVDYWNoZSIsImdldCIsIk1hcCIsInNldCIsImZpbGVuYW1lRGVidWdJZE1hcCIsIk9iamVjdCIsImtleXMiLCJyZWR1Y2UiLCJhY2MiLCJkZWJ1Z0lkU3RhY2tUcmFjZSIsInBhcnNlZFN0YWNrIiwiY2FjaGVkUGFyc2VkU3RhY2siLCJzdGFja0ZyYW1lIiwiZmlsZW5hbWUiLCJmb3JFYWNoIiwic3RhY2t0cmFjZSIsImZyYW1lcyIsImZyYW1lIiwiZGVidWdfaWQiLCJlIiwiYWJzX3BhdGgiLCJkZWJ1Z19tZXRhIiwiaW1hZ2VzIiwicHVzaCIsImNvZGVfZmlsZSIsImludGVncmF0aW9uTmFtZXMiLCJzZGsiLCJkZXB0aCIsIm1heEJyZWFkdGgiLCJub3JtYWxpemVkIiwiYnJlYWRjcnVtYnMiLCJiIiwidXNlciIsImNvbnRleHRzIiwiZXh0cmEiLCJ0cmFjZSIsInNwYW5zIiwic3BhbiIsImNsb25lIiwidXBkYXRlIiwicGFyc2VFdmVudEhpbnRPckNhcHR1cmVDb250ZXh0IiwiaGludElzU2NvcGVPckZ1bmN0aW9uIiwiaGludElzU2NvcGVDb250ZXh0IiwiY2FwdHVyZUNvbnRleHRLZXlzIiwic29tZSIsImtleSIsImluY2x1ZGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/core/esm/utils/prepareEvent.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sentry/core/esm/utils/spanUtils.js":
/*!**********************************************************!*\
  !*** ./node_modules/@sentry/core/esm/utils/spanUtils.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TRACE_FLAG_NONE: () => (/* binding */ TRACE_FLAG_NONE),\n/* harmony export */   TRACE_FLAG_SAMPLED: () => (/* binding */ TRACE_FLAG_SAMPLED),\n/* harmony export */   spanIsSampled: () => (/* binding */ spanIsSampled),\n/* harmony export */   spanTimeInputToSeconds: () => (/* binding */ spanTimeInputToSeconds),\n/* harmony export */   spanToJSON: () => (/* binding */ spanToJSON),\n/* harmony export */   spanToTraceContext: () => (/* binding */ spanToTraceContext),\n/* harmony export */   spanToTraceHeader: () => (/* binding */ spanToTraceHeader)\n/* harmony export */ });\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sentry/utils */ \"(ssr)/./node_modules/@sentry/utils/esm/object.js\");\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @sentry/utils */ \"(ssr)/./node_modules/@sentry/utils/esm/tracing.js\");\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sentry/utils */ \"(ssr)/./node_modules/@sentry/utils/esm/time.js\");\n\n// These are aligned with OpenTelemetry trace flags\nconst TRACE_FLAG_NONE = 0x0;\nconst TRACE_FLAG_SAMPLED = 0x1;\n/**\n * Convert a span to a trace context, which can be sent as the `trace` context in an event.\n */ function spanToTraceContext(span) {\n    const { spanId: span_id, traceId: trace_id } = span.spanContext();\n    const { data, op, parent_span_id, status, tags, origin } = spanToJSON(span);\n    return (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_0__.dropUndefinedKeys)({\n        data,\n        op,\n        parent_span_id,\n        span_id,\n        status,\n        tags,\n        trace_id,\n        origin\n    });\n}\n/**\n * Convert a Span to a Sentry trace header.\n */ function spanToTraceHeader(span) {\n    const { traceId, spanId } = span.spanContext();\n    const sampled = spanIsSampled(span);\n    return (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_1__.generateSentryTraceHeader)(traceId, spanId, sampled);\n}\n/**\n * Convert a span time input intp a timestamp in seconds.\n */ function spanTimeInputToSeconds(input) {\n    if (typeof input === \"number\") {\n        return ensureTimestampInSeconds(input);\n    }\n    if (Array.isArray(input)) {\n        // See {@link HrTime} for the array-based time format\n        return input[0] + input[1] / 1e9;\n    }\n    if (input instanceof Date) {\n        return ensureTimestampInSeconds(input.getTime());\n    }\n    return (0,_sentry_utils__WEBPACK_IMPORTED_MODULE_2__.timestampInSeconds)();\n}\n/**\n * Converts a timestamp to second, if it was in milliseconds, or keeps it as second.\n */ function ensureTimestampInSeconds(timestamp) {\n    const isMs = timestamp > 9999999999;\n    return isMs ? timestamp / 1000 : timestamp;\n}\n/**\n * Convert a span to a JSON representation.\n * Note that all fields returned here are optional and need to be guarded against.\n *\n * Note: Because of this, we currently have a circular type dependency (which we opted out of in package.json).\n * This is not avoidable as we need `spanToJSON` in `spanUtils.ts`, which in turn is needed by `span.ts` for backwards compatibility.\n * And `spanToJSON` needs the Span class from `span.ts` to check here.\n * TODO v8: When we remove the deprecated stuff from `span.ts`, we can remove the circular dependency again.\n */ function spanToJSON(span) {\n    if (spanIsSpanClass(span)) {\n        return span.getSpanJSON();\n    }\n    // Fallback: We also check for `.toJSON()` here...\n    // eslint-disable-next-line deprecation/deprecation\n    if (typeof span.toJSON === \"function\") {\n        // eslint-disable-next-line deprecation/deprecation\n        return span.toJSON();\n    }\n    return {};\n}\n/**\n * Sadly, due to circular dependency checks we cannot actually import the Span class here and check for instanceof.\n * :( So instead we approximate this by checking if it has the `getSpanJSON` method.\n */ function spanIsSpanClass(span) {\n    return typeof span.getSpanJSON === \"function\";\n}\n/**\n * Returns true if a span is sampled.\n * In most cases, you should just use `span.isRecording()` instead.\n * However, this has a slightly different semantic, as it also returns false if the span is finished.\n * So in the case where this distinction is important, use this method.\n */ function spanIsSampled(span) {\n    // We align our trace flags with the ones OpenTelemetry use\n    // So we also check for sampled the same way they do.\n    const { traceFlags } = span.spanContext();\n    // eslint-disable-next-line no-bitwise\n    return Boolean(traceFlags & TRACE_FLAG_SAMPLED);\n}\n //# sourceMappingURL=spanUtils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2VzbS91dGlscy9zcGFuVXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFpRztBQUVqRyxtREFBbUQ7QUFDbkQsTUFBTUcsa0JBQWtCO0FBQ3hCLE1BQU1DLHFCQUFxQjtBQUUzQjs7Q0FFQyxHQUNELFNBQVNDLG1CQUFtQkMsSUFBSTtJQUM5QixNQUFNLEVBQUVDLFFBQVFDLE9BQU8sRUFBRUMsU0FBU0MsUUFBUSxFQUFFLEdBQUdKLEtBQUtLLFdBQVc7SUFDL0QsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLEVBQUUsRUFBRUMsY0FBYyxFQUFFQyxNQUFNLEVBQUVDLElBQUksRUFBRUMsTUFBTSxFQUFFLEdBQUdDLFdBQVdaO0lBRXRFLE9BQU9OLGdFQUFpQkEsQ0FBQztRQUN2Qlk7UUFDQUM7UUFDQUM7UUFDQU47UUFDQU87UUFDQUM7UUFDQU47UUFDQU87SUFDRjtBQUNGO0FBRUE7O0NBRUMsR0FDRCxTQUFTRSxrQkFBa0JiLElBQUk7SUFDN0IsTUFBTSxFQUFFRyxPQUFPLEVBQUVGLE1BQU0sRUFBRSxHQUFHRCxLQUFLSyxXQUFXO0lBQzVDLE1BQU1TLFVBQVVDLGNBQWNmO0lBQzlCLE9BQU9MLHdFQUF5QkEsQ0FBQ1EsU0FBU0YsUUFBUWE7QUFDcEQ7QUFFQTs7Q0FFQyxHQUNELFNBQVNFLHVCQUF1QkMsS0FBSztJQUNuQyxJQUFJLE9BQU9BLFVBQVUsVUFBVTtRQUM3QixPQUFPQyx5QkFBeUJEO0lBQ2xDO0lBRUEsSUFBSUUsTUFBTUMsT0FBTyxDQUFDSCxRQUFRO1FBQ3hCLHFEQUFxRDtRQUNyRCxPQUFPQSxLQUFLLENBQUMsRUFBRSxHQUFHQSxLQUFLLENBQUMsRUFBRSxHQUFHO0lBQy9CO0lBRUEsSUFBSUEsaUJBQWlCSSxNQUFNO1FBQ3pCLE9BQU9ILHlCQUF5QkQsTUFBTUssT0FBTztJQUMvQztJQUVBLE9BQU8xQixpRUFBa0JBO0FBQzNCO0FBRUE7O0NBRUMsR0FDRCxTQUFTc0IseUJBQXlCSyxTQUFTO0lBQ3pDLE1BQU1DLE9BQU9ELFlBQVk7SUFDekIsT0FBT0MsT0FBT0QsWUFBWSxPQUFPQTtBQUNuQztBQUVBOzs7Ozs7OztDQVFDLEdBQ0QsU0FBU1gsV0FBV1osSUFBSTtJQUN0QixJQUFJeUIsZ0JBQWdCekIsT0FBTztRQUN6QixPQUFPQSxLQUFLMEIsV0FBVztJQUN6QjtJQUVBLGtEQUFrRDtJQUNsRCxtREFBbUQ7SUFDbkQsSUFBSSxPQUFPMUIsS0FBSzJCLE1BQU0sS0FBSyxZQUFZO1FBQ3JDLG1EQUFtRDtRQUNuRCxPQUFPM0IsS0FBSzJCLE1BQU07SUFDcEI7SUFFQSxPQUFPLENBQUM7QUFDVjtBQUVBOzs7Q0FHQyxHQUNELFNBQVNGLGdCQUFnQnpCLElBQUk7SUFDM0IsT0FBTyxPQUFPLEtBQVEwQixXQUFXLEtBQUs7QUFDeEM7QUFFQTs7Ozs7Q0FLQyxHQUNELFNBQVNYLGNBQWNmLElBQUk7SUFDekIsMkRBQTJEO0lBQzNELHFEQUFxRDtJQUNyRCxNQUFNLEVBQUU0QixVQUFVLEVBQUUsR0FBRzVCLEtBQUtLLFdBQVc7SUFDdkMsc0NBQXNDO0lBQ3RDLE9BQU93QixRQUFRRCxhQUFhOUI7QUFDOUI7QUFFeUksQ0FDekkscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb2JyYWxpbmstd2ViLy4vbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9lc20vdXRpbHMvc3BhblV0aWxzLmpzPzYwMGIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZHJvcFVuZGVmaW5lZEtleXMsIGdlbmVyYXRlU2VudHJ5VHJhY2VIZWFkZXIsIHRpbWVzdGFtcEluU2Vjb25kcyB9IGZyb20gJ0BzZW50cnkvdXRpbHMnO1xuXG4vLyBUaGVzZSBhcmUgYWxpZ25lZCB3aXRoIE9wZW5UZWxlbWV0cnkgdHJhY2UgZmxhZ3NcbmNvbnN0IFRSQUNFX0ZMQUdfTk9ORSA9IDB4MDtcbmNvbnN0IFRSQUNFX0ZMQUdfU0FNUExFRCA9IDB4MTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgc3BhbiB0byBhIHRyYWNlIGNvbnRleHQsIHdoaWNoIGNhbiBiZSBzZW50IGFzIHRoZSBgdHJhY2VgIGNvbnRleHQgaW4gYW4gZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIHNwYW5Ub1RyYWNlQ29udGV4dChzcGFuKSB7XG4gIGNvbnN0IHsgc3BhbklkOiBzcGFuX2lkLCB0cmFjZUlkOiB0cmFjZV9pZCB9ID0gc3Bhbi5zcGFuQ29udGV4dCgpO1xuICBjb25zdCB7IGRhdGEsIG9wLCBwYXJlbnRfc3Bhbl9pZCwgc3RhdHVzLCB0YWdzLCBvcmlnaW4gfSA9IHNwYW5Ub0pTT04oc3Bhbik7XG5cbiAgcmV0dXJuIGRyb3BVbmRlZmluZWRLZXlzKHtcbiAgICBkYXRhLFxuICAgIG9wLFxuICAgIHBhcmVudF9zcGFuX2lkLFxuICAgIHNwYW5faWQsXG4gICAgc3RhdHVzLFxuICAgIHRhZ3MsXG4gICAgdHJhY2VfaWQsXG4gICAgb3JpZ2luLFxuICB9KTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgU3BhbiB0byBhIFNlbnRyeSB0cmFjZSBoZWFkZXIuXG4gKi9cbmZ1bmN0aW9uIHNwYW5Ub1RyYWNlSGVhZGVyKHNwYW4pIHtcbiAgY29uc3QgeyB0cmFjZUlkLCBzcGFuSWQgfSA9IHNwYW4uc3BhbkNvbnRleHQoKTtcbiAgY29uc3Qgc2FtcGxlZCA9IHNwYW5Jc1NhbXBsZWQoc3Bhbik7XG4gIHJldHVybiBnZW5lcmF0ZVNlbnRyeVRyYWNlSGVhZGVyKHRyYWNlSWQsIHNwYW5JZCwgc2FtcGxlZCk7XG59XG5cbi8qKlxuICogQ29udmVydCBhIHNwYW4gdGltZSBpbnB1dCBpbnRwIGEgdGltZXN0YW1wIGluIHNlY29uZHMuXG4gKi9cbmZ1bmN0aW9uIHNwYW5UaW1lSW5wdXRUb1NlY29uZHMoaW5wdXQpIHtcbiAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gZW5zdXJlVGltZXN0YW1wSW5TZWNvbmRzKGlucHV0KTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgIC8vIFNlZSB7QGxpbmsgSHJUaW1lfSBmb3IgdGhlIGFycmF5LWJhc2VkIHRpbWUgZm9ybWF0XG4gICAgcmV0dXJuIGlucHV0WzBdICsgaW5wdXRbMV0gLyAxZTk7XG4gIH1cblxuICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuIGVuc3VyZVRpbWVzdGFtcEluU2Vjb25kcyhpbnB1dC5nZXRUaW1lKCkpO1xuICB9XG5cbiAgcmV0dXJuIHRpbWVzdGFtcEluU2Vjb25kcygpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgdGltZXN0YW1wIHRvIHNlY29uZCwgaWYgaXQgd2FzIGluIG1pbGxpc2Vjb25kcywgb3Iga2VlcHMgaXQgYXMgc2Vjb25kLlxuICovXG5mdW5jdGlvbiBlbnN1cmVUaW1lc3RhbXBJblNlY29uZHModGltZXN0YW1wKSB7XG4gIGNvbnN0IGlzTXMgPSB0aW1lc3RhbXAgPiA5OTk5OTk5OTk5O1xuICByZXR1cm4gaXNNcyA/IHRpbWVzdGFtcCAvIDEwMDAgOiB0aW1lc3RhbXA7XG59XG5cbi8qKlxuICogQ29udmVydCBhIHNwYW4gdG8gYSBKU09OIHJlcHJlc2VudGF0aW9uLlxuICogTm90ZSB0aGF0IGFsbCBmaWVsZHMgcmV0dXJuZWQgaGVyZSBhcmUgb3B0aW9uYWwgYW5kIG5lZWQgdG8gYmUgZ3VhcmRlZCBhZ2FpbnN0LlxuICpcbiAqIE5vdGU6IEJlY2F1c2Ugb2YgdGhpcywgd2UgY3VycmVudGx5IGhhdmUgYSBjaXJjdWxhciB0eXBlIGRlcGVuZGVuY3kgKHdoaWNoIHdlIG9wdGVkIG91dCBvZiBpbiBwYWNrYWdlLmpzb24pLlxuICogVGhpcyBpcyBub3QgYXZvaWRhYmxlIGFzIHdlIG5lZWQgYHNwYW5Ub0pTT05gIGluIGBzcGFuVXRpbHMudHNgLCB3aGljaCBpbiB0dXJuIGlzIG5lZWRlZCBieSBgc3Bhbi50c2AgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICogQW5kIGBzcGFuVG9KU09OYCBuZWVkcyB0aGUgU3BhbiBjbGFzcyBmcm9tIGBzcGFuLnRzYCB0byBjaGVjayBoZXJlLlxuICogVE9ETyB2ODogV2hlbiB3ZSByZW1vdmUgdGhlIGRlcHJlY2F0ZWQgc3R1ZmYgZnJvbSBgc3Bhbi50c2AsIHdlIGNhbiByZW1vdmUgdGhlIGNpcmN1bGFyIGRlcGVuZGVuY3kgYWdhaW4uXG4gKi9cbmZ1bmN0aW9uIHNwYW5Ub0pTT04oc3Bhbikge1xuICBpZiAoc3BhbklzU3BhbkNsYXNzKHNwYW4pKSB7XG4gICAgcmV0dXJuIHNwYW4uZ2V0U3BhbkpTT04oKTtcbiAgfVxuXG4gIC8vIEZhbGxiYWNrOiBXZSBhbHNvIGNoZWNrIGZvciBgLnRvSlNPTigpYCBoZXJlLi4uXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICBpZiAodHlwZW9mIHNwYW4udG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gICAgcmV0dXJuIHNwYW4udG9KU09OKCk7XG4gIH1cblxuICByZXR1cm4ge307XG59XG5cbi8qKlxuICogU2FkbHksIGR1ZSB0byBjaXJjdWxhciBkZXBlbmRlbmN5IGNoZWNrcyB3ZSBjYW5ub3QgYWN0dWFsbHkgaW1wb3J0IHRoZSBTcGFuIGNsYXNzIGhlcmUgYW5kIGNoZWNrIGZvciBpbnN0YW5jZW9mLlxuICogOiggU28gaW5zdGVhZCB3ZSBhcHByb3hpbWF0ZSB0aGlzIGJ5IGNoZWNraW5nIGlmIGl0IGhhcyB0aGUgYGdldFNwYW5KU09OYCBtZXRob2QuXG4gKi9cbmZ1bmN0aW9uIHNwYW5Jc1NwYW5DbGFzcyhzcGFuKSB7XG4gIHJldHVybiB0eXBlb2YgKHNwYW4gKS5nZXRTcGFuSlNPTiA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYSBzcGFuIGlzIHNhbXBsZWQuXG4gKiBJbiBtb3N0IGNhc2VzLCB5b3Ugc2hvdWxkIGp1c3QgdXNlIGBzcGFuLmlzUmVjb3JkaW5nKClgIGluc3RlYWQuXG4gKiBIb3dldmVyLCB0aGlzIGhhcyBhIHNsaWdodGx5IGRpZmZlcmVudCBzZW1hbnRpYywgYXMgaXQgYWxzbyByZXR1cm5zIGZhbHNlIGlmIHRoZSBzcGFuIGlzIGZpbmlzaGVkLlxuICogU28gaW4gdGhlIGNhc2Ugd2hlcmUgdGhpcyBkaXN0aW5jdGlvbiBpcyBpbXBvcnRhbnQsIHVzZSB0aGlzIG1ldGhvZC5cbiAqL1xuZnVuY3Rpb24gc3BhbklzU2FtcGxlZChzcGFuKSB7XG4gIC8vIFdlIGFsaWduIG91ciB0cmFjZSBmbGFncyB3aXRoIHRoZSBvbmVzIE9wZW5UZWxlbWV0cnkgdXNlXG4gIC8vIFNvIHdlIGFsc28gY2hlY2sgZm9yIHNhbXBsZWQgdGhlIHNhbWUgd2F5IHRoZXkgZG8uXG4gIGNvbnN0IHsgdHJhY2VGbGFncyB9ID0gc3Bhbi5zcGFuQ29udGV4dCgpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICByZXR1cm4gQm9vbGVhbih0cmFjZUZsYWdzICYgVFJBQ0VfRkxBR19TQU1QTEVEKTtcbn1cblxuZXhwb3J0IHsgVFJBQ0VfRkxBR19OT05FLCBUUkFDRV9GTEFHX1NBTVBMRUQsIHNwYW5Jc1NhbXBsZWQsIHNwYW5UaW1lSW5wdXRUb1NlY29uZHMsIHNwYW5Ub0pTT04sIHNwYW5Ub1RyYWNlQ29udGV4dCwgc3BhblRvVHJhY2VIZWFkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNwYW5VdGlscy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJkcm9wVW5kZWZpbmVkS2V5cyIsImdlbmVyYXRlU2VudHJ5VHJhY2VIZWFkZXIiLCJ0aW1lc3RhbXBJblNlY29uZHMiLCJUUkFDRV9GTEFHX05PTkUiLCJUUkFDRV9GTEFHX1NBTVBMRUQiLCJzcGFuVG9UcmFjZUNvbnRleHQiLCJzcGFuIiwic3BhbklkIiwic3Bhbl9pZCIsInRyYWNlSWQiLCJ0cmFjZV9pZCIsInNwYW5Db250ZXh0IiwiZGF0YSIsIm9wIiwicGFyZW50X3NwYW5faWQiLCJzdGF0dXMiLCJ0YWdzIiwib3JpZ2luIiwic3BhblRvSlNPTiIsInNwYW5Ub1RyYWNlSGVhZGVyIiwic2FtcGxlZCIsInNwYW5Jc1NhbXBsZWQiLCJzcGFuVGltZUlucHV0VG9TZWNvbmRzIiwiaW5wdXQiLCJlbnN1cmVUaW1lc3RhbXBJblNlY29uZHMiLCJBcnJheSIsImlzQXJyYXkiLCJEYXRlIiwiZ2V0VGltZSIsInRpbWVzdGFtcCIsImlzTXMiLCJzcGFuSXNTcGFuQ2xhc3MiLCJnZXRTcGFuSlNPTiIsInRvSlNPTiIsInRyYWNlRmxhZ3MiLCJCb29sZWFuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/core/esm/utils/spanUtils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sentry/core/esm/version.js":
/*!**************************************************!*\
  !*** ./node_modules/@sentry/core/esm/version.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SDK_VERSION: () => (/* binding */ SDK_VERSION)\n/* harmony export */ });\nconst SDK_VERSION = \"7.104.0\";\n //# sourceMappingURL=version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2VzbS92ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxNQUFNQSxjQUFjO0FBRUcsQ0FDdkIsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb2JyYWxpbmstd2ViLy4vbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9lc20vdmVyc2lvbi5qcz9jNDExIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFNES19WRVJTSU9OID0gJzcuMTA0LjAnO1xuXG5leHBvcnQgeyBTREtfVkVSU0lPTiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyc2lvbi5qcy5tYXBcbiJdLCJuYW1lcyI6WyJTREtfVkVSU0lPTiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/core/esm/version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sentry/utils/esm/baggage.js":
/*!***************************************************!*\
  !*** ./node_modules/@sentry/utils/esm/baggage.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BAGGAGE_HEADER_NAME: () => (/* binding */ BAGGAGE_HEADER_NAME),\n/* harmony export */   MAX_BAGGAGE_STRING_LENGTH: () => (/* binding */ MAX_BAGGAGE_STRING_LENGTH),\n/* harmony export */   SENTRY_BAGGAGE_KEY_PREFIX: () => (/* binding */ SENTRY_BAGGAGE_KEY_PREFIX),\n/* harmony export */   SENTRY_BAGGAGE_KEY_PREFIX_REGEX: () => (/* binding */ SENTRY_BAGGAGE_KEY_PREFIX_REGEX),\n/* harmony export */   baggageHeaderToDynamicSamplingContext: () => (/* binding */ baggageHeaderToDynamicSamplingContext),\n/* harmony export */   dynamicSamplingContextToSentryBaggageHeader: () => (/* binding */ dynamicSamplingContextToSentryBaggageHeader)\n/* harmony export */ });\n/* harmony import */ var _debug_build_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./debug-build.js */ \"(ssr)/./node_modules/@sentry/utils/esm/debug-build.js\");\n/* harmony import */ var _is_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is.js */ \"(ssr)/./node_modules/@sentry/utils/esm/is.js\");\n/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./logger.js */ \"(ssr)/./node_modules/@sentry/utils/esm/logger.js\");\n\n\n\nconst BAGGAGE_HEADER_NAME = \"baggage\";\nconst SENTRY_BAGGAGE_KEY_PREFIX = \"sentry-\";\nconst SENTRY_BAGGAGE_KEY_PREFIX_REGEX = /^sentry-/;\n/**\n * Max length of a serialized baggage string\n *\n * https://www.w3.org/TR/baggage/#limits\n */ const MAX_BAGGAGE_STRING_LENGTH = 8192;\n/**\n * Takes a baggage header and turns it into Dynamic Sampling Context, by extracting all the \"sentry-\" prefixed values\n * from it.\n *\n * @param baggageHeader A very bread definition of a baggage header as it might appear in various frameworks.\n * @returns The Dynamic Sampling Context that was found on `baggageHeader`, if there was any, `undefined` otherwise.\n */ function baggageHeaderToDynamicSamplingContext(// Very liberal definition of what any incoming header might look like\nbaggageHeader) {\n    if (!(0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isString)(baggageHeader) && !Array.isArray(baggageHeader)) {\n        return undefined;\n    }\n    // Intermediary object to store baggage key value pairs of incoming baggage headers on.\n    // It is later used to read Sentry-DSC-values from.\n    let baggageObject = {};\n    if (Array.isArray(baggageHeader)) {\n        // Combine all baggage headers into one object containing the baggage values so we can later read the Sentry-DSC-values from it\n        baggageObject = baggageHeader.reduce((acc, curr)=>{\n            const currBaggageObject = baggageHeaderToObject(curr);\n            for (const key of Object.keys(currBaggageObject)){\n                acc[key] = currBaggageObject[key];\n            }\n            return acc;\n        }, {});\n    } else {\n        // Return undefined if baggage header is an empty string (technically an empty baggage header is not spec conform but\n        // this is how we choose to handle it)\n        if (!baggageHeader) {\n            return undefined;\n        }\n        baggageObject = baggageHeaderToObject(baggageHeader);\n    }\n    // Read all \"sentry-\" prefixed values out of the baggage object and put it onto a dynamic sampling context object.\n    const dynamicSamplingContext = Object.entries(baggageObject).reduce((acc, [key, value])=>{\n        if (key.match(SENTRY_BAGGAGE_KEY_PREFIX_REGEX)) {\n            const nonPrefixedKey = key.slice(SENTRY_BAGGAGE_KEY_PREFIX.length);\n            acc[nonPrefixedKey] = value;\n        }\n        return acc;\n    }, {});\n    // Only return a dynamic sampling context object if there are keys in it.\n    // A keyless object means there were no sentry values on the header, which means that there is no DSC.\n    if (Object.keys(dynamicSamplingContext).length > 0) {\n        return dynamicSamplingContext;\n    } else {\n        return undefined;\n    }\n}\n/**\n * Turns a Dynamic Sampling Object into a baggage header by prefixing all the keys on the object with \"sentry-\".\n *\n * @param dynamicSamplingContext The Dynamic Sampling Context to turn into a header. For convenience and compatibility\n * with the `getDynamicSamplingContext` method on the Transaction class ,this argument can also be `undefined`. If it is\n * `undefined` the function will return `undefined`.\n * @returns a baggage header, created from `dynamicSamplingContext`, or `undefined` either if `dynamicSamplingContext`\n * was `undefined`, or if `dynamicSamplingContext` didn't contain any values.\n */ function dynamicSamplingContextToSentryBaggageHeader(// this also takes undefined for convenience and bundle size in other places\ndynamicSamplingContext) {\n    if (!dynamicSamplingContext) {\n        return undefined;\n    }\n    // Prefix all DSC keys with \"sentry-\" and put them into a new object\n    const sentryPrefixedDSC = Object.entries(dynamicSamplingContext).reduce((acc, [dscKey, dscValue])=>{\n        if (dscValue) {\n            acc[`${SENTRY_BAGGAGE_KEY_PREFIX}${dscKey}`] = dscValue;\n        }\n        return acc;\n    }, {});\n    return objectToBaggageHeader(sentryPrefixedDSC);\n}\n/**\n * Will parse a baggage header, which is a simple key-value map, into a flat object.\n *\n * @param baggageHeader The baggage header to parse.\n * @returns a flat object containing all the key-value pairs from `baggageHeader`.\n */ function baggageHeaderToObject(baggageHeader) {\n    return baggageHeader.split(\",\").map((baggageEntry)=>baggageEntry.split(\"=\").map((keyOrValue)=>decodeURIComponent(keyOrValue.trim()))).reduce((acc, [key, value])=>{\n        acc[key] = value;\n        return acc;\n    }, {});\n}\n/**\n * Turns a flat object (key-value pairs) into a baggage header, which is also just key-value pairs.\n *\n * @param object The object to turn into a baggage header.\n * @returns a baggage header string, or `undefined` if the object didn't have any values, since an empty baggage header\n * is not spec compliant.\n */ function objectToBaggageHeader(object) {\n    if (Object.keys(object).length === 0) {\n        // An empty baggage header is not spec compliant: We return undefined.\n        return undefined;\n    }\n    return Object.entries(object).reduce((baggageHeader, [objectKey, objectValue], currentIndex)=>{\n        const baggageEntry = `${encodeURIComponent(objectKey)}=${encodeURIComponent(objectValue)}`;\n        const newBaggageHeader = currentIndex === 0 ? baggageEntry : `${baggageHeader},${baggageEntry}`;\n        if (newBaggageHeader.length > MAX_BAGGAGE_STRING_LENGTH) {\n            _debug_build_js__WEBPACK_IMPORTED_MODULE_1__.DEBUG_BUILD && _logger_js__WEBPACK_IMPORTED_MODULE_2__.logger.warn(`Not adding key: ${objectKey} with val: ${objectValue} to baggage header due to exceeding baggage size limits.`);\n            return baggageHeader;\n        } else {\n            return newBaggageHeader;\n        }\n    }, \"\");\n}\n //# sourceMappingURL=baggage.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS91dGlscy9lc20vYmFnZ2FnZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBK0M7QUFDWjtBQUNFO0FBRXJDLE1BQU1HLHNCQUFzQjtBQUU1QixNQUFNQyw0QkFBNEI7QUFFbEMsTUFBTUMsa0NBQWtDO0FBRXhDOzs7O0NBSUMsR0FDRCxNQUFNQyw0QkFBNEI7QUFFbEM7Ozs7OztDQU1DLEdBQ0QsU0FBU0Msc0NBQ1Asc0VBQXNFO0FBQ3RFQyxhQUFhO0lBRWIsSUFBSSxDQUFDUCxnREFBUUEsQ0FBQ08sa0JBQWtCLENBQUNDLE1BQU1DLE9BQU8sQ0FBQ0YsZ0JBQWdCO1FBQzdELE9BQU9HO0lBQ1Q7SUFFQSx1RkFBdUY7SUFDdkYsbURBQW1EO0lBQ25ELElBQUlDLGdCQUFnQixDQUFDO0lBRXJCLElBQUlILE1BQU1DLE9BQU8sQ0FBQ0YsZ0JBQWdCO1FBQ2hDLCtIQUErSDtRQUMvSEksZ0JBQWdCSixjQUFjSyxNQUFNLENBQUMsQ0FBQ0MsS0FBS0M7WUFDekMsTUFBTUMsb0JBQW9CQyxzQkFBc0JGO1lBQ2hELEtBQUssTUFBTUcsT0FBT0MsT0FBT0MsSUFBSSxDQUFDSixtQkFBb0I7Z0JBQ2hERixHQUFHLENBQUNJLElBQUksR0FBR0YsaUJBQWlCLENBQUNFLElBQUk7WUFDbkM7WUFDQSxPQUFPSjtRQUNULEdBQUcsQ0FBQztJQUNOLE9BQU87UUFDTCxxSEFBcUg7UUFDckgsc0NBQXNDO1FBQ3RDLElBQUksQ0FBQ04sZUFBZTtZQUNsQixPQUFPRztRQUNUO1FBRUFDLGdCQUFnQkssc0JBQXNCVDtJQUN4QztJQUVBLGtIQUFrSDtJQUNsSCxNQUFNYSx5QkFBeUJGLE9BQU9HLE9BQU8sQ0FBQ1YsZUFBZUMsTUFBTSxDQUFDLENBQUNDLEtBQUssQ0FBQ0ksS0FBS0ssTUFBTTtRQUNwRixJQUFJTCxJQUFJTSxLQUFLLENBQUNuQixrQ0FBa0M7WUFDOUMsTUFBTW9CLGlCQUFpQlAsSUFBSVEsS0FBSyxDQUFDdEIsMEJBQTBCdUIsTUFBTTtZQUNqRWIsR0FBRyxDQUFDVyxlQUFlLEdBQUdGO1FBQ3hCO1FBQ0EsT0FBT1Q7SUFDVCxHQUFHLENBQUM7SUFFSix5RUFBeUU7SUFDekUsc0dBQXNHO0lBQ3RHLElBQUlLLE9BQU9DLElBQUksQ0FBQ0Msd0JBQXdCTSxNQUFNLEdBQUcsR0FBRztRQUNsRCxPQUFPTjtJQUNULE9BQU87UUFDTCxPQUFPVjtJQUNUO0FBQ0Y7QUFFQTs7Ozs7Ozs7Q0FRQyxHQUNELFNBQVNpQiw0Q0FDUCw0RUFBNEU7QUFDNUVQLHNCQUFzQjtJQUV0QixJQUFJLENBQUNBLHdCQUF3QjtRQUMzQixPQUFPVjtJQUNUO0lBRUEsb0VBQW9FO0lBQ3BFLE1BQU1rQixvQkFBb0JWLE9BQU9HLE9BQU8sQ0FBQ0Qsd0JBQXdCUixNQUFNLENBQ3JFLENBQUNDLEtBQUssQ0FBQ2dCLFFBQVFDLFNBQVM7UUFDdEIsSUFBSUEsVUFBVTtZQUNaakIsR0FBRyxDQUFDLENBQUMsRUFBRVYsMEJBQTBCLEVBQUUwQixPQUFPLENBQUMsQ0FBQyxHQUFHQztRQUNqRDtRQUNBLE9BQU9qQjtJQUNULEdBQ0EsQ0FBQztJQUdILE9BQU9rQixzQkFBc0JIO0FBQy9CO0FBRUE7Ozs7O0NBS0MsR0FDRCxTQUFTWixzQkFBc0JULGFBQWE7SUFDMUMsT0FBT0EsY0FDSnlCLEtBQUssQ0FBQyxLQUNOQyxHQUFHLENBQUNDLENBQUFBLGVBQWdCQSxhQUFhRixLQUFLLENBQUMsS0FBS0MsR0FBRyxDQUFDRSxDQUFBQSxhQUFjQyxtQkFBbUJELFdBQVdFLElBQUksTUFDaEd6QixNQUFNLENBQUMsQ0FBQ0MsS0FBSyxDQUFDSSxLQUFLSyxNQUFNO1FBQ3hCVCxHQUFHLENBQUNJLElBQUksR0FBR0s7UUFDWCxPQUFPVDtJQUNULEdBQUcsQ0FBQztBQUNSO0FBRUE7Ozs7OztDQU1DLEdBQ0QsU0FBU2tCLHNCQUFzQk8sTUFBTTtJQUNuQyxJQUFJcEIsT0FBT0MsSUFBSSxDQUFDbUIsUUFBUVosTUFBTSxLQUFLLEdBQUc7UUFDcEMsc0VBQXNFO1FBQ3RFLE9BQU9oQjtJQUNUO0lBRUEsT0FBT1EsT0FBT0csT0FBTyxDQUFDaUIsUUFBUTFCLE1BQU0sQ0FBQyxDQUFDTCxlQUFlLENBQUNnQyxXQUFXQyxZQUFZLEVBQUVDO1FBQzdFLE1BQU1QLGVBQWUsQ0FBQyxFQUFFUSxtQkFBbUJILFdBQVcsQ0FBQyxFQUFFRyxtQkFBbUJGLGFBQWEsQ0FBQztRQUMxRixNQUFNRyxtQkFBbUJGLGlCQUFpQixJQUFJUCxlQUFlLENBQUMsRUFBRTNCLGNBQWMsQ0FBQyxFQUFFMkIsYUFBYSxDQUFDO1FBQy9GLElBQUlTLGlCQUFpQmpCLE1BQU0sR0FBR3JCLDJCQUEyQjtZQUN2RE4sd0RBQVdBLElBQ1RFLDhDQUFNQSxDQUFDMkMsSUFBSSxDQUNULENBQUMsZ0JBQWdCLEVBQUVMLFVBQVUsV0FBVyxFQUFFQyxZQUFZLHdEQUF3RCxDQUFDO1lBRW5ILE9BQU9qQztRQUNULE9BQU87WUFDTCxPQUFPb0M7UUFDVDtJQUNGLEdBQUc7QUFDTDtBQUUwTSxDQUMxTSxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vYnJhbGluay13ZWIvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS91dGlscy9lc20vYmFnZ2FnZS5qcz8yZDFjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERFQlVHX0JVSUxEIH0gZnJvbSAnLi9kZWJ1Zy1idWlsZC5qcyc7XG5pbXBvcnQgeyBpc1N0cmluZyB9IGZyb20gJy4vaXMuanMnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi9sb2dnZXIuanMnO1xuXG5jb25zdCBCQUdHQUdFX0hFQURFUl9OQU1FID0gJ2JhZ2dhZ2UnO1xuXG5jb25zdCBTRU5UUllfQkFHR0FHRV9LRVlfUFJFRklYID0gJ3NlbnRyeS0nO1xuXG5jb25zdCBTRU5UUllfQkFHR0FHRV9LRVlfUFJFRklYX1JFR0VYID0gL15zZW50cnktLztcblxuLyoqXG4gKiBNYXggbGVuZ3RoIG9mIGEgc2VyaWFsaXplZCBiYWdnYWdlIHN0cmluZ1xuICpcbiAqIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9iYWdnYWdlLyNsaW1pdHNcbiAqL1xuY29uc3QgTUFYX0JBR0dBR0VfU1RSSU5HX0xFTkdUSCA9IDgxOTI7XG5cbi8qKlxuICogVGFrZXMgYSBiYWdnYWdlIGhlYWRlciBhbmQgdHVybnMgaXQgaW50byBEeW5hbWljIFNhbXBsaW5nIENvbnRleHQsIGJ5IGV4dHJhY3RpbmcgYWxsIHRoZSBcInNlbnRyeS1cIiBwcmVmaXhlZCB2YWx1ZXNcbiAqIGZyb20gaXQuXG4gKlxuICogQHBhcmFtIGJhZ2dhZ2VIZWFkZXIgQSB2ZXJ5IGJyZWFkIGRlZmluaXRpb24gb2YgYSBiYWdnYWdlIGhlYWRlciBhcyBpdCBtaWdodCBhcHBlYXIgaW4gdmFyaW91cyBmcmFtZXdvcmtzLlxuICogQHJldHVybnMgVGhlIER5bmFtaWMgU2FtcGxpbmcgQ29udGV4dCB0aGF0IHdhcyBmb3VuZCBvbiBgYmFnZ2FnZUhlYWRlcmAsIGlmIHRoZXJlIHdhcyBhbnksIGB1bmRlZmluZWRgIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gYmFnZ2FnZUhlYWRlclRvRHluYW1pY1NhbXBsaW5nQ29udGV4dChcbiAgLy8gVmVyeSBsaWJlcmFsIGRlZmluaXRpb24gb2Ygd2hhdCBhbnkgaW5jb21pbmcgaGVhZGVyIG1pZ2h0IGxvb2sgbGlrZVxuICBiYWdnYWdlSGVhZGVyLFxuKSB7XG4gIGlmICghaXNTdHJpbmcoYmFnZ2FnZUhlYWRlcikgJiYgIUFycmF5LmlzQXJyYXkoYmFnZ2FnZUhlYWRlcikpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gSW50ZXJtZWRpYXJ5IG9iamVjdCB0byBzdG9yZSBiYWdnYWdlIGtleSB2YWx1ZSBwYWlycyBvZiBpbmNvbWluZyBiYWdnYWdlIGhlYWRlcnMgb24uXG4gIC8vIEl0IGlzIGxhdGVyIHVzZWQgdG8gcmVhZCBTZW50cnktRFNDLXZhbHVlcyBmcm9tLlxuICBsZXQgYmFnZ2FnZU9iamVjdCA9IHt9O1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGJhZ2dhZ2VIZWFkZXIpKSB7XG4gICAgLy8gQ29tYmluZSBhbGwgYmFnZ2FnZSBoZWFkZXJzIGludG8gb25lIG9iamVjdCBjb250YWluaW5nIHRoZSBiYWdnYWdlIHZhbHVlcyBzbyB3ZSBjYW4gbGF0ZXIgcmVhZCB0aGUgU2VudHJ5LURTQy12YWx1ZXMgZnJvbSBpdFxuICAgIGJhZ2dhZ2VPYmplY3QgPSBiYWdnYWdlSGVhZGVyLnJlZHVjZSgoYWNjLCBjdXJyKSA9PiB7XG4gICAgICBjb25zdCBjdXJyQmFnZ2FnZU9iamVjdCA9IGJhZ2dhZ2VIZWFkZXJUb09iamVjdChjdXJyKTtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGN1cnJCYWdnYWdlT2JqZWN0KSkge1xuICAgICAgICBhY2Nba2V5XSA9IGN1cnJCYWdnYWdlT2JqZWN0W2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBSZXR1cm4gdW5kZWZpbmVkIGlmIGJhZ2dhZ2UgaGVhZGVyIGlzIGFuIGVtcHR5IHN0cmluZyAodGVjaG5pY2FsbHkgYW4gZW1wdHkgYmFnZ2FnZSBoZWFkZXIgaXMgbm90IHNwZWMgY29uZm9ybSBidXRcbiAgICAvLyB0aGlzIGlzIGhvdyB3ZSBjaG9vc2UgdG8gaGFuZGxlIGl0KVxuICAgIGlmICghYmFnZ2FnZUhlYWRlcikge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBiYWdnYWdlT2JqZWN0ID0gYmFnZ2FnZUhlYWRlclRvT2JqZWN0KGJhZ2dhZ2VIZWFkZXIpO1xuICB9XG5cbiAgLy8gUmVhZCBhbGwgXCJzZW50cnktXCIgcHJlZml4ZWQgdmFsdWVzIG91dCBvZiB0aGUgYmFnZ2FnZSBvYmplY3QgYW5kIHB1dCBpdCBvbnRvIGEgZHluYW1pYyBzYW1wbGluZyBjb250ZXh0IG9iamVjdC5cbiAgY29uc3QgZHluYW1pY1NhbXBsaW5nQ29udGV4dCA9IE9iamVjdC5lbnRyaWVzKGJhZ2dhZ2VPYmplY3QpLnJlZHVjZSgoYWNjLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBpZiAoa2V5Lm1hdGNoKFNFTlRSWV9CQUdHQUdFX0tFWV9QUkVGSVhfUkVHRVgpKSB7XG4gICAgICBjb25zdCBub25QcmVmaXhlZEtleSA9IGtleS5zbGljZShTRU5UUllfQkFHR0FHRV9LRVlfUFJFRklYLmxlbmd0aCk7XG4gICAgICBhY2Nbbm9uUHJlZml4ZWRLZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcblxuICAvLyBPbmx5IHJldHVybiBhIGR5bmFtaWMgc2FtcGxpbmcgY29udGV4dCBvYmplY3QgaWYgdGhlcmUgYXJlIGtleXMgaW4gaXQuXG4gIC8vIEEga2V5bGVzcyBvYmplY3QgbWVhbnMgdGhlcmUgd2VyZSBubyBzZW50cnkgdmFsdWVzIG9uIHRoZSBoZWFkZXIsIHdoaWNoIG1lYW5zIHRoYXQgdGhlcmUgaXMgbm8gRFNDLlxuICBpZiAoT2JqZWN0LmtleXMoZHluYW1pY1NhbXBsaW5nQ29udGV4dCkubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBkeW5hbWljU2FtcGxpbmdDb250ZXh0IDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogVHVybnMgYSBEeW5hbWljIFNhbXBsaW5nIE9iamVjdCBpbnRvIGEgYmFnZ2FnZSBoZWFkZXIgYnkgcHJlZml4aW5nIGFsbCB0aGUga2V5cyBvbiB0aGUgb2JqZWN0IHdpdGggXCJzZW50cnktXCIuXG4gKlxuICogQHBhcmFtIGR5bmFtaWNTYW1wbGluZ0NvbnRleHQgVGhlIER5bmFtaWMgU2FtcGxpbmcgQ29udGV4dCB0byB0dXJuIGludG8gYSBoZWFkZXIuIEZvciBjb252ZW5pZW5jZSBhbmQgY29tcGF0aWJpbGl0eVxuICogd2l0aCB0aGUgYGdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRgIG1ldGhvZCBvbiB0aGUgVHJhbnNhY3Rpb24gY2xhc3MgLHRoaXMgYXJndW1lbnQgY2FuIGFsc28gYmUgYHVuZGVmaW5lZGAuIElmIGl0IGlzXG4gKiBgdW5kZWZpbmVkYCB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gYHVuZGVmaW5lZGAuXG4gKiBAcmV0dXJucyBhIGJhZ2dhZ2UgaGVhZGVyLCBjcmVhdGVkIGZyb20gYGR5bmFtaWNTYW1wbGluZ0NvbnRleHRgLCBvciBgdW5kZWZpbmVkYCBlaXRoZXIgaWYgYGR5bmFtaWNTYW1wbGluZ0NvbnRleHRgXG4gKiB3YXMgYHVuZGVmaW5lZGAsIG9yIGlmIGBkeW5hbWljU2FtcGxpbmdDb250ZXh0YCBkaWRuJ3QgY29udGFpbiBhbnkgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBkeW5hbWljU2FtcGxpbmdDb250ZXh0VG9TZW50cnlCYWdnYWdlSGVhZGVyKFxuICAvLyB0aGlzIGFsc28gdGFrZXMgdW5kZWZpbmVkIGZvciBjb252ZW5pZW5jZSBhbmQgYnVuZGxlIHNpemUgaW4gb3RoZXIgcGxhY2VzXG4gIGR5bmFtaWNTYW1wbGluZ0NvbnRleHQsXG4pIHtcbiAgaWYgKCFkeW5hbWljU2FtcGxpbmdDb250ZXh0KSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8vIFByZWZpeCBhbGwgRFNDIGtleXMgd2l0aCBcInNlbnRyeS1cIiBhbmQgcHV0IHRoZW0gaW50byBhIG5ldyBvYmplY3RcbiAgY29uc3Qgc2VudHJ5UHJlZml4ZWREU0MgPSBPYmplY3QuZW50cmllcyhkeW5hbWljU2FtcGxpbmdDb250ZXh0KS5yZWR1Y2UoXG4gICAgKGFjYywgW2RzY0tleSwgZHNjVmFsdWVdKSA9PiB7XG4gICAgICBpZiAoZHNjVmFsdWUpIHtcbiAgICAgICAgYWNjW2Ake1NFTlRSWV9CQUdHQUdFX0tFWV9QUkVGSVh9JHtkc2NLZXl9YF0gPSBkc2NWYWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSxcbiAgICB7fSxcbiAgKTtcblxuICByZXR1cm4gb2JqZWN0VG9CYWdnYWdlSGVhZGVyKHNlbnRyeVByZWZpeGVkRFNDKTtcbn1cblxuLyoqXG4gKiBXaWxsIHBhcnNlIGEgYmFnZ2FnZSBoZWFkZXIsIHdoaWNoIGlzIGEgc2ltcGxlIGtleS12YWx1ZSBtYXAsIGludG8gYSBmbGF0IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gYmFnZ2FnZUhlYWRlciBUaGUgYmFnZ2FnZSBoZWFkZXIgdG8gcGFyc2UuXG4gKiBAcmV0dXJucyBhIGZsYXQgb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBrZXktdmFsdWUgcGFpcnMgZnJvbSBgYmFnZ2FnZUhlYWRlcmAuXG4gKi9cbmZ1bmN0aW9uIGJhZ2dhZ2VIZWFkZXJUb09iamVjdChiYWdnYWdlSGVhZGVyKSB7XG4gIHJldHVybiBiYWdnYWdlSGVhZGVyXG4gICAgLnNwbGl0KCcsJylcbiAgICAubWFwKGJhZ2dhZ2VFbnRyeSA9PiBiYWdnYWdlRW50cnkuc3BsaXQoJz0nKS5tYXAoa2V5T3JWYWx1ZSA9PiBkZWNvZGVVUklDb21wb25lbnQoa2V5T3JWYWx1ZS50cmltKCkpKSlcbiAgICAucmVkdWNlKChhY2MsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgYWNjW2tleV0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xufVxuXG4vKipcbiAqIFR1cm5zIGEgZmxhdCBvYmplY3QgKGtleS12YWx1ZSBwYWlycykgaW50byBhIGJhZ2dhZ2UgaGVhZGVyLCB3aGljaCBpcyBhbHNvIGp1c3Qga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwYXJhbSBvYmplY3QgVGhlIG9iamVjdCB0byB0dXJuIGludG8gYSBiYWdnYWdlIGhlYWRlci5cbiAqIEByZXR1cm5zIGEgYmFnZ2FnZSBoZWFkZXIgc3RyaW5nLCBvciBgdW5kZWZpbmVkYCBpZiB0aGUgb2JqZWN0IGRpZG4ndCBoYXZlIGFueSB2YWx1ZXMsIHNpbmNlIGFuIGVtcHR5IGJhZ2dhZ2UgaGVhZGVyXG4gKiBpcyBub3Qgc3BlYyBjb21wbGlhbnQuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvQmFnZ2FnZUhlYWRlcihvYmplY3QpIHtcbiAgaWYgKE9iamVjdC5rZXlzKG9iamVjdCkubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gQW4gZW1wdHkgYmFnZ2FnZSBoZWFkZXIgaXMgbm90IHNwZWMgY29tcGxpYW50OiBXZSByZXR1cm4gdW5kZWZpbmVkLlxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmVudHJpZXMob2JqZWN0KS5yZWR1Y2UoKGJhZ2dhZ2VIZWFkZXIsIFtvYmplY3RLZXksIG9iamVjdFZhbHVlXSwgY3VycmVudEluZGV4KSA9PiB7XG4gICAgY29uc3QgYmFnZ2FnZUVudHJ5ID0gYCR7ZW5jb2RlVVJJQ29tcG9uZW50KG9iamVjdEtleSl9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KG9iamVjdFZhbHVlKX1gO1xuICAgIGNvbnN0IG5ld0JhZ2dhZ2VIZWFkZXIgPSBjdXJyZW50SW5kZXggPT09IDAgPyBiYWdnYWdlRW50cnkgOiBgJHtiYWdnYWdlSGVhZGVyfSwke2JhZ2dhZ2VFbnRyeX1gO1xuICAgIGlmIChuZXdCYWdnYWdlSGVhZGVyLmxlbmd0aCA+IE1BWF9CQUdHQUdFX1NUUklOR19MRU5HVEgpIHtcbiAgICAgIERFQlVHX0JVSUxEICYmXG4gICAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICAgIGBOb3QgYWRkaW5nIGtleTogJHtvYmplY3RLZXl9IHdpdGggdmFsOiAke29iamVjdFZhbHVlfSB0byBiYWdnYWdlIGhlYWRlciBkdWUgdG8gZXhjZWVkaW5nIGJhZ2dhZ2Ugc2l6ZSBsaW1pdHMuYCxcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiBiYWdnYWdlSGVhZGVyO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3QmFnZ2FnZUhlYWRlcjtcbiAgICB9XG4gIH0sICcnKTtcbn1cblxuZXhwb3J0IHsgQkFHR0FHRV9IRUFERVJfTkFNRSwgTUFYX0JBR0dBR0VfU1RSSU5HX0xFTkdUSCwgU0VOVFJZX0JBR0dBR0VfS0VZX1BSRUZJWCwgU0VOVFJZX0JBR0dBR0VfS0VZX1BSRUZJWF9SRUdFWCwgYmFnZ2FnZUhlYWRlclRvRHluYW1pY1NhbXBsaW5nQ29udGV4dCwgZHluYW1pY1NhbXBsaW5nQ29udGV4dFRvU2VudHJ5QmFnZ2FnZUhlYWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFnZ2FnZS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJERUJVR19CVUlMRCIsImlzU3RyaW5nIiwibG9nZ2VyIiwiQkFHR0FHRV9IRUFERVJfTkFNRSIsIlNFTlRSWV9CQUdHQUdFX0tFWV9QUkVGSVgiLCJTRU5UUllfQkFHR0FHRV9LRVlfUFJFRklYX1JFR0VYIiwiTUFYX0JBR0dBR0VfU1RSSU5HX0xFTkdUSCIsImJhZ2dhZ2VIZWFkZXJUb0R5bmFtaWNTYW1wbGluZ0NvbnRleHQiLCJiYWdnYWdlSGVhZGVyIiwiQXJyYXkiLCJpc0FycmF5IiwidW5kZWZpbmVkIiwiYmFnZ2FnZU9iamVjdCIsInJlZHVjZSIsImFjYyIsImN1cnIiLCJjdXJyQmFnZ2FnZU9iamVjdCIsImJhZ2dhZ2VIZWFkZXJUb09iamVjdCIsImtleSIsIk9iamVjdCIsImtleXMiLCJkeW5hbWljU2FtcGxpbmdDb250ZXh0IiwiZW50cmllcyIsInZhbHVlIiwibWF0Y2giLCJub25QcmVmaXhlZEtleSIsInNsaWNlIiwibGVuZ3RoIiwiZHluYW1pY1NhbXBsaW5nQ29udGV4dFRvU2VudHJ5QmFnZ2FnZUhlYWRlciIsInNlbnRyeVByZWZpeGVkRFNDIiwiZHNjS2V5IiwiZHNjVmFsdWUiLCJvYmplY3RUb0JhZ2dhZ2VIZWFkZXIiLCJzcGxpdCIsIm1hcCIsImJhZ2dhZ2VFbnRyeSIsImtleU9yVmFsdWUiLCJkZWNvZGVVUklDb21wb25lbnQiLCJ0cmltIiwib2JqZWN0Iiwib2JqZWN0S2V5Iiwib2JqZWN0VmFsdWUiLCJjdXJyZW50SW5kZXgiLCJlbmNvZGVVUklDb21wb25lbnQiLCJuZXdCYWdnYWdlSGVhZGVyIiwid2FybiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/utils/esm/baggage.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sentry/utils/esm/browser.js":
/*!***************************************************!*\
  !*** ./node_modules/@sentry/utils/esm/browser.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getComponentName: () => (/* binding */ getComponentName),\n/* harmony export */   getDomElement: () => (/* binding */ getDomElement),\n/* harmony export */   getLocationHref: () => (/* binding */ getLocationHref),\n/* harmony export */   htmlTreeAsString: () => (/* binding */ htmlTreeAsString)\n/* harmony export */ });\n/* harmony import */ var _is_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./is.js */ \"(ssr)/./node_modules/@sentry/utils/esm/is.js\");\n/* harmony import */ var _worldwide_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./worldwide.js */ \"(ssr)/./node_modules/@sentry/utils/esm/worldwide.js\");\n\n\n// eslint-disable-next-line deprecation/deprecation\nconst WINDOW = (0,_worldwide_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalObject)();\nconst DEFAULT_MAX_STRING_LENGTH = 80;\n/**\n * Given a child DOM element, returns a query-selector statement describing that\n * and its ancestors\n * e.g. [HTMLElement] => body > div > input#foo.btn[name=baz]\n * @returns generated DOM path\n */ function htmlTreeAsString(elem, options = {}) {\n    if (!elem) {\n        return \"<unknown>\";\n    }\n    // try/catch both:\n    // - accessing event.target (see getsentry/raven-js#838, #768)\n    // - `htmlTreeAsString` because it's complex, and just accessing the DOM incorrectly\n    // - can throw an exception in some circumstances.\n    try {\n        let currentElem = elem;\n        const MAX_TRAVERSE_HEIGHT = 5;\n        const out = [];\n        let height = 0;\n        let len = 0;\n        const separator = \" > \";\n        const sepLength = separator.length;\n        let nextStr;\n        const keyAttrs = Array.isArray(options) ? options : options.keyAttrs;\n        const maxStringLength = !Array.isArray(options) && options.maxStringLength || DEFAULT_MAX_STRING_LENGTH;\n        while(currentElem && height++ < MAX_TRAVERSE_HEIGHT){\n            nextStr = _htmlElementAsString(currentElem, keyAttrs);\n            // bail out if\n            // - nextStr is the 'html' element\n            // - the length of the string that would be created exceeds maxStringLength\n            //   (ignore this limit if we are on the first iteration)\n            if (nextStr === \"html\" || height > 1 && len + out.length * sepLength + nextStr.length >= maxStringLength) {\n                break;\n            }\n            out.push(nextStr);\n            len += nextStr.length;\n            currentElem = currentElem.parentNode;\n        }\n        return out.reverse().join(separator);\n    } catch (_oO) {\n        return \"<unknown>\";\n    }\n}\n/**\n * Returns a simple, query-selector representation of a DOM element\n * e.g. [HTMLElement] => input#foo.btn[name=baz]\n * @returns generated DOM path\n */ function _htmlElementAsString(el, keyAttrs) {\n    const elem = el;\n    const out = [];\n    let className;\n    let classes;\n    let key;\n    let attr;\n    let i;\n    if (!elem || !elem.tagName) {\n        return \"\";\n    }\n    // @ts-expect-error WINDOW has HTMLElement\n    if (WINDOW.HTMLElement) {\n        // If using the component name annotation plugin, this value may be available on the DOM node\n        if (elem instanceof HTMLElement && elem.dataset && elem.dataset[\"sentryComponent\"]) {\n            return elem.dataset[\"sentryComponent\"];\n        }\n    }\n    out.push(elem.tagName.toLowerCase());\n    // Pairs of attribute keys defined in `serializeAttribute` and their values on element.\n    const keyAttrPairs = keyAttrs && keyAttrs.length ? keyAttrs.filter((keyAttr)=>elem.getAttribute(keyAttr)).map((keyAttr)=>[\n            keyAttr,\n            elem.getAttribute(keyAttr)\n        ]) : null;\n    if (keyAttrPairs && keyAttrPairs.length) {\n        keyAttrPairs.forEach((keyAttrPair)=>{\n            out.push(`[${keyAttrPair[0]}=\"${keyAttrPair[1]}\"]`);\n        });\n    } else {\n        if (elem.id) {\n            out.push(`#${elem.id}`);\n        }\n        // eslint-disable-next-line prefer-const\n        className = elem.className;\n        if (className && (0,_is_js__WEBPACK_IMPORTED_MODULE_1__.isString)(className)) {\n            classes = className.split(/\\s+/);\n            for(i = 0; i < classes.length; i++){\n                out.push(`.${classes[i]}`);\n            }\n        }\n    }\n    const allowedAttrs = [\n        \"aria-label\",\n        \"type\",\n        \"name\",\n        \"title\",\n        \"alt\"\n    ];\n    for(i = 0; i < allowedAttrs.length; i++){\n        key = allowedAttrs[i];\n        attr = elem.getAttribute(key);\n        if (attr) {\n            out.push(`[${key}=\"${attr}\"]`);\n        }\n    }\n    return out.join(\"\");\n}\n/**\n * A safe form of location.href\n */ function getLocationHref() {\n    try {\n        return WINDOW.document.location.href;\n    } catch (oO) {\n        return \"\";\n    }\n}\n/**\n * Gets a DOM element by using document.querySelector.\n *\n * This wrapper will first check for the existance of the function before\n * actually calling it so that we don't have to take care of this check,\n * every time we want to access the DOM.\n *\n * Reason: DOM/querySelector is not available in all environments.\n *\n * We have to cast to any because utils can be consumed by a variety of environments,\n * and we don't want to break TS users. If you know what element will be selected by\n * `document.querySelector`, specify it as part of the generic call. For example,\n * `const element = getDomElement<Element>('selector');`\n *\n * @param selector the selector string passed on to document.querySelector\n */ // eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction getDomElement(selector) {\n    if (WINDOW.document && WINDOW.document.querySelector) {\n        return WINDOW.document.querySelector(selector);\n    }\n    return null;\n}\n/**\n * Given a DOM element, traverses up the tree until it finds the first ancestor node\n * that has the `data-sentry-component` attribute. This attribute is added at build-time\n * by projects that have the component name annotation plugin installed.\n *\n * @returns a string representation of the component for the provided DOM element, or `null` if not found\n */ function getComponentName(elem) {\n    // @ts-expect-error WINDOW has HTMLElement\n    if (!WINDOW.HTMLElement) {\n        return null;\n    }\n    let currentElem = elem;\n    const MAX_TRAVERSE_HEIGHT = 5;\n    for(let i = 0; i < MAX_TRAVERSE_HEIGHT; i++){\n        if (!currentElem) {\n            return null;\n        }\n        if (currentElem instanceof HTMLElement && currentElem.dataset[\"sentryComponent\"]) {\n            return currentElem.dataset[\"sentryComponent\"];\n        }\n        currentElem = currentElem.parentNode;\n    }\n    return null;\n}\n //# sourceMappingURL=browser.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS91dGlscy9lc20vYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBbUM7QUFDYztBQUVqRCxtREFBbUQ7QUFDbkQsTUFBTUUsU0FBU0QsOERBQWVBO0FBRTlCLE1BQU1FLDRCQUE0QjtBQUVsQzs7Ozs7Q0FLQyxHQUNELFNBQVNDLGlCQUNQQyxJQUFJLEVBQ0pDLFVBQVUsQ0FBQyxDQUFDO0lBRVosSUFBSSxDQUFDRCxNQUFNO1FBQ1QsT0FBTztJQUNUO0lBRUEsa0JBQWtCO0lBQ2xCLDhEQUE4RDtJQUM5RCxvRkFBb0Y7SUFDcEYsa0RBQWtEO0lBQ2xELElBQUk7UUFDRixJQUFJRSxjQUFjRjtRQUNsQixNQUFNRyxzQkFBc0I7UUFDNUIsTUFBTUMsTUFBTSxFQUFFO1FBQ2QsSUFBSUMsU0FBUztRQUNiLElBQUlDLE1BQU07UUFDVixNQUFNQyxZQUFZO1FBQ2xCLE1BQU1DLFlBQVlELFVBQVVFLE1BQU07UUFDbEMsSUFBSUM7UUFDSixNQUFNQyxXQUFXQyxNQUFNQyxPQUFPLENBQUNaLFdBQVdBLFVBQVVBLFFBQVFVLFFBQVE7UUFDcEUsTUFBTUcsa0JBQWtCLENBQUVGLE1BQU1DLE9BQU8sQ0FBQ1osWUFBWUEsUUFBUWEsZUFBZSxJQUFLaEI7UUFFaEYsTUFBT0ksZUFBZUcsV0FBV0Ysb0JBQXFCO1lBQ3BETyxVQUFVSyxxQkFBcUJiLGFBQWFTO1lBQzVDLGNBQWM7WUFDZCxrQ0FBa0M7WUFDbEMsMkVBQTJFO1lBQzNFLHlEQUF5RDtZQUN6RCxJQUFJRCxZQUFZLFVBQVdMLFNBQVMsS0FBS0MsTUFBTUYsSUFBSUssTUFBTSxHQUFHRCxZQUFZRSxRQUFRRCxNQUFNLElBQUlLLGlCQUFrQjtnQkFDMUc7WUFDRjtZQUVBVixJQUFJWSxJQUFJLENBQUNOO1lBRVRKLE9BQU9JLFFBQVFELE1BQU07WUFDckJQLGNBQWNBLFlBQVllLFVBQVU7UUFDdEM7UUFFQSxPQUFPYixJQUFJYyxPQUFPLEdBQUdDLElB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U0FBU0UsaUJBQWlCakQsSUFBSTtJQUM1QiwwQ0FBMEM7SUFDMUMsSUFBSSxDQUFDSCxPQUFPK0IsV0FBVyxFQUFFO1FBQ3ZCLE9BQU87SUFDVDtJQUVBLElBQUkxQixjQUFjRjtJQUNsQixNQUFNRyxzQkFBc0I7SUFDNUIsSUFBSyxJQUFJdUIsSUFBSSxHQUFHQSxJQUFJdkIscUJBQXFCdUIsSUFBSztRQUM1QyxJQUFJLENBQUN4QixhQUFhO1lBQ2hCLE9BQU87UUFDVDtRQUVBLElBQUlBLHVCQUF1QjBCLGVBQWUxQixZQUFZMkIsT0FBTyxDQUFDLGtCQUFrQixFQUFFO1lBQ2hGLE9BQU8zQixZQUFZMkIsT0FBTyxDQUFDLGtCQUFrQjtRQUMvQztRQUVBM0IsY0FBY0EsWUFBWWUsVUFBVTtJQUN0QztJQUVBLE9BQU87QUFDVDtBQUU4RSxDQUM5RSxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vYnJhbGluay13ZWIvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS91dGlscy9lc20vYnJvd3Nlci5qcz81MDYxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzU3RyaW5nIH0gZnJvbSAnLi9pcy5qcyc7XG5pbXBvcnQgeyBnZXRHbG9iYWxPYmplY3QgfSBmcm9tICcuL3dvcmxkd2lkZS5qcyc7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuY29uc3QgV0lORE9XID0gZ2V0R2xvYmFsT2JqZWN0KCk7XG5cbmNvbnN0IERFRkFVTFRfTUFYX1NUUklOR19MRU5HVEggPSA4MDtcblxuLyoqXG4gKiBHaXZlbiBhIGNoaWxkIERPTSBlbGVtZW50LCByZXR1cm5zIGEgcXVlcnktc2VsZWN0b3Igc3RhdGVtZW50IGRlc2NyaWJpbmcgdGhhdFxuICogYW5kIGl0cyBhbmNlc3RvcnNcbiAqIGUuZy4gW0hUTUxFbGVtZW50XSA9PiBib2R5ID4gZGl2ID4gaW5wdXQjZm9vLmJ0bltuYW1lPWJhel1cbiAqIEByZXR1cm5zIGdlbmVyYXRlZCBET00gcGF0aFxuICovXG5mdW5jdGlvbiBodG1sVHJlZUFzU3RyaW5nKFxuICBlbGVtLFxuICBvcHRpb25zID0ge30sXG4pIHtcbiAgaWYgKCFlbGVtKSB7XG4gICAgcmV0dXJuICc8dW5rbm93bj4nO1xuICB9XG5cbiAgLy8gdHJ5L2NhdGNoIGJvdGg6XG4gIC8vIC0gYWNjZXNzaW5nIGV2ZW50LnRhcmdldCAoc2VlIGdldHNlbnRyeS9yYXZlbi1qcyM4MzgsICM3NjgpXG4gIC8vIC0gYGh0bWxUcmVlQXNTdHJpbmdgIGJlY2F1c2UgaXQncyBjb21wbGV4LCBhbmQganVzdCBhY2Nlc3NpbmcgdGhlIERPTSBpbmNvcnJlY3RseVxuICAvLyAtIGNhbiB0aHJvdyBhbiBleGNlcHRpb24gaW4gc29tZSBjaXJjdW1zdGFuY2VzLlxuICB0cnkge1xuICAgIGxldCBjdXJyZW50RWxlbSA9IGVsZW0gO1xuICAgIGNvbnN0IE1BWF9UUkFWRVJTRV9IRUlHSFQgPSA1O1xuICAgIGNvbnN0IG91dCA9IFtdO1xuICAgIGxldCBoZWlnaHQgPSAwO1xuICAgIGxldCBsZW4gPSAwO1xuICAgIGNvbnN0IHNlcGFyYXRvciA9ICcgPiAnO1xuICAgIGNvbnN0IHNlcExlbmd0aCA9IHNlcGFyYXRvci5sZW5ndGg7XG4gICAgbGV0IG5leHRTdHI7XG4gICAgY29uc3Qga2V5QXR0cnMgPSBBcnJheS5pc0FycmF5KG9wdGlvbnMpID8gb3B0aW9ucyA6IG9wdGlvbnMua2V5QXR0cnM7XG4gICAgY29uc3QgbWF4U3RyaW5nTGVuZ3RoID0gKCFBcnJheS5pc0FycmF5KG9wdGlvbnMpICYmIG9wdGlvbnMubWF4U3RyaW5nTGVuZ3RoKSB8fCBERUZBVUxUX01BWF9TVFJJTkdfTEVOR1RIO1xuXG4gICAgd2hpbGUgKGN1cnJlbnRFbGVtICYmIGhlaWdodCsrIDwgTUFYX1RSQVZFUlNFX0hFSUdIVCkge1xuICAgICAgbmV4dFN0ciA9IF9odG1sRWxlbWVudEFzU3RyaW5nKGN1cnJlbnRFbGVtLCBrZXlBdHRycyk7XG4gICAgICAvLyBiYWlsIG91dCBpZlxuICAgICAgLy8gLSBuZXh0U3RyIGlzIHRoZSAnaHRtbCcgZWxlbWVudFxuICAgICAgLy8gLSB0aGUgbGVuZ3RoIG9mIHRoZSBzdHJpbmcgdGhhdCB3b3VsZCBiZSBjcmVhdGVkIGV4Y2VlZHMgbWF4U3RyaW5nTGVuZ3RoXG4gICAgICAvLyAgIChpZ25vcmUgdGhpcyBsaW1pdCBpZiB3ZSBhcmUgb24gdGhlIGZpcnN0IGl0ZXJhdGlvbilcbiAgICAgIGlmIChuZXh0U3RyID09PSAnaHRtbCcgfHwgKGhlaWdodCA+IDEgJiYgbGVuICsgb3V0Lmxlbmd0aCAqIHNlcExlbmd0aCArIG5leHRTdHIubGVuZ3RoID49IG1heFN0cmluZ0xlbmd0aCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIG91dC5wdXNoKG5leHRTdHIpO1xuXG4gICAgICBsZW4gKz0gbmV4dFN0ci5sZW5ndGg7XG4gICAgICBjdXJyZW50RWxlbSA9IGN1cnJlbnRFbGVtLnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dC5yZXZlcnNlKCkuam9pbihzZXBhcmF0b3IpO1xuICB9IGNhdGNoIChfb08pIHtcbiAgICByZXR1cm4gJzx1bmtub3duPic7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc2ltcGxlLCBxdWVyeS1zZWxlY3RvciByZXByZXNlbnRhdGlvbiBvZiBhIERPTSBlbGVtZW50XG4gKiBlLmcuIFtIVE1MRWxlbWVudF0gPT4gaW5wdXQjZm9vLmJ0bltuYW1lPWJhel1cbiAqIEByZXR1cm5zIGdlbmVyYXRlZCBET00gcGF0aFxuICovXG5mdW5jdGlvbiBfaHRtbEVsZW1lbnRBc1N0cmluZyhlbCwga2V5QXR0cnMpIHtcbiAgY29uc3QgZWxlbSA9IGVsXG5cbjtcblxuICBjb25zdCBvdXQgPSBbXTtcbiAgbGV0IGNsYXNzTmFtZTtcbiAgbGV0IGNsYXNzZXM7XG4gIGxldCBrZXk7XG4gIGxldCBhdHRyO1xuICBsZXQgaTtcblxuICBpZiAoIWVsZW0gfHwgIWVsZW0udGFnTmFtZSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIC8vIEB0cy1leHBlY3QtZXJyb3IgV0lORE9XIGhhcyBIVE1MRWxlbWVudFxuICBpZiAoV0lORE9XLkhUTUxFbGVtZW50KSB7XG4gICAgLy8gSWYgdXNpbmcgdGhlIGNvbXBvbmVudCBuYW1lIGFubm90YXRpb24gcGx1Z2luLCB0aGlzIHZhbHVlIG1heSBiZSBhdmFpbGFibGUgb24gdGhlIERPTSBub2RlXG4gICAgaWYgKGVsZW0gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiBlbGVtLmRhdGFzZXQgJiYgZWxlbS5kYXRhc2V0WydzZW50cnlDb21wb25lbnQnXSkge1xuICAgICAgcmV0dXJuIGVsZW0uZGF0YXNldFsnc2VudHJ5Q29tcG9uZW50J107XG4gICAgfVxuICB9XG5cbiAgb3V0LnB1c2goZWxlbS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpO1xuXG4gIC8vIFBhaXJzIG9mIGF0dHJpYnV0ZSBrZXlzIGRlZmluZWQgaW4gYHNlcmlhbGl6ZUF0dHJpYnV0ZWAgYW5kIHRoZWlyIHZhbHVlcyBvbiBlbGVtZW50LlxuICBjb25zdCBrZXlBdHRyUGFpcnMgPVxuICAgIGtleUF0dHJzICYmIGtleUF0dHJzLmxlbmd0aFxuICAgICAgPyBrZXlBdHRycy5maWx0ZXIoa2V5QXR0ciA9PiBlbGVtLmdldEF0dHJpYnV0ZShrZXlBdHRyKSkubWFwKGtleUF0dHIgPT4gW2tleUF0dHIsIGVsZW0uZ2V0QXR0cmlidXRlKGtleUF0dHIpXSlcbiAgICAgIDogbnVsbDtcblxuICBpZiAoa2V5QXR0clBhaXJzICYmIGtleUF0dHJQYWlycy5sZW5ndGgpIHtcbiAgICBrZXlBdHRyUGFpcnMuZm9yRWFjaChrZXlBdHRyUGFpciA9PiB7XG4gICAgICBvdXQucHVzaChgWyR7a2V5QXR0clBhaXJbMF19PVwiJHtrZXlBdHRyUGFpclsxXX1cIl1gKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoZWxlbS5pZCkge1xuICAgICAgb3V0LnB1c2goYCMke2VsZW0uaWR9YCk7XG4gICAgfVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICAgIGNsYXNzTmFtZSA9IGVsZW0uY2xhc3NOYW1lO1xuICAgIGlmIChjbGFzc05hbWUgJiYgaXNTdHJpbmcoY2xhc3NOYW1lKSkge1xuICAgICAgY2xhc3NlcyA9IGNsYXNzTmFtZS5zcGxpdCgvXFxzKy8pO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNsYXNzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgb3V0LnB1c2goYC4ke2NsYXNzZXNbaV19YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IGFsbG93ZWRBdHRycyA9IFsnYXJpYS1sYWJlbCcsICd0eXBlJywgJ25hbWUnLCAndGl0bGUnLCAnYWx0J107XG4gIGZvciAoaSA9IDA7IGkgPCBhbGxvd2VkQXR0cnMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBhbGxvd2VkQXR0cnNbaV07XG4gICAgYXR0ciA9IGVsZW0uZ2V0QXR0cmlidXRlKGtleSk7XG4gICAgaWYgKGF0dHIpIHtcbiAgICAgIG91dC5wdXNoKGBbJHtrZXl9PVwiJHthdHRyfVwiXWApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0LmpvaW4oJycpO1xufVxuXG4vKipcbiAqIEEgc2FmZSBmb3JtIG9mIGxvY2F0aW9uLmhyZWZcbiAqL1xuZnVuY3Rpb24gZ2V0TG9jYXRpb25IcmVmKCkge1xuICB0cnkge1xuICAgIHJldHVybiBXSU5ET1cuZG9jdW1lbnQubG9jYXRpb24uaHJlZjtcbiAgfSBjYXRjaCAob08pIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXRzIGEgRE9NIGVsZW1lbnQgYnkgdXNpbmcgZG9jdW1lbnQucXVlcnlTZWxlY3Rvci5cbiAqXG4gKiBUaGlzIHdyYXBwZXIgd2lsbCBmaXJzdCBjaGVjayBmb3IgdGhlIGV4aXN0YW5jZSBvZiB0aGUgZnVuY3Rpb24gYmVmb3JlXG4gKiBhY3R1YWxseSBjYWxsaW5nIGl0IHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZSB0byB0YWtlIGNhcmUgb2YgdGhpcyBjaGVjayxcbiAqIGV2ZXJ5IHRpbWUgd2Ugd2FudCB0byBhY2Nlc3MgdGhlIERPTS5cbiAqXG4gKiBSZWFzb246IERPTS9xdWVyeVNlbGVjdG9yIGlzIG5vdCBhdmFpbGFibGUgaW4gYWxsIGVudmlyb25tZW50cy5cbiAqXG4gKiBXZSBoYXZlIHRvIGNhc3QgdG8gYW55IGJlY2F1c2UgdXRpbHMgY2FuIGJlIGNvbnN1bWVkIGJ5IGEgdmFyaWV0eSBvZiBlbnZpcm9ubWVudHMsXG4gKiBhbmQgd2UgZG9uJ3Qgd2FudCB0byBicmVhayBUUyB1c2Vycy4gSWYgeW91IGtub3cgd2hhdCBlbGVtZW50IHdpbGwgYmUgc2VsZWN0ZWQgYnlcbiAqIGBkb2N1bWVudC5xdWVyeVNlbGVjdG9yYCwgc3BlY2lmeSBpdCBhcyBwYXJ0IG9mIHRoZSBnZW5lcmljIGNhbGwuIEZvciBleGFtcGxlLFxuICogYGNvbnN0IGVsZW1lbnQgPSBnZXREb21FbGVtZW50PEVsZW1lbnQ+KCdzZWxlY3RvcicpO2BcbiAqXG4gKiBAcGFyYW0gc2VsZWN0b3IgdGhlIHNlbGVjdG9yIHN0cmluZyBwYXNzZWQgb24gdG8gZG9jdW1lbnQucXVlcnlTZWxlY3RvclxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gZ2V0RG9tRWxlbWVudChzZWxlY3Rvcikge1xuICBpZiAoV0lORE9XLmRvY3VtZW50ICYmIFdJTkRPVy5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIFdJTkRPVy5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKSA7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBET00gZWxlbWVudCwgdHJhdmVyc2VzIHVwIHRoZSB0cmVlIHVudGlsIGl0IGZpbmRzIHRoZSBmaXJzdCBhbmNlc3RvciBub2RlXG4gKiB0aGF0IGhhcyB0aGUgYGRhdGEtc2VudHJ5LWNvbXBvbmVudGAgYXR0cmlidXRlLiBUaGlzIGF0dHJpYnV0ZSBpcyBhZGRlZCBhdCBidWlsZC10aW1lXG4gKiBieSBwcm9qZWN0cyB0aGF0IGhhdmUgdGhlIGNvbXBvbmVudCBuYW1lIGFubm90YXRpb24gcGx1Z2luIGluc3RhbGxlZC5cbiAqXG4gKiBAcmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgY29tcG9uZW50IGZvciB0aGUgcHJvdmlkZWQgRE9NIGVsZW1lbnQsIG9yIGBudWxsYCBpZiBub3QgZm91bmRcbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZShlbGVtKSB7XG4gIC8vIEB0cy1leHBlY3QtZXJyb3IgV0lORE9XIGhhcyBIVE1MRWxlbWVudFxuICBpZiAoIVdJTkRPVy5IVE1MRWxlbWVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbGV0IGN1cnJlbnRFbGVtID0gZWxlbSA7XG4gIGNvbnN0IE1BWF9UUkFWRVJTRV9IRUlHSFQgPSA1O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IE1BWF9UUkFWRVJTRV9IRUlHSFQ7IGkrKykge1xuICAgIGlmICghY3VycmVudEVsZW0pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChjdXJyZW50RWxlbSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIGN1cnJlbnRFbGVtLmRhdGFzZXRbJ3NlbnRyeUNvbXBvbmVudCddKSB7XG4gICAgICByZXR1cm4gY3VycmVudEVsZW0uZGF0YXNldFsnc2VudHJ5Q29tcG9uZW50J107XG4gICAgfVxuXG4gICAgY3VycmVudEVsZW0gPSBjdXJyZW50RWxlbS5wYXJlbnROb2RlO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCB7IGdldENvbXBvbmVudE5hbWUsIGdldERvbUVsZW1lbnQsIGdldExvY2F0aW9uSHJlZiwgaHRtbFRyZWVBc1N0cmluZyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnJvd3Nlci5qcy5tYXBcbiJdLCJuYW1lcyI6WyJpc1N0cmluZyIsImdldEdsb2JhbE9iamVjdCIsIldJTkRPVyIsIkRFRkFVTFRfTUFYX1NUUklOR19MRU5HVEgiLCJodG1sVHJlZUFzU3RyaW5nIiwiZWxlbSIsIm9wdGlvbnMiLCJjdXJyZW50RWxlbSIsIk1BWF9UUkFWRVJTRV9IRUlHSFQiLCJvdXQiLCJoZWlnaHQiLCJsZW4iLCJzZXBhcmF0b3IiLCJzZXBMZW5ndGgiLCJsZW5ndGgiLCJuZXh0U3RyIiwia2V5QXR0cnMiLCJBcnJheSIsImlzQXJyYXkiLCJtYXhTdHJpbmdMZW5ndGgiLCJfaHRtbEVsZW1lbnRBc1N0cmluZyIsInB1c2giLCJwYXJlbnROb2RlIiwicmV2ZXJzZSIsImpvaW4iLCJfb08iLCJlbCIsImNsYXNzTmFtZSIsImNsYXNzZXMiLCJrZXkiLCJhdHRyIiwiaSIsInRhZ05hbWUiLCJIVE1MRWxlbWVudCIsImRhdGFzZXQiLCJ0b0xvd2VyQ2FzZSIsImtleUF0dHJQYWlycyIsImZpbHRlciIsImtleUF0dHIiLCJnZXRBdHRyaWJ1dGUiLCJtYXAiLCJmb3JFYWNoIiwia2V5QXR0clBhaXIiLCJpZCIsInNwbGl0IiwiYWxsb3dlZEF0dHJzIiwiZ2V0TG9jYXRpb25IcmVmIiwiZG9jdW1lbnQiLCJsb2NhdGlvbiIsImhyZWYiLCJvTyIsImdldERvbUVsZW1lbnQiLCJzZWxlY3RvciIsInF1ZXJ5U2VsZWN0b3IiLCJnZXRDb21wb25lbnROYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/utils/esm/browser.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sentry/utils/esm/debug-build.js":
/*!*******************************************************!*\
  !*** ./node_modules/@sentry/utils/esm/debug-build.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEBUG_BUILD: () => (/* binding */ DEBUG_BUILD)\n/* harmony export */ });\n/**\n * This serves as a build time flag that will be true by default, but false in non-debug builds or if users replace `__SENTRY_DEBUG__` in their generated code.\n *\n * ATTENTION: This constant must never cross package boundaries (i.e. be exported) to guarantee that it can be used for tree shaking.\n */ const DEBUG_BUILD = typeof __SENTRY_DEBUG__ === \"undefined\" || __SENTRY_DEBUG__;\n //# sourceMappingURL=debug-build.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS91dGlscy9lc20vZGVidWctYnVpbGQuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7O0NBSUMsR0FDRCxNQUFNQSxjQUFlLE9BQU9DLHFCQUFxQixlQUFlQTtBQUV6QyxDQUN2Qix1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vYnJhbGluay13ZWIvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS91dGlscy9lc20vZGVidWctYnVpbGQuanM/MTYzOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRoaXMgc2VydmVzIGFzIGEgYnVpbGQgdGltZSBmbGFnIHRoYXQgd2lsbCBiZSB0cnVlIGJ5IGRlZmF1bHQsIGJ1dCBmYWxzZSBpbiBub24tZGVidWcgYnVpbGRzIG9yIGlmIHVzZXJzIHJlcGxhY2UgYF9fU0VOVFJZX0RFQlVHX19gIGluIHRoZWlyIGdlbmVyYXRlZCBjb2RlLlxuICpcbiAqIEFUVEVOVElPTjogVGhpcyBjb25zdGFudCBtdXN0IG5ldmVyIGNyb3NzIHBhY2thZ2UgYm91bmRhcmllcyAoaS5lLiBiZSBleHBvcnRlZCkgdG8gZ3VhcmFudGVlIHRoYXQgaXQgY2FuIGJlIHVzZWQgZm9yIHRyZWUgc2hha2luZy5cbiAqL1xuY29uc3QgREVCVUdfQlVJTEQgPSAodHlwZW9mIF9fU0VOVFJZX0RFQlVHX18gPT09ICd1bmRlZmluZWQnIHx8IF9fU0VOVFJZX0RFQlVHX18pO1xuXG5leHBvcnQgeyBERUJVR19CVUlMRCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVidWctYnVpbGQuanMubWFwXG4iXSwibmFtZXMiOlsiREVCVUdfQlVJTEQiLCJfX1NFTlRSWV9ERUJVR19fIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/utils/esm/debug-build.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sentry/utils/esm/is.js":
/*!**********************************************!*\
  !*** ./node_modules/@sentry/utils/esm/is.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isDOMError: () => (/* binding */ isDOMError),\n/* harmony export */   isDOMException: () => (/* binding */ isDOMException),\n/* harmony export */   isElement: () => (/* binding */ isElement),\n/* harmony export */   isError: () => (/* binding */ isError),\n/* harmony export */   isErrorEvent: () => (/* binding */ isErrorEvent),\n/* harmony export */   isEvent: () => (/* binding */ isEvent),\n/* harmony export */   isInstanceOf: () => (/* binding */ isInstanceOf),\n/* harmony export */   isNaN: () => (/* binding */ isNaN),\n/* harmony export */   isParameterizedString: () => (/* binding */ isParameterizedString),\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   isPrimitive: () => (/* binding */ isPrimitive),\n/* harmony export */   isRegExp: () => (/* binding */ isRegExp),\n/* harmony export */   isString: () => (/* binding */ isString),\n/* harmony export */   isSyntheticEvent: () => (/* binding */ isSyntheticEvent),\n/* harmony export */   isThenable: () => (/* binding */ isThenable),\n/* harmony export */   isVueViewModel: () => (/* binding */ isVueViewModel)\n/* harmony export */ });\n// eslint-disable-next-line @typescript-eslint/unbound-method\nconst objectToString = Object.prototype.toString;\n/**\n * Checks whether given value's type is one of a few Error or Error-like\n * {@link isError}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */ function isError(wat) {\n    switch(objectToString.call(wat)){\n        case \"[object Error]\":\n        case \"[object Exception]\":\n        case \"[object DOMException]\":\n            return true;\n        default:\n            return isInstanceOf(wat, Error);\n    }\n}\n/**\n * Checks whether given value is an instance of the given built-in class.\n *\n * @param wat The value to be checked\n * @param className\n * @returns A boolean representing the result.\n */ function isBuiltin(wat, className) {\n    return objectToString.call(wat) === `[object ${className}]`;\n}\n/**\n * Checks whether given value's type is ErrorEvent\n * {@link isErrorEvent}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */ function isErrorEvent(wat) {\n    return isBuiltin(wat, \"ErrorEvent\");\n}\n/**\n * Checks whether given value's type is DOMError\n * {@link isDOMError}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */ function isDOMError(wat) {\n    return isBuiltin(wat, \"DOMError\");\n}\n/**\n * Checks whether given value's type is DOMException\n * {@link isDOMException}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */ function isDOMException(wat) {\n    return isBuiltin(wat, \"DOMException\");\n}\n/**\n * Checks whether given value's type is a string\n * {@link isString}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */ function isString(wat) {\n    return isBuiltin(wat, \"String\");\n}\n/**\n * Checks whether given string is parameterized\n * {@link isParameterizedString}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */ function isParameterizedString(wat) {\n    return typeof wat === \"object\" && wat !== null && \"__sentry_template_string__\" in wat && \"__sentry_template_values__\" in wat;\n}\n/**\n * Checks whether given value is a primitive (undefined, null, number, boolean, string, bigint, symbol)\n * {@link isPrimitive}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */ function isPrimitive(wat) {\n    return wat === null || isParameterizedString(wat) || typeof wat !== \"object\" && typeof wat !== \"function\";\n}\n/**\n * Checks whether given value's type is an object literal, or a class instance.\n * {@link isPlainObject}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */ function isPlainObject(wat) {\n    return isBuiltin(wat, \"Object\");\n}\n/**\n * Checks whether given value's type is an Event instance\n * {@link isEvent}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */ function isEvent(wat) {\n    return typeof Event !== \"undefined\" && isInstanceOf(wat, Event);\n}\n/**\n * Checks whether given value's type is an Element instance\n * {@link isElement}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */ function isElement(wat) {\n    return typeof Element !== \"undefined\" && isInstanceOf(wat, Element);\n}\n/**\n * Checks whether given value's type is an regexp\n * {@link isRegExp}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */ function isRegExp(wat) {\n    return isBuiltin(wat, \"RegExp\");\n}\n/**\n * Checks whether given value has a then function.\n * @param wat A value to be checked.\n */ function isThenable(wat) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    return Boolean(wat && wat.then && typeof wat.then === \"function\");\n}\n/**\n * Checks whether given value's type is a SyntheticEvent\n * {@link isSyntheticEvent}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */ function isSyntheticEvent(wat) {\n    return isPlainObject(wat) && \"nativeEvent\" in wat && \"preventDefault\" in wat && \"stopPropagation\" in wat;\n}\n/**\n * Checks whether given value is NaN\n * {@link isNaN}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */ function isNaN(wat) {\n    return typeof wat === \"number\" && wat !== wat;\n}\n/**\n * Checks whether given value's type is an instance of provided constructor.\n * {@link isInstanceOf}.\n *\n * @param wat A value to be checked.\n * @param base A constructor to be used in a check.\n * @returns A boolean representing the result.\n */ function isInstanceOf(wat, base) {\n    try {\n        return wat instanceof base;\n    } catch (_e) {\n        return false;\n    }\n}\n/**\n * Checks whether given value's type is a Vue ViewModel.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */ function isVueViewModel(wat) {\n    // Not using Object.prototype.toString because in Vue 3 it would read the instance's Symbol(Symbol.toStringTag) property.\n    return !!(typeof wat === \"object\" && wat !== null && (wat.__isVue || wat._isVue));\n}\n //# sourceMappingURL=is.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS91dGlscy9lc20vaXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDZEQUE2RDtBQUM3RCxNQUFNQSxpQkFBaUJDLE9BQU9DLFNBQVMsQ0FBQ0MsUUFBUTtBQUVoRDs7Ozs7O0NBTUMsR0FDRCxTQUFTQyxRQUFRQyxHQUFHO0lBQ2xCLE9BQVFMLGVBQWVNLElBQUksQ0FBQ0Q7UUFDMUIsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNUO1lBQ0UsT0FBT0UsYUFBYUYsS0FBS0c7SUFDN0I7QUFDRjtBQUNBOzs7Ozs7Q0FNQyxHQUNELFNBQVNDLFVBQVVKLEdBQUcsRUFBRUssU0FBUztJQUMvQixPQUFPVixlQUFlTSxJQUFJLENBQUNELFNBQVMsQ0FBQyxRQUFRLEVBQUVLLFVBQVUsQ0FBQyxDQUFDO0FBQzdEO0FBRUE7Ozs7OztDQU1DLEdBQ0QsU0FBU0MsYUFBYU4sR0FBRztJQUN2QixPQUFPSSxVQUFVSixLQUFLO0FBQ3hCO0FBRUE7Ozs7OztDQU1DLEdBQ0QsU0FBU08sV0FBV1AsR0FBRztJQUNyQixPQUFPSSxVQUFVSixLQUFLO0FBQ3hCO0FBRUE7Ozs7OztDQU1DLEdBQ0QsU0FBU1EsZUFBZVIsR0FBRztJQUN6QixPQUFPSSxVQUFVSixLQUFLO0FBQ3hCO0FBRUE7Ozs7OztDQU1DLEdBQ0QsU0FBU1MsU0FBU1QsR0FBRztJQUNuQixPQUFPSSxVQUFVSixLQUFLO0FBQ3hCO0FBRUE7Ozs7OztDQU1DLEdBQ0QsU0FBU1Usc0JBQXNCVixHQUFHO0lBQ2hDLE9BQ0UsT0FBT0EsUUFBUSxZQUNmQSxRQUFRLFFBQ1IsZ0NBQWdDQSxPQUNoQyxnQ0FBZ0NBO0FBRXBDO0FBRUE7Ozs7OztDQU1DLEdBQ0QsU0FBU1csWUFBWVgsR0FBRztJQUN0QixPQUFPQSxRQUFRLFFBQVFVLHNCQUFzQlYsUUFBUyxPQUFPQSxRQUFRLFlBQVksT0FBT0EsUUFBUTtBQUNsRztBQUVBOzs7Ozs7Q0FNQyxHQUNELFNBQVNZLGNBQWNaLEdBQUc7SUFDeEIsT0FBT0ksVUFBVUosS0FBSztBQUN4QjtBQUVBOzs7Ozs7Q0FNQyxHQUNELFNBQVNhLFFBQVFiLEdBQUc7SUFDbEIsT0FBTyxPQUFPYyxVQUFVLGVBQWVaLGFBQWFGLEtBQUtjO0FBQzNEO0FBRUE7Ozs7OztDQU1DLEdBQ0QsU0FBU0MsVUFBVWYsR0FBRztJQUNwQixPQUFPLE9BQU9nQixZQUFZLGVBQWVkLGFBQWFGLEtBQUtnQjtBQUM3RDtBQUVBOzs7Ozs7Q0FNQyxHQUNELFNBQVNDLFNBQVNqQixHQUFHO0lBQ25CLE9BQU9JLFVBQVVKLEtBQUs7QUFDeEI7QUFFQTs7O0NBR0MsR0FDRCxTQUFTa0IsV0FBV2xCLEdBQUc7SUFDckIsc0VBQXNFO0lBQ3RFLE9BQU9tQixRQUFRbkIsT0FBT0EsSUFBSW9CLElBQUksSUFBSSxPQUFPcEIsSUFBSW9CLElBQUksS0FBSztBQUN4RDtBQUVBOzs7Ozs7Q0FNQyxHQUNELFNBQVNDLGlCQUFpQnJCLEdBQUc7SUFDM0IsT0FBT1ksY0FBY1osUUFBUSxpQkFBaUJBLE9BQU8sb0JBQW9CQSxPQUFPLHFCQUFxQkE7QUFDdkc7QUFFQTs7Ozs7O0NBTUMsR0FDRCxTQUFTc0IsTUFBTXRCLEdBQUc7SUFDaEIsT0FBTyxPQUFPQSxRQUFRLFlBQVlBLFFBQVFBO0FBQzVDO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNELFNBQVNFLGFBQWFGLEdBQUcsRUFBRXVCLElBQUk7SUFDN0IsSUFBSTtRQUNGLE9BQU92QixlQUFldUI7SUFDeEIsRUFBRSxPQUFPQyxJQUFJO1FBQ1gsT0FBTztJQUNUO0FBQ0Y7QUFFQTs7Ozs7Q0FLQyxHQUNELFNBQVNDLGVBQWV6QixHQUFHO0lBQ3pCLHlIQUF5SDtJQUN6SCxPQUFPLENBQUMsQ0FBRSxRQUFPQSxRQUFRLFlBQVlBLFFBQVEsUUFBUyxLQUFPMEIsT0FBTyxJQUFJLElBQU9DLE1BQU07QUFDdkY7QUFFMk4sQ0FDM04sOEJBQThCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb2JyYWxpbmstd2ViLy4vbm9kZV9tb2R1bGVzL0BzZW50cnkvdXRpbHMvZXNtL2lzLmpzP2U1NGYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuY29uc3Qgb2JqZWN0VG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGdpdmVuIHZhbHVlJ3MgdHlwZSBpcyBvbmUgb2YgYSBmZXcgRXJyb3Igb3IgRXJyb3ItbGlrZVxuICoge0BsaW5rIGlzRXJyb3J9LlxuICpcbiAqIEBwYXJhbSB3YXQgQSB2YWx1ZSB0byBiZSBjaGVja2VkLlxuICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB0aGUgcmVzdWx0LlxuICovXG5mdW5jdGlvbiBpc0Vycm9yKHdhdCkge1xuICBzd2l0Y2ggKG9iamVjdFRvU3RyaW5nLmNhbGwod2F0KSkge1xuICAgIGNhc2UgJ1tvYmplY3QgRXJyb3JdJzpcbiAgICBjYXNlICdbb2JqZWN0IEV4Y2VwdGlvbl0nOlxuICAgIGNhc2UgJ1tvYmplY3QgRE9NRXhjZXB0aW9uXSc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGlzSW5zdGFuY2VPZih3YXQsIEVycm9yKTtcbiAgfVxufVxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBnaXZlbiB2YWx1ZSBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgZ2l2ZW4gYnVpbHQtaW4gY2xhc3MuXG4gKlxuICogQHBhcmFtIHdhdCBUaGUgdmFsdWUgdG8gYmUgY2hlY2tlZFxuICogQHBhcmFtIGNsYXNzTmFtZVxuICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB0aGUgcmVzdWx0LlxuICovXG5mdW5jdGlvbiBpc0J1aWx0aW4od2F0LCBjbGFzc05hbWUpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nLmNhbGwod2F0KSA9PT0gYFtvYmplY3QgJHtjbGFzc05hbWV9XWA7XG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgZ2l2ZW4gdmFsdWUncyB0eXBlIGlzIEVycm9yRXZlbnRcbiAqIHtAbGluayBpc0Vycm9yRXZlbnR9LlxuICpcbiAqIEBwYXJhbSB3YXQgQSB2YWx1ZSB0byBiZSBjaGVja2VkLlxuICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB0aGUgcmVzdWx0LlxuICovXG5mdW5jdGlvbiBpc0Vycm9yRXZlbnQod2F0KSB7XG4gIHJldHVybiBpc0J1aWx0aW4od2F0LCAnRXJyb3JFdmVudCcpO1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGdpdmVuIHZhbHVlJ3MgdHlwZSBpcyBET01FcnJvclxuICoge0BsaW5rIGlzRE9NRXJyb3J9LlxuICpcbiAqIEBwYXJhbSB3YXQgQSB2YWx1ZSB0byBiZSBjaGVja2VkLlxuICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB0aGUgcmVzdWx0LlxuICovXG5mdW5jdGlvbiBpc0RPTUVycm9yKHdhdCkge1xuICByZXR1cm4gaXNCdWlsdGluKHdhdCwgJ0RPTUVycm9yJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgZ2l2ZW4gdmFsdWUncyB0eXBlIGlzIERPTUV4Y2VwdGlvblxuICoge0BsaW5rIGlzRE9NRXhjZXB0aW9ufS5cbiAqXG4gKiBAcGFyYW0gd2F0IEEgdmFsdWUgdG8gYmUgY2hlY2tlZC5cbiAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgdGhlIHJlc3VsdC5cbiAqL1xuZnVuY3Rpb24gaXNET01FeGNlcHRpb24od2F0KSB7XG4gIHJldHVybiBpc0J1aWx0aW4od2F0LCAnRE9NRXhjZXB0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgZ2l2ZW4gdmFsdWUncyB0eXBlIGlzIGEgc3RyaW5nXG4gKiB7QGxpbmsgaXNTdHJpbmd9LlxuICpcbiAqIEBwYXJhbSB3YXQgQSB2YWx1ZSB0byBiZSBjaGVja2VkLlxuICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB0aGUgcmVzdWx0LlxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh3YXQpIHtcbiAgcmV0dXJuIGlzQnVpbHRpbih3YXQsICdTdHJpbmcnKTtcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBnaXZlbiBzdHJpbmcgaXMgcGFyYW1ldGVyaXplZFxuICoge0BsaW5rIGlzUGFyYW1ldGVyaXplZFN0cmluZ30uXG4gKlxuICogQHBhcmFtIHdhdCBBIHZhbHVlIHRvIGJlIGNoZWNrZWQuXG4gKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHRoZSByZXN1bHQuXG4gKi9cbmZ1bmN0aW9uIGlzUGFyYW1ldGVyaXplZFN0cmluZyh3YXQpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2Ygd2F0ID09PSAnb2JqZWN0JyAmJlxuICAgIHdhdCAhPT0gbnVsbCAmJlxuICAgICdfX3NlbnRyeV90ZW1wbGF0ZV9zdHJpbmdfXycgaW4gd2F0ICYmXG4gICAgJ19fc2VudHJ5X3RlbXBsYXRlX3ZhbHVlc19fJyBpbiB3YXRcbiAgKTtcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBnaXZlbiB2YWx1ZSBpcyBhIHByaW1pdGl2ZSAodW5kZWZpbmVkLCBudWxsLCBudW1iZXIsIGJvb2xlYW4sIHN0cmluZywgYmlnaW50LCBzeW1ib2wpXG4gKiB7QGxpbmsgaXNQcmltaXRpdmV9LlxuICpcbiAqIEBwYXJhbSB3YXQgQSB2YWx1ZSB0byBiZSBjaGVja2VkLlxuICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB0aGUgcmVzdWx0LlxuICovXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZSh3YXQpIHtcbiAgcmV0dXJuIHdhdCA9PT0gbnVsbCB8fCBpc1BhcmFtZXRlcml6ZWRTdHJpbmcod2F0KSB8fCAodHlwZW9mIHdhdCAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIHdhdCAhPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgZ2l2ZW4gdmFsdWUncyB0eXBlIGlzIGFuIG9iamVjdCBsaXRlcmFsLCBvciBhIGNsYXNzIGluc3RhbmNlLlxuICoge0BsaW5rIGlzUGxhaW5PYmplY3R9LlxuICpcbiAqIEBwYXJhbSB3YXQgQSB2YWx1ZSB0byBiZSBjaGVja2VkLlxuICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB0aGUgcmVzdWx0LlxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHdhdCkge1xuICByZXR1cm4gaXNCdWlsdGluKHdhdCwgJ09iamVjdCcpO1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGdpdmVuIHZhbHVlJ3MgdHlwZSBpcyBhbiBFdmVudCBpbnN0YW5jZVxuICoge0BsaW5rIGlzRXZlbnR9LlxuICpcbiAqIEBwYXJhbSB3YXQgQSB2YWx1ZSB0byBiZSBjaGVja2VkLlxuICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB0aGUgcmVzdWx0LlxuICovXG5mdW5jdGlvbiBpc0V2ZW50KHdhdCkge1xuICByZXR1cm4gdHlwZW9mIEV2ZW50ICE9PSAndW5kZWZpbmVkJyAmJiBpc0luc3RhbmNlT2Yod2F0LCBFdmVudCk7XG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgZ2l2ZW4gdmFsdWUncyB0eXBlIGlzIGFuIEVsZW1lbnQgaW5zdGFuY2VcbiAqIHtAbGluayBpc0VsZW1lbnR9LlxuICpcbiAqIEBwYXJhbSB3YXQgQSB2YWx1ZSB0byBiZSBjaGVja2VkLlxuICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB0aGUgcmVzdWx0LlxuICovXG5mdW5jdGlvbiBpc0VsZW1lbnQod2F0KSB7XG4gIHJldHVybiB0eXBlb2YgRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNJbnN0YW5jZU9mKHdhdCwgRWxlbWVudCk7XG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgZ2l2ZW4gdmFsdWUncyB0eXBlIGlzIGFuIHJlZ2V4cFxuICoge0BsaW5rIGlzUmVnRXhwfS5cbiAqXG4gKiBAcGFyYW0gd2F0IEEgdmFsdWUgdG8gYmUgY2hlY2tlZC5cbiAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgdGhlIHJlc3VsdC5cbiAqL1xuZnVuY3Rpb24gaXNSZWdFeHAod2F0KSB7XG4gIHJldHVybiBpc0J1aWx0aW4od2F0LCAnUmVnRXhwJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgZ2l2ZW4gdmFsdWUgaGFzIGEgdGhlbiBmdW5jdGlvbi5cbiAqIEBwYXJhbSB3YXQgQSB2YWx1ZSB0byBiZSBjaGVja2VkLlxuICovXG5mdW5jdGlvbiBpc1RoZW5hYmxlKHdhdCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gIHJldHVybiBCb29sZWFuKHdhdCAmJiB3YXQudGhlbiAmJiB0eXBlb2Ygd2F0LnRoZW4gPT09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGdpdmVuIHZhbHVlJ3MgdHlwZSBpcyBhIFN5bnRoZXRpY0V2ZW50XG4gKiB7QGxpbmsgaXNTeW50aGV0aWNFdmVudH0uXG4gKlxuICogQHBhcmFtIHdhdCBBIHZhbHVlIHRvIGJlIGNoZWNrZWQuXG4gKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHRoZSByZXN1bHQuXG4gKi9cbmZ1bmN0aW9uIGlzU3ludGhldGljRXZlbnQod2F0KSB7XG4gIHJldHVybiBpc1BsYWluT2JqZWN0KHdhdCkgJiYgJ25hdGl2ZUV2ZW50JyBpbiB3YXQgJiYgJ3ByZXZlbnREZWZhdWx0JyBpbiB3YXQgJiYgJ3N0b3BQcm9wYWdhdGlvbicgaW4gd2F0O1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGdpdmVuIHZhbHVlIGlzIE5hTlxuICoge0BsaW5rIGlzTmFOfS5cbiAqXG4gKiBAcGFyYW0gd2F0IEEgdmFsdWUgdG8gYmUgY2hlY2tlZC5cbiAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgdGhlIHJlc3VsdC5cbiAqL1xuZnVuY3Rpb24gaXNOYU4od2F0KSB7XG4gIHJldHVybiB0eXBlb2Ygd2F0ID09PSAnbnVtYmVyJyAmJiB3YXQgIT09IHdhdDtcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBnaXZlbiB2YWx1ZSdzIHR5cGUgaXMgYW4gaW5zdGFuY2Ugb2YgcHJvdmlkZWQgY29uc3RydWN0b3IuXG4gKiB7QGxpbmsgaXNJbnN0YW5jZU9mfS5cbiAqXG4gKiBAcGFyYW0gd2F0IEEgdmFsdWUgdG8gYmUgY2hlY2tlZC5cbiAqIEBwYXJhbSBiYXNlIEEgY29uc3RydWN0b3IgdG8gYmUgdXNlZCBpbiBhIGNoZWNrLlxuICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB0aGUgcmVzdWx0LlxuICovXG5mdW5jdGlvbiBpc0luc3RhbmNlT2Yod2F0LCBiYXNlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdhdCBpbnN0YW5jZW9mIGJhc2U7XG4gIH0gY2F0Y2ggKF9lKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgZ2l2ZW4gdmFsdWUncyB0eXBlIGlzIGEgVnVlIFZpZXdNb2RlbC5cbiAqXG4gKiBAcGFyYW0gd2F0IEEgdmFsdWUgdG8gYmUgY2hlY2tlZC5cbiAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgdGhlIHJlc3VsdC5cbiAqL1xuZnVuY3Rpb24gaXNWdWVWaWV3TW9kZWwod2F0KSB7XG4gIC8vIE5vdCB1c2luZyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nIGJlY2F1c2UgaW4gVnVlIDMgaXQgd291bGQgcmVhZCB0aGUgaW5zdGFuY2UncyBTeW1ib2woU3ltYm9sLnRvU3RyaW5nVGFnKSBwcm9wZXJ0eS5cbiAgcmV0dXJuICEhKHR5cGVvZiB3YXQgPT09ICdvYmplY3QnICYmIHdhdCAhPT0gbnVsbCAmJiAoKHdhdCApLl9faXNWdWUgfHwgKHdhdCApLl9pc1Z1ZSkpO1xufVxuXG5leHBvcnQgeyBpc0RPTUVycm9yLCBpc0RPTUV4Y2VwdGlvbiwgaXNFbGVtZW50LCBpc0Vycm9yLCBpc0Vycm9yRXZlbnQsIGlzRXZlbnQsIGlzSW5zdGFuY2VPZiwgaXNOYU4sIGlzUGFyYW1ldGVyaXplZFN0cmluZywgaXNQbGFpbk9iamVjdCwgaXNQcmltaXRpdmUsIGlzUmVnRXhwLCBpc1N0cmluZywgaXNTeW50aGV0aWNFdmVudCwgaXNUaGVuYWJsZSwgaXNWdWVWaWV3TW9kZWwgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLmpzLm1hcFxuIl0sIm5hbWVzIjpbIm9iamVjdFRvU3RyaW5nIiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJpc0Vycm9yIiwid2F0IiwiY2FsbCIsImlzSW5zdGFuY2VPZiIsIkVycm9yIiwiaXNCdWlsdGluIiwiY2xhc3NOYW1lIiwiaXNFcnJvckV2ZW50IiwiaXNET01FcnJvciIsImlzRE9NRXhjZXB0aW9uIiwiaXNTdHJpbmciLCJpc1BhcmFtZXRlcml6ZWRTdHJpbmciLCJpc1ByaW1pdGl2ZSIsImlzUGxhaW5PYmplY3QiLCJpc0V2ZW50IiwiRXZlbnQiLCJpc0VsZW1lbnQiLCJFbGVtZW50IiwiaXNSZWdFeHAiLCJpc1RoZW5hYmxlIiwiQm9vbGVhbiIsInRoZW4iLCJpc1N5bnRoZXRpY0V2ZW50IiwiaXNOYU4iLCJiYXNlIiwiX2UiLCJpc1Z1ZVZpZXdNb2RlbCIsIl9faXNWdWUiLCJfaXNWdWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/utils/esm/is.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sentry/utils/esm/logger.js":
/*!**************************************************!*\
  !*** ./node_modules/@sentry/utils/esm/logger.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CONSOLE_LEVELS: () => (/* binding */ CONSOLE_LEVELS),\n/* harmony export */   consoleSandbox: () => (/* binding */ consoleSandbox),\n/* harmony export */   logger: () => (/* binding */ logger),\n/* harmony export */   originalConsoleMethods: () => (/* binding */ originalConsoleMethods)\n/* harmony export */ });\n/* harmony import */ var _debug_build_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./debug-build.js */ \"(ssr)/./node_modules/@sentry/utils/esm/debug-build.js\");\n/* harmony import */ var _worldwide_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./worldwide.js */ \"(ssr)/./node_modules/@sentry/utils/esm/worldwide.js\");\n\n\n/** Prefix for logging strings */ const PREFIX = \"Sentry Logger \";\nconst CONSOLE_LEVELS = [\n    \"debug\",\n    \"info\",\n    \"warn\",\n    \"error\",\n    \"log\",\n    \"assert\",\n    \"trace\"\n];\n/** This may be mutated by the console instrumentation. */ const originalConsoleMethods = {};\n/** JSDoc */ /**\n * Temporarily disable sentry console instrumentations.\n *\n * @param callback The function to run against the original `console` messages\n * @returns The results of the callback\n */ function consoleSandbox(callback) {\n    if (!(\"console\" in _worldwide_js__WEBPACK_IMPORTED_MODULE_0__.GLOBAL_OBJ)) {\n        return callback();\n    }\n    const console = _worldwide_js__WEBPACK_IMPORTED_MODULE_0__.GLOBAL_OBJ.console;\n    const wrappedFuncs = {};\n    const wrappedLevels = Object.keys(originalConsoleMethods);\n    // Restore all wrapped console methods\n    wrappedLevels.forEach((level)=>{\n        const originalConsoleMethod = originalConsoleMethods[level];\n        wrappedFuncs[level] = console[level];\n        console[level] = originalConsoleMethod;\n    });\n    try {\n        return callback();\n    } finally{\n        // Revert restoration to wrapped state\n        wrappedLevels.forEach((level)=>{\n            console[level] = wrappedFuncs[level];\n        });\n    }\n}\nfunction makeLogger() {\n    let enabled = false;\n    const logger = {\n        enable: ()=>{\n            enabled = true;\n        },\n        disable: ()=>{\n            enabled = false;\n        },\n        isEnabled: ()=>enabled\n    };\n    if (_debug_build_js__WEBPACK_IMPORTED_MODULE_1__.DEBUG_BUILD) {\n        CONSOLE_LEVELS.forEach((name)=>{\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            logger[name] = (...args)=>{\n                if (enabled) {\n                    consoleSandbox(()=>{\n                        _worldwide_js__WEBPACK_IMPORTED_MODULE_0__.GLOBAL_OBJ.console[name](`${PREFIX}[${name}]:`, ...args);\n                    });\n                }\n            };\n        });\n    } else {\n        CONSOLE_LEVELS.forEach((name)=>{\n            logger[name] = ()=>undefined;\n        });\n    }\n    return logger;\n}\nconst logger = makeLogger();\n //# sourceMappingURL=logger.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS91dGlscy9lc20vbG9nZ2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUErQztBQUNIO0FBRTVDLCtCQUErQixHQUMvQixNQUFNRSxTQUFTO0FBRWYsTUFBTUMsaUJBQWlCO0lBQ3JCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0Q7QUFFRCx3REFBd0QsR0FDeEQsTUFBTUMseUJBRUgsQ0FBQztBQUVKLFVBQVUsR0FFVjs7Ozs7Q0FLQyxHQUNELFNBQVNDLGVBQWVDLFFBQVE7SUFDOUIsSUFBSSxDQUFFLG1FQUFzQixHQUFJO1FBQzlCLE9BQU9BO0lBQ1Q7SUFFQSxNQUFNQyxVQUFVTixxREFBVUEsQ0FBQ00sT0FBTztJQUNsQyxNQUFNQyxlQUFlLENBQUM7SUFFdEIsTUFBTUMsZ0JBQWdCQyxPQUFPQyxJQUFJLENBQUNQO0lBRWxDLHNDQUFzQztJQUN0Q0ssY0FBY0csT0FBTyxDQUFDQyxDQUFBQTtRQUNwQixNQUFNQyx3QkFBd0JWLHNCQUFzQixDQUFDUyxNQUFNO1FBQzNETCxZQUFZLENBQUNLLE1BQU0sR0FBR04sT0FBTyxDQUFDTSxNQUFNO1FBQ3BDTixPQUFPLENBQUNNLE1BQU0sR0FBR0M7SUFDbkI7SUFFQSxJQUFJO1FBQ0YsT0FBT1I7SUFDVCxTQUFVO1FBQ1Isc0NBQXNDO1FBQ3RDRyxjQUFjRyxPQUFPLENBQUNDLENBQUFBO1lBQ3BCTixPQUFPLENBQUNNLE1BQU0sR0FBR0wsWUFBWSxDQUFDSyxNQUFNO1FBQ3RDO0lBQ0Y7QUFDRjtBQUVBLFNBQVNFO0lBQ1AsSUFBSUMsVUFBVTtJQUNkLE1BQU1DLFNBQVM7UUFDYkMsUUFBUTtZQUNORixVQUFVO1FBQ1o7UUFDQUcsU0FBUztZQUNQSCxVQUFVO1FBQ1o7UUFDQUksV0FBVyxJQUFNSjtJQUNuQjtJQUVBLElBQUloQix3REFBV0EsRUFBRTtRQUNmRyxlQUFlUyxPQUFPLENBQUNTLENBQUFBO1lBQ3JCLDhEQUE4RDtZQUM5REosTUFBTSxDQUFDSSxLQUFLLEdBQUcsQ0FBQyxHQUFHQztnQkFDakIsSUFBSU4sU0FBUztvQkFDWFgsZUFBZTt3QkFDYkoscURBQVVBLENBQUNNLE9BQU8sQ0FBQ2MsS0FBSyxDQUFDLENBQUMsRUFBRW5CLE9BQU8sQ0FBQyxFQUFFbUIsS0FBSyxFQUFFLENBQUMsS0FBS0M7b0JBQ3JEO2dCQUNGO1lBQ0Y7UUFDRjtJQUNGLE9BQU87UUFDTG5CLGVBQWVTLE9BQU8sQ0FBQ1MsQ0FBQUE7WUFDckJKLE1BQU0sQ0FBQ0ksS0FBSyxHQUFHLElBQU1FO1FBQ3ZCO0lBQ0Y7SUFFQSxPQUFPTjtBQUNUO0FBRUEsTUFBTUEsU0FBU0Y7QUFFMkQsQ0FDMUUsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb2JyYWxpbmstd2ViLy4vbm9kZV9tb2R1bGVzL0BzZW50cnkvdXRpbHMvZXNtL2xvZ2dlci5qcz84Y2NlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERFQlVHX0JVSUxEIH0gZnJvbSAnLi9kZWJ1Zy1idWlsZC5qcyc7XG5pbXBvcnQgeyBHTE9CQUxfT0JKIH0gZnJvbSAnLi93b3JsZHdpZGUuanMnO1xuXG4vKiogUHJlZml4IGZvciBsb2dnaW5nIHN0cmluZ3MgKi9cbmNvbnN0IFBSRUZJWCA9ICdTZW50cnkgTG9nZ2VyICc7XG5cbmNvbnN0IENPTlNPTEVfTEVWRUxTID0gW1xuICAnZGVidWcnLFxuICAnaW5mbycsXG4gICd3YXJuJyxcbiAgJ2Vycm9yJyxcbiAgJ2xvZycsXG4gICdhc3NlcnQnLFxuICAndHJhY2UnLFxuXSA7XG5cbi8qKiBUaGlzIG1heSBiZSBtdXRhdGVkIGJ5IHRoZSBjb25zb2xlIGluc3RydW1lbnRhdGlvbi4gKi9cbmNvbnN0IG9yaWdpbmFsQ29uc29sZU1ldGhvZHNcblxuID0ge307XG5cbi8qKiBKU0RvYyAqL1xuXG4vKipcbiAqIFRlbXBvcmFyaWx5IGRpc2FibGUgc2VudHJ5IGNvbnNvbGUgaW5zdHJ1bWVudGF0aW9ucy5cbiAqXG4gKiBAcGFyYW0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIHJ1biBhZ2FpbnN0IHRoZSBvcmlnaW5hbCBgY29uc29sZWAgbWVzc2FnZXNcbiAqIEByZXR1cm5zIFRoZSByZXN1bHRzIG9mIHRoZSBjYWxsYmFja1xuICovXG5mdW5jdGlvbiBjb25zb2xlU2FuZGJveChjYWxsYmFjaykge1xuICBpZiAoISgnY29uc29sZScgaW4gR0xPQkFMX09CSikpIHtcbiAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgfVxuXG4gIGNvbnN0IGNvbnNvbGUgPSBHTE9CQUxfT0JKLmNvbnNvbGUgO1xuICBjb25zdCB3cmFwcGVkRnVuY3MgPSB7fTtcblxuICBjb25zdCB3cmFwcGVkTGV2ZWxzID0gT2JqZWN0LmtleXMob3JpZ2luYWxDb25zb2xlTWV0aG9kcykgO1xuXG4gIC8vIFJlc3RvcmUgYWxsIHdyYXBwZWQgY29uc29sZSBtZXRob2RzXG4gIHdyYXBwZWRMZXZlbHMuZm9yRWFjaChsZXZlbCA9PiB7XG4gICAgY29uc3Qgb3JpZ2luYWxDb25zb2xlTWV0aG9kID0gb3JpZ2luYWxDb25zb2xlTWV0aG9kc1tsZXZlbF0gO1xuICAgIHdyYXBwZWRGdW5jc1tsZXZlbF0gPSBjb25zb2xlW2xldmVsXSA7XG4gICAgY29uc29sZVtsZXZlbF0gPSBvcmlnaW5hbENvbnNvbGVNZXRob2Q7XG4gIH0pO1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gIH0gZmluYWxseSB7XG4gICAgLy8gUmV2ZXJ0IHJlc3RvcmF0aW9uIHRvIHdyYXBwZWQgc3RhdGVcbiAgICB3cmFwcGVkTGV2ZWxzLmZvckVhY2gobGV2ZWwgPT4ge1xuICAgICAgY29uc29sZVtsZXZlbF0gPSB3cmFwcGVkRnVuY3NbbGV2ZWxdIDtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlTG9nZ2VyKCkge1xuICBsZXQgZW5hYmxlZCA9IGZhbHNlO1xuICBjb25zdCBsb2dnZXIgPSB7XG4gICAgZW5hYmxlOiAoKSA9PiB7XG4gICAgICBlbmFibGVkID0gdHJ1ZTtcbiAgICB9LFxuICAgIGRpc2FibGU6ICgpID0+IHtcbiAgICAgIGVuYWJsZWQgPSBmYWxzZTtcbiAgICB9LFxuICAgIGlzRW5hYmxlZDogKCkgPT4gZW5hYmxlZCxcbiAgfTtcblxuICBpZiAoREVCVUdfQlVJTEQpIHtcbiAgICBDT05TT0xFX0xFVkVMUy5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgIGxvZ2dlcltuYW1lXSA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgICAgY29uc29sZVNhbmRib3goKCkgPT4ge1xuICAgICAgICAgICAgR0xPQkFMX09CSi5jb25zb2xlW25hbWVdKGAke1BSRUZJWH1bJHtuYW1lfV06YCwgLi4uYXJncyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgQ09OU09MRV9MRVZFTFMuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgIGxvZ2dlcltuYW1lXSA9ICgpID0+IHVuZGVmaW5lZDtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBsb2dnZXIgO1xufVxuXG5jb25zdCBsb2dnZXIgPSBtYWtlTG9nZ2VyKCk7XG5cbmV4cG9ydCB7IENPTlNPTEVfTEVWRUxTLCBjb25zb2xlU2FuZGJveCwgbG9nZ2VyLCBvcmlnaW5hbENvbnNvbGVNZXRob2RzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2dnZXIuanMubWFwXG4iXSwibmFtZXMiOlsiREVCVUdfQlVJTEQiLCJHTE9CQUxfT0JKIiwiUFJFRklYIiwiQ09OU09MRV9MRVZFTFMiLCJvcmlnaW5hbENvbnNvbGVNZXRob2RzIiwiY29uc29sZVNhbmRib3giLCJjYWxsYmFjayIsImNvbnNvbGUiLCJ3cmFwcGVkRnVuY3MiLCJ3cmFwcGVkTGV2ZWxzIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJsZXZlbCIsIm9yaWdpbmFsQ29uc29sZU1ldGhvZCIsIm1ha2VMb2dnZXIiLCJlbmFibGVkIiwibG9nZ2VyIiwiZW5hYmxlIiwiZGlzYWJsZSIsImlzRW5hYmxlZCIsIm5hbWUiLCJhcmdzIiwidW5kZWZpbmVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/utils/esm/logger.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sentry/utils/esm/memo.js":
/*!************************************************!*\
  !*** ./node_modules/@sentry/utils/esm/memo.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   memoBuilder: () => (/* binding */ memoBuilder)\n/* harmony export */ });\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */ /* eslint-disable @typescript-eslint/no-explicit-any */ /**\n * Helper to decycle json objects\n */ function memoBuilder() {\n    const hasWeakSet = typeof WeakSet === \"function\";\n    const inner = hasWeakSet ? new WeakSet() : [];\n    function memoize(obj) {\n        if (hasWeakSet) {\n            if (inner.has(obj)) {\n                return true;\n            }\n            inner.add(obj);\n            return false;\n        }\n        // eslint-disable-next-line @typescript-eslint/prefer-for-of\n        for(let i = 0; i < inner.length; i++){\n            const value = inner[i];\n            if (value === obj) {\n                return true;\n            }\n        }\n        inner.push(obj);\n        return false;\n    }\n    function unmemoize(obj) {\n        if (hasWeakSet) {\n            inner.delete(obj);\n        } else {\n            for(let i = 0; i < inner.length; i++){\n                if (inner[i] === obj) {\n                    inner.splice(i, 1);\n                    break;\n                }\n            }\n        }\n    }\n    return [\n        memoize,\n        unmemoize\n    ];\n}\n //# sourceMappingURL=memo.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS91dGlscy9lc20vbWVtby5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsNkRBQTZELEdBQzdELHFEQUFxRCxHQUVyRDs7Q0FFQyxHQUNELFNBQVNBO0lBQ1AsTUFBTUMsYUFBYSxPQUFPQyxZQUFZO0lBQ3RDLE1BQU1DLFFBQVFGLGFBQWEsSUFBSUMsWUFBWSxFQUFFO0lBQzdDLFNBQVNFLFFBQVFDLEdBQUc7UUFDbEIsSUFBSUosWUFBWTtZQUNkLElBQUlFLE1BQU1HLEdBQUcsQ0FBQ0QsTUFBTTtnQkFDbEIsT0FBTztZQUNUO1lBQ0FGLE1BQU1JLEdBQUcsQ0FBQ0Y7WUFDVixPQUFPO1FBQ1Q7UUFDQSw0REFBNEQ7UUFDNUQsSUFBSyxJQUFJRyxJQUFJLEdBQUdBLElBQUlMLE1BQU1NLE1BQU0sRUFBRUQsSUFBSztZQUNyQyxNQUFNRSxRQUFRUCxLQUFLLENBQUNLLEVBQUU7WUFDdEIsSUFBSUUsVUFBVUwsS0FBSztnQkFDakIsT0FBTztZQUNUO1FBQ0Y7UUFDQUYsTUFBTVEsSUFBSSxDQUFDTjtRQUNYLE9BQU87SUFDVDtJQUVBLFNBQVNPLFVBQVVQLEdBQUc7UUFDcEIsSUFBSUosWUFBWTtZQUNkRSxNQUFNVSxNQUFNLENBQUNSO1FBQ2YsT0FBTztZQUNMLElBQUssSUFBSUcsSUFBSSxHQUFHQSxJQUFJTCxNQUFNTSxNQUFNLEVBQUVELElBQUs7Z0JBQ3JDLElBQUlMLEtBQUssQ0FBQ0ssRUFBRSxLQUFLSCxLQUFLO29CQUNwQkYsTUFBTVcsTUFBTSxDQUFDTixHQUFHO29CQUNoQjtnQkFDRjtZQUNGO1FBQ0Y7SUFDRjtJQUNBLE9BQU87UUFBQ0o7UUFBU1E7S0FBVTtBQUM3QjtBQUV1QixDQUN2QixnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vYnJhbGluay13ZWIvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS91dGlscy9lc20vbWVtby5qcz9jZGQ5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcyAqL1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuXG4vKipcbiAqIEhlbHBlciB0byBkZWN5Y2xlIGpzb24gb2JqZWN0c1xuICovXG5mdW5jdGlvbiBtZW1vQnVpbGRlcigpIHtcbiAgY29uc3QgaGFzV2Vha1NldCA9IHR5cGVvZiBXZWFrU2V0ID09PSAnZnVuY3Rpb24nO1xuICBjb25zdCBpbm5lciA9IGhhc1dlYWtTZXQgPyBuZXcgV2Vha1NldCgpIDogW107XG4gIGZ1bmN0aW9uIG1lbW9pemUob2JqKSB7XG4gICAgaWYgKGhhc1dlYWtTZXQpIHtcbiAgICAgIGlmIChpbm5lci5oYXMob2JqKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlubmVyLmFkZChvYmopO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3ByZWZlci1mb3Itb2ZcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlubmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGlubmVyW2ldO1xuICAgICAgaWYgKHZhbHVlID09PSBvYmopIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlubmVyLnB1c2gob2JqKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiB1bm1lbW9pemUob2JqKSB7XG4gICAgaWYgKGhhc1dlYWtTZXQpIHtcbiAgICAgIGlubmVyLmRlbGV0ZShvYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlubmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpbm5lcltpXSA9PT0gb2JqKSB7XG4gICAgICAgICAgaW5uZXIuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBbbWVtb2l6ZSwgdW5tZW1vaXplXTtcbn1cblxuZXhwb3J0IHsgbWVtb0J1aWxkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lbW8uanMubWFwXG4iXSwibmFtZXMiOlsibWVtb0J1aWxkZXIiLCJoYXNXZWFrU2V0IiwiV2Vha1NldCIsImlubmVyIiwibWVtb2l6ZSIsIm9iaiIsImhhcyIsImFkZCIsImkiLCJsZW5ndGgiLCJ2YWx1ZSIsInB1c2giLCJ1bm1lbW9pemUiLCJkZWxldGUiLCJzcGxpY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/utils/esm/memo.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sentry/utils/esm/misc.js":
/*!************************************************!*\
  !*** ./node_modules/@sentry/utils/esm/misc.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addContextToFrame: () => (/* binding */ addContextToFrame),\n/* harmony export */   addExceptionMechanism: () => (/* binding */ addExceptionMechanism),\n/* harmony export */   addExceptionTypeValue: () => (/* binding */ addExceptionTypeValue),\n/* harmony export */   arrayify: () => (/* binding */ arrayify),\n/* harmony export */   checkOrSetAlreadyCaught: () => (/* binding */ checkOrSetAlreadyCaught),\n/* harmony export */   getEventDescription: () => (/* binding */ getEventDescription),\n/* harmony export */   parseSemver: () => (/* binding */ parseSemver),\n/* harmony export */   uuid4: () => (/* binding */ uuid4)\n/* harmony export */ });\n/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./object.js */ \"(ssr)/./node_modules/@sentry/utils/esm/object.js\");\n/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./string.js */ \"(ssr)/./node_modules/@sentry/utils/esm/string.js\");\n/* harmony import */ var _worldwide_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./worldwide.js */ \"(ssr)/./node_modules/@sentry/utils/esm/worldwide.js\");\n\n\n\n/**\n * UUID4 generator\n *\n * @returns string Generated UUID4.\n */ function uuid4() {\n    const gbl = _worldwide_js__WEBPACK_IMPORTED_MODULE_0__.GLOBAL_OBJ;\n    const crypto = gbl.crypto || gbl.msCrypto;\n    let getRandomByte = ()=>Math.random() * 16;\n    try {\n        if (crypto && crypto.randomUUID) {\n            return crypto.randomUUID().replace(/-/g, \"\");\n        }\n        if (crypto && crypto.getRandomValues) {\n            getRandomByte = ()=>{\n                // crypto.getRandomValues might return undefined instead of the typed array\n                // in old Chromium versions (e.g. 23.0.1235.0 (151422))\n                // However, `typedArray` is still filled in-place.\n                // @see https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues#typedarray\n                const typedArray = new Uint8Array(1);\n                crypto.getRandomValues(typedArray);\n                return typedArray[0];\n            };\n        }\n    } catch (_) {\n    // some runtimes can crash invoking crypto\n    // https://github.com/getsentry/sentry-javascript/issues/8935\n    }\n    // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523\n    // Concatenating the following numbers as strings results in '10000000100040008000100000000000'\n    return ([\n        1e7\n    ] + 1e3 + 4e3 + 8e3 + 1e11).replace(/[018]/g, (c)=>// eslint-disable-next-line no-bitwise\n        (c ^ (getRandomByte() & 15) >> c / 4).toString(16));\n}\nfunction getFirstException(event) {\n    return event.exception && event.exception.values ? event.exception.values[0] : undefined;\n}\n/**\n * Extracts either message or type+value from an event that can be used for user-facing logs\n * @returns event's description\n */ function getEventDescription(event) {\n    const { message, event_id: eventId } = event;\n    if (message) {\n        return message;\n    }\n    const firstException = getFirstException(event);\n    if (firstException) {\n        if (firstException.type && firstException.value) {\n            return `${firstException.type}: ${firstException.value}`;\n        }\n        return firstException.type || firstException.value || eventId || \"<unknown>\";\n    }\n    return eventId || \"<unknown>\";\n}\n/**\n * Adds exception values, type and value to an synthetic Exception.\n * @param event The event to modify.\n * @param value Value of the exception.\n * @param type Type of the exception.\n * @hidden\n */ function addExceptionTypeValue(event, value, type) {\n    const exception = event.exception = event.exception || {};\n    const values = exception.values = exception.values || [];\n    const firstException = values[0] = values[0] || {};\n    if (!firstException.value) {\n        firstException.value = value || \"\";\n    }\n    if (!firstException.type) {\n        firstException.type = type || \"Error\";\n    }\n}\n/**\n * Adds exception mechanism data to a given event. Uses defaults if the second parameter is not passed.\n *\n * @param event The event to modify.\n * @param newMechanism Mechanism data to add to the event.\n * @hidden\n */ function addExceptionMechanism(event, newMechanism) {\n    const firstException = getFirstException(event);\n    if (!firstException) {\n        return;\n    }\n    const defaultMechanism = {\n        type: \"generic\",\n        handled: true\n    };\n    const currentMechanism = firstException.mechanism;\n    firstException.mechanism = {\n        ...defaultMechanism,\n        ...currentMechanism,\n        ...newMechanism\n    };\n    if (newMechanism && \"data\" in newMechanism) {\n        const mergedData = {\n            ...currentMechanism && currentMechanism.data,\n            ...newMechanism.data\n        };\n        firstException.mechanism.data = mergedData;\n    }\n}\n// https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\nconst SEMVER_REGEXP = /^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$/;\n/**\n * Represents Semantic Versioning object\n */ /**\n * Parses input into a SemVer interface\n * @param input string representation of a semver version\n */ function parseSemver(input) {\n    const match = input.match(SEMVER_REGEXP) || [];\n    const major = parseInt(match[1], 10);\n    const minor = parseInt(match[2], 10);\n    const patch = parseInt(match[3], 10);\n    return {\n        buildmetadata: match[5],\n        major: isNaN(major) ? undefined : major,\n        minor: isNaN(minor) ? undefined : minor,\n        patch: isNaN(patch) ? undefined : patch,\n        prerelease: match[4]\n    };\n}\n/**\n * This function adds context (pre/post/line) lines to the provided frame\n *\n * @param lines string[] containing all lines\n * @param frame StackFrame that will be mutated\n * @param linesOfContext number of context lines we want to add pre/post\n */ function addContextToFrame(lines, frame, linesOfContext = 5) {\n    // When there is no line number in the frame, attaching context is nonsensical and will even break grouping\n    if (frame.lineno === undefined) {\n        return;\n    }\n    const maxLines = lines.length;\n    const sourceLine = Math.max(Math.min(maxLines - 1, frame.lineno - 1), 0);\n    frame.pre_context = lines.slice(Math.max(0, sourceLine - linesOfContext), sourceLine).map((line)=>(0,_string_js__WEBPACK_IMPORTED_MODULE_1__.snipLine)(line, 0));\n    frame.context_line = (0,_string_js__WEBPACK_IMPORTED_MODULE_1__.snipLine)(lines[Math.min(maxLines - 1, sourceLine)], frame.colno || 0);\n    frame.post_context = lines.slice(Math.min(sourceLine + 1, maxLines), sourceLine + 1 + linesOfContext).map((line)=>(0,_string_js__WEBPACK_IMPORTED_MODULE_1__.snipLine)(line, 0));\n}\n/**\n * Checks whether or not we've already captured the given exception (note: not an identical exception - the very object\n * in question), and marks it captured if not.\n *\n * This is useful because it's possible for an error to get captured by more than one mechanism. After we intercept and\n * record an error, we rethrow it (assuming we've intercepted it before it's reached the top-level global handlers), so\n * that we don't interfere with whatever effects the error might have had were the SDK not there. At that point, because\n * the error has been rethrown, it's possible for it to bubble up to some other code we've instrumented. If it's not\n * caught after that, it will bubble all the way up to the global handlers (which of course we also instrument). This\n * function helps us ensure that even if we encounter the same error more than once, we only record it the first time we\n * see it.\n *\n * Note: It will ignore primitives (always return `false` and not mark them as seen), as properties can't be set on\n * them. {@link: Object.objectify} can be used on exceptions to convert any that are primitives into their equivalent\n * object wrapper forms so that this check will always work. However, because we need to flag the exact object which\n * will get rethrown, and because that rethrowing happens outside of the event processing pipeline, the objectification\n * must be done before the exception captured.\n *\n * @param A thrown exception to check or flag as having been seen\n * @returns `true` if the exception has already been captured, `false` if not (with the side effect of marking it seen)\n */ function checkOrSetAlreadyCaught(exception) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    if (exception && exception.__sentry_captured__) {\n        return true;\n    }\n    try {\n        // set it this way rather than by assignment so that it's not ennumerable and therefore isn't recorded by the\n        // `ExtraErrorData` integration\n        (0,_object_js__WEBPACK_IMPORTED_MODULE_2__.addNonEnumerableProperty)(exception, \"__sentry_captured__\", true);\n    } catch (err) {\n    // `exception` is a primitive, so we can't mark it seen\n    }\n    return false;\n}\n/**\n * Checks whether the given input is already an array, and if it isn't, wraps it in one.\n *\n * @param maybeArray Input to turn into an array, if necessary\n * @returns The input, if already an array, or an array with the input as the only element, if not\n */ function arrayify(maybeArray) {\n    return Array.isArray(maybeArray) ? maybeArray : [\n        maybeArray\n    ];\n}\n //# sourceMappingURL=misc.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS91dGlscy9lc20vbWlzYy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUF1RDtBQUNoQjtBQUNLO0FBRTVDOzs7O0NBSUMsR0FDRCxTQUFTRztJQUNQLE1BQU1DLE1BQU1GLHFEQUFVQTtJQUN0QixNQUFNRyxTQUFTRCxJQUFJQyxNQUFNLElBQUlELElBQUlFLFFBQVE7SUFFekMsSUFBSUMsZ0JBQWdCLElBQU1DLEtBQUtDLE1BQU0sS0FBSztJQUMxQyxJQUFJO1FBQ0YsSUFBSUosVUFBVUEsT0FBT0ssVUFBVSxFQUFFO1lBQy9CLE9BQU9MLE9BQU9LLFVBQVUsR0FBR0MsT0FBTyxDQUFDLE1BQU07UUFDM0M7UUFDQSxJQUFJTixVQUFVQSxPQUFPTyxlQUFlLEVBQUU7WUFDcENMLGdCQUFnQjtnQkFDZCwyRUFBMkU7Z0JBQzNFLHVEQUF1RDtnQkFDdkQsa0RBQWtEO2dCQUNsRCwwRkFBMEY7Z0JBQzFGLE1BQU1NLGFBQWEsSUFBSUMsV0FBVztnQkFDbENULE9BQU9PLGVBQWUsQ0FBQ0M7Z0JBQ3ZCLE9BQU9BLFVBQVUsQ0FBQyxFQUFFO1lBQ3RCO1FBQ0Y7SUFDRixFQUFFLE9BQU9FLEdBQUc7SUFDViwwQ0FBMEM7SUFDMUMsNkRBQTZEO0lBQy9EO0lBRUEsb0dBQW9HO0lBQ3BHLCtGQUErRjtJQUMvRixPQUFPLENBQUM7UUFBRTtLQUFJLEdBQUssTUFBTSxNQUFNLE1BQU0sSUFBRyxFQUFHSixPQUFPLENBQUMsVUFBVUssQ0FBQUEsSUFFM0Qsc0NBRHNDO1FBQ3JDLEtBQVEsQ0FBQ1Qsa0JBQWtCLEVBQUMsS0FBTyxJQUFPLENBQUUsRUFBR1UsUUFBUSxDQUFDO0FBRTdEO0FBRUEsU0FBU0Msa0JBQWtCQyxLQUFLO0lBQzlCLE9BQU9BLE1BQU1DLFNBQVMsSUFBSUQsTUFBTUMsU0FBUyxDQUFDQyxNQUFNLEdBQUdGLE1BQU1DLFNBQVMsQ0FBQ0MsTUFBTSxDQUFDLEVBQUUsR0FBR0M7QUFDakY7QUFF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Q0osV0FBVyxHQUFHSCxNQUFNRSxNQUFNLEdBQUcsSUFBSTtJQUV0RUYsTUFBTVEsV0FBVyxHQUFHVCxNQUNqQlUsS0FBSyxDQUFDckQsS0FBS2tELEdBQUcsQ0FBQyxHQUFHRCxhQUFhSixpQkFBaUJJLFlBQ2hESyxHQUFHLENBQUMsQ0FBQ0MsT0FBUzlELG9EQUFRQSxDQUFDOEQsTUFBTTtJQUVoQ1gsTUFBTVksWUFBWSxHQUFHL0Qsb0RBQVFBLENBQUNrRCxLQUFLLENBQUMzQyxLQUFLbUQsR0FBRyxDQUFDSixXQUFXLEdBQUdFLFlBQVksRUFBRUwsTUFBTWEsS0FBSyxJQUFJO0lBRXhGYixNQUFNYyxZQUFZLEdBQUdmLE1BQ2xCVSxLQUFLLENBQUNyRCxLQUFLbUQsR0FBRyxDQUFDRixhQUFhLEdBQUdGLFdBQVdFLGFBQWEsSUFBSUosZ0JBQzNEUyxHQUFHLENBQUMsQ0FBQ0MsT0FBUzlELG9EQUFRQSxDQUFDOEQsTUFBTTtBQUNsQztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW9CQyxHQUNELFNBQVNJLHdCQUF3Qi9DLFNBQVM7SUFDeEMsc0VBQXNFO0lBQ3RFLElBQUlBLGFBQWEsVUFBYWdELG1CQUFtQixFQUFFO1FBQ2pELE9BQU87SUFDVDtJQUVBLElBQUk7UUFDRiw2R0FBNkc7UUFDN0csK0JBQStCO1FBQy9CcEUsb0VBQXdCQSxDQUFDb0IsV0FBWSx1QkFBdUI7SUFDOUQsRUFBRSxPQUFPaUQsS0FBSztJQUNaLHVEQUF1RDtJQUN6RDtJQUVBLE9BQU87QUFDVDtBQUVBOzs7OztDQUtDLEdBQ0QsU0FBU0MsU0FBU0MsVUFBVTtJQUMxQixPQUFPQyxNQUFNQyxPQUFPLENBQUNGLGNBQWNBLGFBQWE7UUFBQ0E7S0FBVztBQUM5RDtBQUV1SixDQUN2SixnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vYnJhbGluay13ZWIvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS91dGlscy9lc20vbWlzYy5qcz85ODA2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFkZE5vbkVudW1lcmFibGVQcm9wZXJ0eSB9IGZyb20gJy4vb2JqZWN0LmpzJztcbmltcG9ydCB7IHNuaXBMaW5lIH0gZnJvbSAnLi9zdHJpbmcuanMnO1xuaW1wb3J0IHsgR0xPQkFMX09CSiB9IGZyb20gJy4vd29ybGR3aWRlLmpzJztcblxuLyoqXG4gKiBVVUlENCBnZW5lcmF0b3JcbiAqXG4gKiBAcmV0dXJucyBzdHJpbmcgR2VuZXJhdGVkIFVVSUQ0LlxuICovXG5mdW5jdGlvbiB1dWlkNCgpIHtcbiAgY29uc3QgZ2JsID0gR0xPQkFMX09CSiA7XG4gIGNvbnN0IGNyeXB0byA9IGdibC5jcnlwdG8gfHwgZ2JsLm1zQ3J5cHRvO1xuXG4gIGxldCBnZXRSYW5kb21CeXRlID0gKCkgPT4gTWF0aC5yYW5kb20oKSAqIDE2O1xuICB0cnkge1xuICAgIGlmIChjcnlwdG8gJiYgY3J5cHRvLnJhbmRvbVVVSUQpIHtcbiAgICAgIHJldHVybiBjcnlwdG8ucmFuZG9tVVVJRCgpLnJlcGxhY2UoLy0vZywgJycpO1xuICAgIH1cbiAgICBpZiAoY3J5cHRvICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAgIGdldFJhbmRvbUJ5dGUgPSAoKSA9PiB7XG4gICAgICAgIC8vIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgbWlnaHQgcmV0dXJuIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHRoZSB0eXBlZCBhcnJheVxuICAgICAgICAvLyBpbiBvbGQgQ2hyb21pdW0gdmVyc2lvbnMgKGUuZy4gMjMuMC4xMjM1LjAgKDE1MTQyMikpXG4gICAgICAgIC8vIEhvd2V2ZXIsIGB0eXBlZEFycmF5YCBpcyBzdGlsbCBmaWxsZWQgaW4tcGxhY2UuXG4gICAgICAgIC8vIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NyeXB0by9nZXRSYW5kb21WYWx1ZXMjdHlwZWRhcnJheVxuICAgICAgICBjb25zdCB0eXBlZEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gICAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXModHlwZWRBcnJheSk7XG4gICAgICAgIHJldHVybiB0eXBlZEFycmF5WzBdO1xuICAgICAgfTtcbiAgICB9XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICAvLyBzb21lIHJ1bnRpbWVzIGNhbiBjcmFzaCBpbnZva2luZyBjcnlwdG9cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ2V0c2VudHJ5L3NlbnRyeS1qYXZhc2NyaXB0L2lzc3Vlcy84OTM1XG4gIH1cblxuICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwNTAzNC9ob3ctdG8tY3JlYXRlLWEtZ3VpZC11dWlkLWluLWphdmFzY3JpcHQvMjExNzUyMyMyMTE3NTIzXG4gIC8vIENvbmNhdGVuYXRpbmcgdGhlIGZvbGxvd2luZyBudW1iZXJzIGFzIHN0cmluZ3MgcmVzdWx0cyBpbiAnMTAwMDAwMDAxMDAwNDAwMDgwMDAxMDAwMDAwMDAwMDAnXG4gIHJldHVybiAoKFsxZTddICkgKyAxZTMgKyA0ZTMgKyA4ZTMgKyAxZTExKS5yZXBsYWNlKC9bMDE4XS9nLCBjID0+XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAoKGMgKSBeICgoZ2V0UmFuZG9tQnl0ZSgpICYgMTUpID4+ICgoYyApIC8gNCkpKS50b1N0cmluZygxNiksXG4gICk7XG59XG5cbmZ1bmN0aW9uIGdldEZpcnN0RXhjZXB0aW9uKGV2ZW50KSB7XG4gIHJldHVybiBldmVudC5leGNlcHRpb24gJiYgZXZlbnQuZXhjZXB0aW9uLnZhbHVlcyA/IGV2ZW50LmV4Y2VwdGlvbi52YWx1ZXNbMF0gOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogRXh0cmFjdHMgZWl0aGVyIG1lc3NhZ2Ugb3IgdHlwZSt2YWx1ZSBmcm9tIGFuIGV2ZW50IHRoYXQgY2FuIGJlIHVzZWQgZm9yIHVzZXItZmFjaW5nIGxvZ3NcbiAqIEByZXR1cm5zIGV2ZW50J3MgZGVzY3JpcHRpb25cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnREZXNjcmlwdGlvbihldmVudCkge1xuICBjb25zdCB7IG1lc3NhZ2UsIGV2ZW50X2lkOiBldmVudElkIH0gPSBldmVudDtcbiAgaWYgKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuXG4gIGNvbnN0IGZpcnN0RXhjZXB0aW9uID0gZ2V0Rmlyc3RFeGNlcHRpb24oZXZlbnQpO1xuICBpZiAoZmlyc3RFeGNlcHRpb24pIHtcbiAgICBpZiAoZmlyc3RFeGNlcHRpb24udHlwZSAmJiBmaXJzdEV4Y2VwdGlvbi52YWx1ZSkge1xuICAgICAgcmV0dXJuIGAke2ZpcnN0RXhjZXB0aW9uLnR5cGV9OiAke2ZpcnN0RXhjZXB0aW9uLnZhbHVlfWA7XG4gICAgfVxuICAgIHJldHVybiBmaXJzdEV4Y2VwdGlvbi50eXBlIHx8IGZpcnN0RXhjZXB0aW9uLnZhbHVlIHx8IGV2ZW50SWQgfHwgJzx1bmtub3duPic7XG4gIH1cbiAgcmV0dXJuIGV2ZW50SWQgfHwgJzx1bmtub3duPic7XG59XG5cbi8qKlxuICogQWRkcyBleGNlcHRpb24gdmFsdWVzLCB0eXBlIGFuZCB2YWx1ZSB0byBhbiBzeW50aGV0aWMgRXhjZXB0aW9uLlxuICogQHBhcmFtIGV2ZW50IFRoZSBldmVudCB0byBtb2RpZnkuXG4gKiBAcGFyYW0gdmFsdWUgVmFsdWUgb2YgdGhlIGV4Y2VwdGlvbi5cbiAqIEBwYXJhbSB0eXBlIFR5cGUgb2YgdGhlIGV4Y2VwdGlvbi5cbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gYWRkRXhjZXB0aW9uVHlwZVZhbHVlKGV2ZW50LCB2YWx1ZSwgdHlwZSkge1xuICBjb25zdCBleGNlcHRpb24gPSAoZXZlbnQuZXhjZXB0aW9uID0gZXZlbnQuZXhjZXB0aW9uIHx8IHt9KTtcbiAgY29uc3QgdmFsdWVzID0gKGV4Y2VwdGlvbi52YWx1ZXMgPSBleGNlcHRpb24udmFsdWVzIHx8IFtdKTtcbiAgY29uc3QgZmlyc3RFeGNlcHRpb24gPSAodmFsdWVzWzBdID0gdmFsdWVzWzBdIHx8IHt9KTtcbiAgaWYgKCFmaXJzdEV4Y2VwdGlvbi52YWx1ZSkge1xuICAgIGZpcnN0RXhjZXB0aW9uLnZhbHVlID0gdmFsdWUgfHwgJyc7XG4gIH1cbiAgaWYgKCFmaXJzdEV4Y2VwdGlvbi50eXBlKSB7XG4gICAgZmlyc3RFeGNlcHRpb24udHlwZSA9IHR5cGUgfHwgJ0Vycm9yJztcbiAgfVxufVxuXG4vKipcbiAqIEFkZHMgZXhjZXB0aW9uIG1lY2hhbmlzbSBkYXRhIHRvIGEgZ2l2ZW4gZXZlbnQuIFVzZXMgZGVmYXVsdHMgaWYgdGhlIHNlY29uZCBwYXJhbWV0ZXIgaXMgbm90IHBhc3NlZC5cbiAqXG4gKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSBuZXdNZWNoYW5pc20gTWVjaGFuaXNtIGRhdGEgdG8gYWRkIHRvIHRoZSBldmVudC5cbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gYWRkRXhjZXB0aW9uTWVjaGFuaXNtKGV2ZW50LCBuZXdNZWNoYW5pc20pIHtcbiAgY29uc3QgZmlyc3RFeGNlcHRpb24gPSBnZXRGaXJzdEV4Y2VwdGlvbihldmVudCk7XG4gIGlmICghZmlyc3RFeGNlcHRpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBkZWZhdWx0TWVjaGFuaXNtID0geyB0eXBlOiAnZ2VuZXJpYycsIGhhbmRsZWQ6IHRydWUgfTtcbiAgY29uc3QgY3VycmVudE1lY2hhbmlzbSA9IGZpcnN0RXhjZXB0aW9uLm1lY2hhbmlzbTtcbiAgZmlyc3RFeGNlcHRpb24ubWVjaGFuaXNtID0geyAuLi5kZWZhdWx0TWVjaGFuaXNtLCAuLi5jdXJyZW50TWVjaGFuaXNtLCAuLi5uZXdNZWNoYW5pc20gfTtcblxuICBpZiAobmV3TWVjaGFuaXNtICYmICdkYXRhJyBpbiBuZXdNZWNoYW5pc20pIHtcbiAgICBjb25zdCBtZXJnZWREYXRhID0geyAuLi4oY3VycmVudE1lY2hhbmlzbSAmJiBjdXJyZW50TWVjaGFuaXNtLmRhdGEpLCAuLi5uZXdNZWNoYW5pc20uZGF0YSB9O1xuICAgIGZpcnN0RXhjZXB0aW9uLm1lY2hhbmlzbS5kYXRhID0gbWVyZ2VkRGF0YTtcbiAgfVxufVxuXG4vLyBodHRwczovL3NlbXZlci5vcmcvI2lzLXRoZXJlLWEtc3VnZ2VzdGVkLXJlZ3VsYXItZXhwcmVzc2lvbi1yZWdleC10by1jaGVjay1hLXNlbXZlci1zdHJpbmdcbmNvbnN0IFNFTVZFUl9SRUdFWFAgPVxuICAvXigwfFsxLTldXFxkKilcXC4oMHxbMS05XVxcZCopXFwuKDB8WzEtOV1cXGQqKSg/Oi0oKD86MHxbMS05XVxcZCp8XFxkKlthLXpBLVotXVswLTlhLXpBLVotXSopKD86XFwuKD86MHxbMS05XVxcZCp8XFxkKlthLXpBLVotXVswLTlhLXpBLVotXSopKSopKT8oPzpcXCsoWzAtOWEtekEtWi1dKyg/OlxcLlswLTlhLXpBLVotXSspKikpPyQvO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgU2VtYW50aWMgVmVyc2lvbmluZyBvYmplY3RcbiAqL1xuXG4vKipcbiAqIFBhcnNlcyBpbnB1dCBpbnRvIGEgU2VtVmVyIGludGVyZmFjZVxuICogQHBhcmFtIGlucHV0IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHNlbXZlciB2ZXJzaW9uXG4gKi9cbmZ1bmN0aW9uIHBhcnNlU2VtdmVyKGlucHV0KSB7XG4gIGNvbnN0IG1hdGNoID0gaW5wdXQubWF0Y2goU0VNVkVSX1JFR0VYUCkgfHwgW107XG4gIGNvbnN0IG1ham9yID0gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcbiAgY29uc3QgbWlub3IgPSBwYXJzZUludChtYXRjaFsyXSwgMTApO1xuICBjb25zdCBwYXRjaCA9IHBhcnNlSW50KG1hdGNoWzNdLCAxMCk7XG4gIHJldHVybiB7XG4gICAgYnVpbGRtZXRhZGF0YTogbWF0Y2hbNV0sXG4gICAgbWFqb3I6IGlzTmFOKG1ham9yKSA/IHVuZGVmaW5lZCA6IG1ham9yLFxuICAgIG1pbm9yOiBpc05hTihtaW5vcikgPyB1bmRlZmluZWQgOiBtaW5vcixcbiAgICBwYXRjaDogaXNOYU4ocGF0Y2gpID8gdW5kZWZpbmVkIDogcGF0Y2gsXG4gICAgcHJlcmVsZWFzZTogbWF0Y2hbNF0sXG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBhZGRzIGNvbnRleHQgKHByZS9wb3N0L2xpbmUpIGxpbmVzIHRvIHRoZSBwcm92aWRlZCBmcmFtZVxuICpcbiAqIEBwYXJhbSBsaW5lcyBzdHJpbmdbXSBjb250YWluaW5nIGFsbCBsaW5lc1xuICogQHBhcmFtIGZyYW1lIFN0YWNrRnJhbWUgdGhhdCB3aWxsIGJlIG11dGF0ZWRcbiAqIEBwYXJhbSBsaW5lc09mQ29udGV4dCBudW1iZXIgb2YgY29udGV4dCBsaW5lcyB3ZSB3YW50IHRvIGFkZCBwcmUvcG9zdFxuICovXG5mdW5jdGlvbiBhZGRDb250ZXh0VG9GcmFtZShsaW5lcywgZnJhbWUsIGxpbmVzT2ZDb250ZXh0ID0gNSkge1xuICAvLyBXaGVuIHRoZXJlIGlzIG5vIGxpbmUgbnVtYmVyIGluIHRoZSBmcmFtZSwgYXR0YWNoaW5nIGNvbnRleHQgaXMgbm9uc2Vuc2ljYWwgYW5kIHdpbGwgZXZlbiBicmVhayBncm91cGluZ1xuICBpZiAoZnJhbWUubGluZW5vID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBtYXhMaW5lcyA9IGxpbmVzLmxlbmd0aDtcbiAgY29uc3Qgc291cmNlTGluZSA9IE1hdGgubWF4KE1hdGgubWluKG1heExpbmVzIC0gMSwgZnJhbWUubGluZW5vIC0gMSksIDApO1xuXG4gIGZyYW1lLnByZV9jb250ZXh0ID0gbGluZXNcbiAgICAuc2xpY2UoTWF0aC5tYXgoMCwgc291cmNlTGluZSAtIGxpbmVzT2ZDb250ZXh0KSwgc291cmNlTGluZSlcbiAgICAubWFwKChsaW5lKSA9PiBzbmlwTGluZShsaW5lLCAwKSk7XG5cbiAgZnJhbWUuY29udGV4dF9saW5lID0gc25pcExpbmUobGluZXNbTWF0aC5taW4obWF4TGluZXMgLSAxLCBzb3VyY2VMaW5lKV0sIGZyYW1lLmNvbG5vIHx8IDApO1xuXG4gIGZyYW1lLnBvc3RfY29udGV4dCA9IGxpbmVzXG4gICAgLnNsaWNlKE1hdGgubWluKHNvdXJjZUxpbmUgKyAxLCBtYXhMaW5lcyksIHNvdXJjZUxpbmUgKyAxICsgbGluZXNPZkNvbnRleHQpXG4gICAgLm1hcCgobGluZSkgPT4gc25pcExpbmUobGluZSwgMCkpO1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB3ZSd2ZSBhbHJlYWR5IGNhcHR1cmVkIHRoZSBnaXZlbiBleGNlcHRpb24gKG5vdGU6IG5vdCBhbiBpZGVudGljYWwgZXhjZXB0aW9uIC0gdGhlIHZlcnkgb2JqZWN0XG4gKiBpbiBxdWVzdGlvbiksIGFuZCBtYXJrcyBpdCBjYXB0dXJlZCBpZiBub3QuXG4gKlxuICogVGhpcyBpcyB1c2VmdWwgYmVjYXVzZSBpdCdzIHBvc3NpYmxlIGZvciBhbiBlcnJvciB0byBnZXQgY2FwdHVyZWQgYnkgbW9yZSB0aGFuIG9uZSBtZWNoYW5pc20uIEFmdGVyIHdlIGludGVyY2VwdCBhbmRcbiAqIHJlY29yZCBhbiBlcnJvciwgd2UgcmV0aHJvdyBpdCAoYXNzdW1pbmcgd2UndmUgaW50ZXJjZXB0ZWQgaXQgYmVmb3JlIGl0J3MgcmVhY2hlZCB0aGUgdG9wLWxldmVsIGdsb2JhbCBoYW5kbGVycyksIHNvXG4gKiB0aGF0IHdlIGRvbid0IGludGVyZmVyZSB3aXRoIHdoYXRldmVyIGVmZmVjdHMgdGhlIGVycm9yIG1pZ2h0IGhhdmUgaGFkIHdlcmUgdGhlIFNESyBub3QgdGhlcmUuIEF0IHRoYXQgcG9pbnQsIGJlY2F1c2VcbiAqIHRoZSBlcnJvciBoYXMgYmVlbiByZXRocm93biwgaXQncyBwb3NzaWJsZSBmb3IgaXQgdG8gYnViYmxlIHVwIHRvIHNvbWUgb3RoZXIgY29kZSB3ZSd2ZSBpbnN0cnVtZW50ZWQuIElmIGl0J3Mgbm90XG4gKiBjYXVnaHQgYWZ0ZXIgdGhhdCwgaXQgd2lsbCBidWJibGUgYWxsIHRoZSB3YXkgdXAgdG8gdGhlIGdsb2JhbCBoYW5kbGVycyAod2hpY2ggb2YgY291cnNlIHdlIGFsc28gaW5zdHJ1bWVudCkuIFRoaXNcbiAqIGZ1bmN0aW9uIGhlbHBzIHVzIGVuc3VyZSB0aGF0IGV2ZW4gaWYgd2UgZW5jb3VudGVyIHRoZSBzYW1lIGVycm9yIG1vcmUgdGhhbiBvbmNlLCB3ZSBvbmx5IHJlY29yZCBpdCB0aGUgZmlyc3QgdGltZSB3ZVxuICogc2VlIGl0LlxuICpcbiAqIE5vdGU6IEl0IHdpbGwgaWdub3JlIHByaW1pdGl2ZXMgKGFsd2F5cyByZXR1cm4gYGZhbHNlYCBhbmQgbm90IG1hcmsgdGhlbSBhcyBzZWVuKSwgYXMgcHJvcGVydGllcyBjYW4ndCBiZSBzZXQgb25cbiAqIHRoZW0uIHtAbGluazogT2JqZWN0Lm9iamVjdGlmeX0gY2FuIGJlIHVzZWQgb24gZXhjZXB0aW9ucyB0byBjb252ZXJ0IGFueSB0aGF0IGFyZSBwcmltaXRpdmVzIGludG8gdGhlaXIgZXF1aXZhbGVudFxuICogb2JqZWN0IHdyYXBwZXIgZm9ybXMgc28gdGhhdCB0aGlzIGNoZWNrIHdpbGwgYWx3YXlzIHdvcmsuIEhvd2V2ZXIsIGJlY2F1c2Ugd2UgbmVlZCB0byBmbGFnIHRoZSBleGFjdCBvYmplY3Qgd2hpY2hcbiAqIHdpbGwgZ2V0IHJldGhyb3duLCBhbmQgYmVjYXVzZSB0aGF0IHJldGhyb3dpbmcgaGFwcGVucyBvdXRzaWRlIG9mIHRoZSBldmVudCBwcm9jZXNzaW5nIHBpcGVsaW5lLCB0aGUgb2JqZWN0aWZpY2F0aW9uXG4gKiBtdXN0IGJlIGRvbmUgYmVmb3JlIHRoZSBleGNlcHRpb24gY2FwdHVyZWQuXG4gKlxuICogQHBhcmFtIEEgdGhyb3duIGV4Y2VwdGlvbiB0byBjaGVjayBvciBmbGFnIGFzIGhhdmluZyBiZWVuIHNlZW5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgZXhjZXB0aW9uIGhhcyBhbHJlYWR5IGJlZW4gY2FwdHVyZWQsIGBmYWxzZWAgaWYgbm90ICh3aXRoIHRoZSBzaWRlIGVmZmVjdCBvZiBtYXJraW5nIGl0IHNlZW4pXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT3JTZXRBbHJlYWR5Q2F1Z2h0KGV4Y2VwdGlvbikge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gIGlmIChleGNlcHRpb24gJiYgKGV4Y2VwdGlvbiApLl9fc2VudHJ5X2NhcHR1cmVkX18pIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gc2V0IGl0IHRoaXMgd2F5IHJhdGhlciB0aGFuIGJ5IGFzc2lnbm1lbnQgc28gdGhhdCBpdCdzIG5vdCBlbm51bWVyYWJsZSBhbmQgdGhlcmVmb3JlIGlzbid0IHJlY29yZGVkIGJ5IHRoZVxuICAgIC8vIGBFeHRyYUVycm9yRGF0YWAgaW50ZWdyYXRpb25cbiAgICBhZGROb25FbnVtZXJhYmxlUHJvcGVydHkoZXhjZXB0aW9uICwgJ19fc2VudHJ5X2NhcHR1cmVkX18nLCB0cnVlKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gYGV4Y2VwdGlvbmAgaXMgYSBwcmltaXRpdmUsIHNvIHdlIGNhbid0IG1hcmsgaXQgc2VlblxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBpbnB1dCBpcyBhbHJlYWR5IGFuIGFycmF5LCBhbmQgaWYgaXQgaXNuJ3QsIHdyYXBzIGl0IGluIG9uZS5cbiAqXG4gKiBAcGFyYW0gbWF5YmVBcnJheSBJbnB1dCB0byB0dXJuIGludG8gYW4gYXJyYXksIGlmIG5lY2Vzc2FyeVxuICogQHJldHVybnMgVGhlIGlucHV0LCBpZiBhbHJlYWR5IGFuIGFycmF5LCBvciBhbiBhcnJheSB3aXRoIHRoZSBpbnB1dCBhcyB0aGUgb25seSBlbGVtZW50LCBpZiBub3RcbiAqL1xuZnVuY3Rpb24gYXJyYXlpZnkobWF5YmVBcnJheSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShtYXliZUFycmF5KSA/IG1heWJlQXJyYXkgOiBbbWF5YmVBcnJheV07XG59XG5cbmV4cG9ydCB7IGFkZENvbnRleHRUb0ZyYW1lLCBhZGRFeGNlcHRpb25NZWNoYW5pc20sIGFkZEV4Y2VwdGlvblR5cGVWYWx1ZSwgYXJyYXlpZnksIGNoZWNrT3JTZXRBbHJlYWR5Q2F1Z2h0LCBnZXRFdmVudERlc2NyaXB0aW9uLCBwYXJzZVNlbXZlciwgdXVpZDQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1pc2MuanMubWFwXG4iXSwibmFtZXMiOlsiYWRkTm9uRW51bWVyYWJsZVByb3BlcnR5Iiwic25pcExpbmUiLCJHTE9CQUxfT0JKIiwidXVpZDQiLCJnYmwiLCJjcnlwdG8iLCJtc0NyeXB0byIsImdldFJhbmRvbUJ5dGUiLCJNYXRoIiwicmFuZG9tIiwicmFuZG9tVVVJRCIsInJlcGxhY2UiLCJnZXRSYW5kb21WYWx1ZXMiLCJ0eXBlZEFycmF5IiwiVWludDhBcnJheSIsIl8iLCJjIiwidG9TdHJpbmciLCJnZXRGaXJzdEV4Y2VwdGlvbiIsImV2ZW50IiwiZXhjZXB0aW9uIiwidmFsdWVzIiwidW5kZWZpbmVkIiwiZ2V0RXZlbnREZXNjcmlwdGlvbiIsIm1lc3NhZ2UiLCJldmVudF9pZCIsImV2ZW50SWQiLCJmaXJzdEV4Y2VwdGlvbiIsInR5cGUiLCJ2YWx1ZSIsImFkZEV4Y2VwdGlvblR5cGVWYWx1ZSIsImFkZEV4Y2VwdGlvbk1lY2hhbmlzbSIsIm5ld01lY2hhbmlzbSIsImRlZmF1bHRNZWNoYW5pc20iLCJoYW5kbGVkIiwiY3VycmVudE1lY2hhbmlzbSIsIm1lY2hhbmlzbSIsIm1lcmdlZERhdGEiLCJkYXRhIiwiU0VNVkVSX1JFR0VYUCIsInBhcnNlU2VtdmVyIiwiaW5wdXQiLCJtYXRjaCIsIm1ham9yIiwicGFyc2VJbnQiLCJtaW5vciIsInBhdGNoIiwiYnVpbGRtZXRhZGF0YSIsImlzTmFOIiwicHJlcmVsZWFzZSIsImFkZENvbnRleHRUb0ZyYW1lIiwibGluZXMiLCJmcmFtZSIsImxpbmVzT2ZDb250ZXh0IiwibGluZW5vIiwibWF4TGluZXMiLCJsZW5ndGgiLCJzb3VyY2VMaW5lIiwibWF4IiwibWluIiwicHJlX2NvbnRleHQiLCJzbGljZSIsIm1hcCIsImxpbmUiLCJjb250ZXh0X2xpbmUiLCJjb2xubyIsInBvc3RfY29udGV4dCIsImNoZWNrT3JTZXRBbHJlYWR5Q2F1Z2h0IiwiX19zZW50cnlfY2FwdHVyZWRfXyIsImVyciIsImFycmF5aWZ5IiwibWF5YmVBcnJheSIsIkFycmF5IiwiaXNBcnJheSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/utils/esm/misc.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sentry/utils/esm/node-stack-trace.js":
/*!************************************************************!*\
  !*** ./node_modules/@sentry/utils/esm/node-stack-trace.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   filenameIsInApp: () => (/* binding */ filenameIsInApp),\n/* harmony export */   node: () => (/* binding */ node)\n/* harmony export */ });\n/**\n * Does this filename look like it's part of the app code?\n */ function filenameIsInApp(filename, isNative = false) {\n    const isInternal = isNative || filename && // It's not internal if it's an absolute linux path\n    !filename.startsWith(\"/\") && // It's not internal if it's an absolute windows path\n    !filename.match(/^[A-Z]:/) && // It's not internal if the path is starting with a dot\n    !filename.startsWith(\".\") && // It's not internal if the frame has a protocol. In node, this is usually the case if the file got pre-processed with a bundler like webpack\n    !filename.match(/^[a-zA-Z]([a-zA-Z0-9.\\-+])*:\\/\\//); // Schema from: https://stackoverflow.com/a/3641782\n    // in_app is all that's not an internal Node function or a module within node_modules\n    // note that isNative appears to return true even for node core libraries\n    // see https://github.com/getsentry/raven-node/issues/176\n    return !isInternal && filename !== undefined && !filename.includes(\"node_modules/\");\n}\n/** Node Stack line parser */ // eslint-disable-next-line complexity\nfunction node(getModule) {\n    const FILENAME_MATCH = /^\\s*[-]{4,}$/;\n    const FULL_MATCH = /at (?:async )?(?:(.+?)\\s+\\()?(?:(.+):(\\d+):(\\d+)?|([^)]+))\\)?/;\n    // eslint-disable-next-line complexity\n    return (line)=>{\n        const lineMatch = line.match(FULL_MATCH);\n        if (lineMatch) {\n            let object;\n            let method;\n            let functionName;\n            let typeName;\n            let methodName;\n            if (lineMatch[1]) {\n                functionName = lineMatch[1];\n                let methodStart = functionName.lastIndexOf(\".\");\n                if (functionName[methodStart - 1] === \".\") {\n                    methodStart--;\n                }\n                if (methodStart > 0) {\n                    object = functionName.slice(0, methodStart);\n                    method = functionName.slice(methodStart + 1);\n                    const objectEnd = object.indexOf(\".Module\");\n                    if (objectEnd > 0) {\n                        functionName = functionName.slice(objectEnd + 1);\n                        object = object.slice(0, objectEnd);\n                    }\n                }\n                typeName = undefined;\n            }\n            if (method) {\n                typeName = object;\n                methodName = method;\n            }\n            if (method === \"<anonymous>\") {\n                methodName = undefined;\n                functionName = undefined;\n            }\n            if (functionName === undefined) {\n                methodName = methodName || \"<anonymous>\";\n                functionName = typeName ? `${typeName}.${methodName}` : methodName;\n            }\n            let filename = lineMatch[2] && lineMatch[2].startsWith(\"file://\") ? lineMatch[2].slice(7) : lineMatch[2];\n            const isNative = lineMatch[5] === \"native\";\n            // If it's a Windows path, trim the leading slash so that `/C:/foo` becomes `C:/foo`\n            if (filename && filename.match(/\\/[A-Z]:/)) {\n                filename = filename.slice(1);\n            }\n            if (!filename && lineMatch[5] && !isNative) {\n                filename = lineMatch[5];\n            }\n            return {\n                filename,\n                module: getModule ? getModule(filename) : undefined,\n                function: functionName,\n                lineno: parseInt(lineMatch[3], 10) || undefined,\n                colno: parseInt(lineMatch[4], 10) || undefined,\n                in_app: filenameIsInApp(filename, isNative)\n            };\n        }\n        if (line.match(FILENAME_MATCH)) {\n            return {\n                filename: line\n            };\n        }\n        return undefined;\n    };\n}\n //# sourceMappingURL=node-stack-trace.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS91dGlscy9lc20vbm9kZS1zdGFjay10cmFjZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOztDQUVDLEdBQ0QsU0FBU0EsZ0JBQWdCQyxRQUFRLEVBQUVDLFdBQVcsS0FBSztJQUNqRCxNQUFNQyxhQUNKRCxZQUNDRCxZQUNDLG1EQUFtRDtJQUNuRCxDQUFDQSxTQUFTRyxVQUFVLENBQUMsUUFDckIscURBQXFEO0lBQ3JELENBQUNILFNBQVNJLEtBQUssQ0FBQyxjQUNoQix1REFBdUQ7SUFDdkQsQ0FBQ0osU0FBU0csVUFBVSxDQUFDLFFBQ3JCLDZJQUE2STtJQUM3SSxDQUFDSCxTQUFTSSxLQUFLLENBQUMscUNBQXNDLG1EQUFtRDtJQUU3RyxxRkFBcUY7SUFDckYseUVBQXlFO0lBQ3pFLHlEQUF5RDtJQUV6RCxPQUFPLENBQUNGLGNBQWNGLGFBQWFLLGFBQWEsQ0FBQ0wsU0FBU00sUUFBUSxDQUFDO0FBQ3JFO0FBRUEsMkJBQTJCLEdBQzNCLHNDQUFzQztBQUN0QyxTQUFTQyxLQUFLQyxTQUFTO0lBQ3JCLE1BQU1DLGlCQUFpQjtJQUN2QixNQUFNQyxhQUFhO0lBRW5CLHNDQUFzQztJQUN0QyxPQUFPLENBQUNDO1FBQ04sTUFBTUMsWUFBWUQsS0FBS1AsS0FBSyxDQUFDTTtRQUU3QixJQUFJRSxXQUFXO1lBQ2IsSUFBSUM7WUFDSixJQUFJQztZQUNKLElBQUlDO1lBQ0osSUFBSUM7WUFDSixJQUFJQztZQUVKLElBQUlMLFNBQVMsQ0FBQyxFQUFFLEVBQUU7Z0JBQ2hCRyxlQUFlSCxTQUFTLENBQUMsRUFBRTtnQkFFM0IsSUFBSU0sY0FBY0gsYUFBYUksV0FBVyxDQUFDO2dCQUMzQyxJQUFJSixZQUFZLENBQUNHLGNBQWMsRUFBRSxLQUFLLEtBQUs7b0JBQ3pDQTtnQkFDRjtnQkFFQSxJQUFJQSxjQUFjLEdBQUc7b0JBQ25CTCxTQUFTRSxhQUFhSyxLQUFLLENBQUMsR0FBR0Y7b0JBQy9CSixTQUFTQyxhQUFhSyxLQUFLLENBQUNGLGNBQWM7b0JBQzFDLE1BQU1HLFlBQVlSLE9BQU9TLE9BQU8sQ0FBQztvQkFDakMsSUFBSUQsWUFBWSxHQUFHO3dCQUNqQk4sZUFBZUEsYUFBYUssS0FBSyxDQUFDQyxZQUFZO3dCQUM5Q1IsU0FBU0EsT0FBT08sS0FBSyxDQUFDLEdBQUdDO29CQUMzQjtnQkFDRjtnQkFDQUwsV0FBV1g7WUFDYjtZQUVBLElBQUlTLFFBQVE7Z0JBQ1ZFLFdBQVdIO2dCQUNYSSxhQUFhSDtZQUNmO1lBRUEsSUFBSUEsV0FBVyxlQUFlO2dCQUM1QkcsYUFBYVo7Z0JBQ2JVLGVBQWVWO1lBQ2pCO1lBRUEsSUFBSVUsaUJBQWlCVixXQUFXO2dCQUM5QlksYUFBYUEsY0FBYztnQkFDM0JGLGVBQWVDLFdBQVcsQ0FBQyxFQUFFQSxTQUFTLENBQUMsRUFBRUMsV0FBVyxDQUFDLEdBQUdBO1lBQzFEO1lBRUEsSUFBSWpCLFdBQVdZLFNBQVMsQ0FBQyxFQUFFLElBQUlBLFNBQVMsQ0FBQyxFQUFFLENBQUNULFVBQVUsQ0FBQyxhQUFhUyxTQUFTLENBQUMsRUFBRSxDQUFDUSxLQUFLLENBQUMsS0FBS1IsU0FBUyxDQUFDLEVBQUU7WUFDeEcsTUFBTVgsV0FBV1csU0FBUyxDQUFDLEVBQUUsS0FBSztZQUVsQyxvRkFBb0Y7WUFDcEYsSUFBSVosWUFBWUEsU0FBU0ksS0FBSyxDQUFDLGFBQWE7Z0JBQzFDSixXQUFXQSxTQUFTb0IsS0FBSyxDQUFDO1lBQzVCO1lBRUEsSUFBSSxDQUFDcEIsWUFBWVksU0FBUyxDQUFDLEVBQUUsSUFBSSxDQUFDWCxVQUFVO2dCQUMxQ0QsV0FBV1ksU0FBUyxDQUFDLEVBQUU7WUFDekI7WUFFQSxPQUFPO2dCQUNMWjtnQkFDQXVCLFFBQVFmLFlBQVlBLFVBQVVSLFlBQVlLO2dCQUMxQ21CLFVBQVVUO2dCQUNWVSxRQUFRQyxTQUFTZCxTQUFTLENBQUMsRUFBRSxFQUFFLE9BQU9QO2dCQUN0Q3NCLE9BQU9ELFNBQVNkLFNBQVMsQ0FBQyxFQUFFLEVBQUUsT0FBT1A7Z0JBQ3JDdUIsUUFBUTdCLGdCQUFnQkMsVUFBVUM7WUFDcEM7UUFDRjtRQUVBLElBQUlVLEtBQUtQLEtBQUssQ0FBQ0ssaUJBQWlCO1lBQzlCLE9BQU87Z0JBQ0xULFVBQVVXO1lBQ1o7UUFDRjtRQUVBLE9BQU9OO0lBQ1Q7QUFDRjtBQUVpQyxDQUNqQyw0Q0FBNEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vYnJhbGluay13ZWIvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS91dGlscy9lc20vbm9kZS1zdGFjay10cmFjZS5qcz8wNTk4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRG9lcyB0aGlzIGZpbGVuYW1lIGxvb2sgbGlrZSBpdCdzIHBhcnQgb2YgdGhlIGFwcCBjb2RlP1xuICovXG5mdW5jdGlvbiBmaWxlbmFtZUlzSW5BcHAoZmlsZW5hbWUsIGlzTmF0aXZlID0gZmFsc2UpIHtcbiAgY29uc3QgaXNJbnRlcm5hbCA9XG4gICAgaXNOYXRpdmUgfHxcbiAgICAoZmlsZW5hbWUgJiZcbiAgICAgIC8vIEl0J3Mgbm90IGludGVybmFsIGlmIGl0J3MgYW4gYWJzb2x1dGUgbGludXggcGF0aFxuICAgICAgIWZpbGVuYW1lLnN0YXJ0c1dpdGgoJy8nKSAmJlxuICAgICAgLy8gSXQncyBub3QgaW50ZXJuYWwgaWYgaXQncyBhbiBhYnNvbHV0ZSB3aW5kb3dzIHBhdGhcbiAgICAgICFmaWxlbmFtZS5tYXRjaCgvXltBLVpdOi8pICYmXG4gICAgICAvLyBJdCdzIG5vdCBpbnRlcm5hbCBpZiB0aGUgcGF0aCBpcyBzdGFydGluZyB3aXRoIGEgZG90XG4gICAgICAhZmlsZW5hbWUuc3RhcnRzV2l0aCgnLicpICYmXG4gICAgICAvLyBJdCdzIG5vdCBpbnRlcm5hbCBpZiB0aGUgZnJhbWUgaGFzIGEgcHJvdG9jb2wuIEluIG5vZGUsIHRoaXMgaXMgdXN1YWxseSB0aGUgY2FzZSBpZiB0aGUgZmlsZSBnb3QgcHJlLXByb2Nlc3NlZCB3aXRoIGEgYnVuZGxlciBsaWtlIHdlYnBhY2tcbiAgICAgICFmaWxlbmFtZS5tYXRjaCgvXlthLXpBLVpdKFthLXpBLVowLTkuXFwtK10pKjpcXC9cXC8vKSk7IC8vIFNjaGVtYSBmcm9tOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzY0MTc4MlxuXG4gIC8vIGluX2FwcCBpcyBhbGwgdGhhdCdzIG5vdCBhbiBpbnRlcm5hbCBOb2RlIGZ1bmN0aW9uIG9yIGEgbW9kdWxlIHdpdGhpbiBub2RlX21vZHVsZXNcbiAgLy8gbm90ZSB0aGF0IGlzTmF0aXZlIGFwcGVhcnMgdG8gcmV0dXJuIHRydWUgZXZlbiBmb3Igbm9kZSBjb3JlIGxpYnJhcmllc1xuICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2dldHNlbnRyeS9yYXZlbi1ub2RlL2lzc3Vlcy8xNzZcblxuICByZXR1cm4gIWlzSW50ZXJuYWwgJiYgZmlsZW5hbWUgIT09IHVuZGVmaW5lZCAmJiAhZmlsZW5hbWUuaW5jbHVkZXMoJ25vZGVfbW9kdWxlcy8nKTtcbn1cblxuLyoqIE5vZGUgU3RhY2sgbGluZSBwYXJzZXIgKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5mdW5jdGlvbiBub2RlKGdldE1vZHVsZSkge1xuICBjb25zdCBGSUxFTkFNRV9NQVRDSCA9IC9eXFxzKlstXXs0LH0kLztcbiAgY29uc3QgRlVMTF9NQVRDSCA9IC9hdCAoPzphc3luYyApPyg/OiguKz8pXFxzK1xcKCk/KD86KC4rKTooXFxkKyk6KFxcZCspP3woW14pXSspKVxcKT8vO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gIHJldHVybiAobGluZSkgPT4ge1xuICAgIGNvbnN0IGxpbmVNYXRjaCA9IGxpbmUubWF0Y2goRlVMTF9NQVRDSCk7XG5cbiAgICBpZiAobGluZU1hdGNoKSB7XG4gICAgICBsZXQgb2JqZWN0O1xuICAgICAgbGV0IG1ldGhvZDtcbiAgICAgIGxldCBmdW5jdGlvbk5hbWU7XG4gICAgICBsZXQgdHlwZU5hbWU7XG4gICAgICBsZXQgbWV0aG9kTmFtZTtcblxuICAgICAgaWYgKGxpbmVNYXRjaFsxXSkge1xuICAgICAgICBmdW5jdGlvbk5hbWUgPSBsaW5lTWF0Y2hbMV07XG5cbiAgICAgICAgbGV0IG1ldGhvZFN0YXJ0ID0gZnVuY3Rpb25OYW1lLmxhc3RJbmRleE9mKCcuJyk7XG4gICAgICAgIGlmIChmdW5jdGlvbk5hbWVbbWV0aG9kU3RhcnQgLSAxXSA9PT0gJy4nKSB7XG4gICAgICAgICAgbWV0aG9kU3RhcnQtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZXRob2RTdGFydCA+IDApIHtcbiAgICAgICAgICBvYmplY3QgPSBmdW5jdGlvbk5hbWUuc2xpY2UoMCwgbWV0aG9kU3RhcnQpO1xuICAgICAgICAgIG1ldGhvZCA9IGZ1bmN0aW9uTmFtZS5zbGljZShtZXRob2RTdGFydCArIDEpO1xuICAgICAgICAgIGNvbnN0IG9iamVjdEVuZCA9IG9iamVjdC5pbmRleE9mKCcuTW9kdWxlJyk7XG4gICAgICAgICAgaWYgKG9iamVjdEVuZCA+IDApIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZSA9IGZ1bmN0aW9uTmFtZS5zbGljZShvYmplY3RFbmQgKyAxKTtcbiAgICAgICAgICAgIG9iamVjdCA9IG9iamVjdC5zbGljZSgwLCBvYmplY3RFbmQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0eXBlTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgaWYgKG1ldGhvZCkge1xuICAgICAgICB0eXBlTmFtZSA9IG9iamVjdDtcbiAgICAgICAgbWV0aG9kTmFtZSA9IG1ldGhvZDtcbiAgICAgIH1cblxuICAgICAgaWYgKG1ldGhvZCA9PT0gJzxhbm9ueW1vdXM+Jykge1xuICAgICAgICBtZXRob2ROYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICBmdW5jdGlvbk5hbWUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChmdW5jdGlvbk5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtZXRob2ROYW1lID0gbWV0aG9kTmFtZSB8fCAnPGFub255bW91cz4nO1xuICAgICAgICBmdW5jdGlvbk5hbWUgPSB0eXBlTmFtZSA/IGAke3R5cGVOYW1lfS4ke21ldGhvZE5hbWV9YCA6IG1ldGhvZE5hbWU7XG4gICAgICB9XG5cbiAgICAgIGxldCBmaWxlbmFtZSA9IGxpbmVNYXRjaFsyXSAmJiBsaW5lTWF0Y2hbMl0uc3RhcnRzV2l0aCgnZmlsZTovLycpID8gbGluZU1hdGNoWzJdLnNsaWNlKDcpIDogbGluZU1hdGNoWzJdO1xuICAgICAgY29uc3QgaXNOYXRpdmUgPSBsaW5lTWF0Y2hbNV0gPT09ICduYXRpdmUnO1xuXG4gICAgICAvLyBJZiBpdCdzIGEgV2luZG93cyBwYXRoLCB0cmltIHRoZSBsZWFkaW5nIHNsYXNoIHNvIHRoYXQgYC9DOi9mb29gIGJlY29tZXMgYEM6L2Zvb2BcbiAgICAgIGlmIChmaWxlbmFtZSAmJiBmaWxlbmFtZS5tYXRjaCgvXFwvW0EtWl06LykpIHtcbiAgICAgICAgZmlsZW5hbWUgPSBmaWxlbmFtZS5zbGljZSgxKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFmaWxlbmFtZSAmJiBsaW5lTWF0Y2hbNV0gJiYgIWlzTmF0aXZlKSB7XG4gICAgICAgIGZpbGVuYW1lID0gbGluZU1hdGNoWzVdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBmaWxlbmFtZSxcbiAgICAgICAgbW9kdWxlOiBnZXRNb2R1bGUgPyBnZXRNb2R1bGUoZmlsZW5hbWUpIDogdW5kZWZpbmVkLFxuICAgICAgICBmdW5jdGlvbjogZnVuY3Rpb25OYW1lLFxuICAgICAgICBsaW5lbm86IHBhcnNlSW50KGxpbmVNYXRjaFszXSwgMTApIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgY29sbm86IHBhcnNlSW50KGxpbmVNYXRjaFs0XSwgMTApIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgaW5fYXBwOiBmaWxlbmFtZUlzSW5BcHAoZmlsZW5hbWUsIGlzTmF0aXZlKSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKGxpbmUubWF0Y2goRklMRU5BTUVfTUFUQ0gpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBmaWxlbmFtZTogbGluZSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfTtcbn1cblxuZXhwb3J0IHsgZmlsZW5hbWVJc0luQXBwLCBub2RlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub2RlLXN0YWNrLXRyYWNlLmpzLm1hcFxuIl0sIm5hbWVzIjpbImZpbGVuYW1lSXNJbkFwcCIsImZpbGVuYW1lIiwiaXNOYXRpdmUiLCJpc0ludGVybmFsIiwic3RhcnRzV2l0aCIsIm1hdGNoIiwidW5kZWZpbmVkIiwiaW5jbHVkZXMiLCJub2RlIiwiZ2V0TW9kdWxlIiwiRklMRU5BTUVfTUFUQ0giLCJGVUxMX01BVENIIiwibGluZSIsImxpbmVNYXRjaCIsIm9iamVjdCIsIm1ldGhvZCIsImZ1bmN0aW9uTmFtZSIsInR5cGVOYW1lIiwibWV0aG9kTmFtZSIsIm1ldGhvZFN0YXJ0IiwibGFzdEluZGV4T2YiLCJzbGljZSIsIm9iamVjdEVuZCIsImluZGV4T2YiLCJtb2R1bGUiLCJmdW5jdGlvbiIsImxpbmVubyIsInBhcnNlSW50IiwiY29sbm8iLCJpbl9hcHAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/utils/esm/node-stack-trace.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sentry/utils/esm/normalize.js":
/*!*****************************************************!*\
  !*** ./node_modules/@sentry/utils/esm/normalize.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   normalize: () => (/* binding */ normalize),\n/* harmony export */   normalizeToSize: () => (/* binding */ normalizeToSize),\n/* harmony export */   normalizeUrlToBase: () => (/* binding */ normalizeUrlToBase),\n/* harmony export */   walk: () => (/* binding */ visit)\n/* harmony export */ });\n/* harmony import */ var _is_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./is.js */ \"(ssr)/./node_modules/@sentry/utils/esm/is.js\");\n/* harmony import */ var _memo_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./memo.js */ \"(ssr)/./node_modules/@sentry/utils/esm/memo.js\");\n/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./object.js */ \"(ssr)/./node_modules/@sentry/utils/esm/object.js\");\n/* harmony import */ var _stacktrace_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stacktrace.js */ \"(ssr)/./node_modules/@sentry/utils/esm/stacktrace.js\");\n\n\n\n\n/**\n * Recursively normalizes the given object.\n *\n * - Creates a copy to prevent original input mutation\n * - Skips non-enumerable properties\n * - When stringifying, calls `toJSON` if implemented\n * - Removes circular references\n * - Translates non-serializable values (`undefined`/`NaN`/functions) to serializable format\n * - Translates known global objects/classes to a string representations\n * - Takes care of `Error` object serialization\n * - Optionally limits depth of final output\n * - Optionally limits number of properties/elements included in any single object/array\n *\n * @param input The object to be normalized.\n * @param depth The max depth to which to normalize the object. (Anything deeper stringified whole.)\n * @param maxProperties The max number of elements or properties to be included in any single array or\n * object in the normallized output.\n * @returns A normalized version of the object, or `\"**non-serializable**\"` if any errors are thrown during normalization.\n */ // eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction normalize(input, depth = 100, maxProperties = +Infinity) {\n    try {\n        // since we're at the outermost level, we don't provide a key\n        return visit(\"\", input, depth, maxProperties);\n    } catch (err) {\n        return {\n            ERROR: `**non-serializable** (${err})`\n        };\n    }\n}\n/** JSDoc */ function normalizeToSize(// eslint-disable-next-line @typescript-eslint/no-explicit-any\nobject, // Default Node.js REPL depth\ndepth = 3, // 100kB, as 200kB is max payload size, so half sounds reasonable\nmaxSize = 100 * 1024) {\n    const normalized = normalize(object, depth);\n    if (jsonSize(normalized) > maxSize) {\n        return normalizeToSize(object, depth - 1, maxSize);\n    }\n    return normalized;\n}\n/**\n * Visits a node to perform normalization on it\n *\n * @param key The key corresponding to the given node\n * @param value The node to be visited\n * @param depth Optional number indicating the maximum recursion depth\n * @param maxProperties Optional maximum number of properties/elements included in any single object/array\n * @param memo Optional Memo class handling decycling\n */ function visit(key, value, depth = +Infinity, maxProperties = +Infinity, memo = (0,_memo_js__WEBPACK_IMPORTED_MODULE_0__.memoBuilder)()) {\n    const [memoize, unmemoize] = memo;\n    // Get the simple cases out of the way first\n    if (value == null || // this matches null and undefined -> eqeq not eqeqeq\n    [\n        \"number\",\n        \"boolean\",\n        \"string\"\n    ].includes(typeof value) && !(0,_is_js__WEBPACK_IMPORTED_MODULE_1__.isNaN)(value)) {\n        return value;\n    }\n    const stringified = stringifyValue(key, value);\n    // Anything we could potentially dig into more (objects or arrays) will have come back as `\"[object XXXX]\"`.\n    // Everything else will have already been serialized, so if we don't see that pattern, we're done.\n    if (!stringified.startsWith(\"[object \")) {\n        return stringified;\n    }\n    // From here on, we can assert that `value` is either an object or an array.\n    // Do not normalize objects that we know have already been normalized. As a general rule, the\n    // \"__sentry_skip_normalization__\" property should only be used sparingly and only should only be set on objects that\n    // have already been normalized.\n    if (value[\"__sentry_skip_normalization__\"]) {\n        return value;\n    }\n    // We can set `__sentry_override_normalization_depth__` on an object to ensure that from there\n    // We keep a certain amount of depth.\n    // This should be used sparingly, e.g. we use it for the redux integration to ensure we get a certain amount of state.\n    const remainingDepth = typeof value[\"__sentry_override_normalization_depth__\"] === \"number\" ? value[\"__sentry_override_normalization_depth__\"] : depth;\n    // We're also done if we've reached the max depth\n    if (remainingDepth === 0) {\n        // At this point we know `serialized` is a string of the form `\"[object XXXX]\"`. Clean it up so it's just `\"[XXXX]\"`.\n        return stringified.replace(\"object \", \"\");\n    }\n    // If we've already visited this branch, bail out, as it's circular reference. If not, note that we're seeing it now.\n    if (memoize(value)) {\n        return \"[Circular ~]\";\n    }\n    // If the value has a `toJSON` method, we call it to extract more information\n    const valueWithToJSON = value;\n    if (valueWithToJSON && typeof valueWithToJSON.toJSON === \"function\") {\n        try {\n            const jsonValue = valueWithToJSON.toJSON();\n            // We need to normalize the return value of `.toJSON()` in case it has circular references\n            return visit(\"\", jsonValue, remainingDepth - 1, maxProperties, memo);\n        } catch (err) {\n        // pass (The built-in `toJSON` failed, but we can still try to do it ourselves)\n        }\n    }\n    // At this point we know we either have an object or an array, we haven't seen it before, and we're going to recurse\n    // because we haven't yet reached the max depth. Create an accumulator to hold the results of visiting each\n    // property/entry, and keep track of the number of items we add to it.\n    const normalized = Array.isArray(value) ? [] : {};\n    let numAdded = 0;\n    // Before we begin, convert`Error` and`Event` instances into plain objects, since some of each of their relevant\n    // properties are non-enumerable and otherwise would get missed.\n    const visitable = (0,_object_js__WEBPACK_IMPORTED_MODULE_2__.convertToPlainObject)(value);\n    for(const visitKey in visitable){\n        // Avoid iterating over fields in the prototype if they've somehow been exposed to enumeration.\n        if (!Object.prototype.hasOwnProperty.call(visitable, visitKey)) {\n            continue;\n        }\n        if (numAdded >= maxProperties) {\n            normalized[visitKey] = \"[MaxProperties ~]\";\n            break;\n        }\n        // Recursively visit all the child nodes\n        const visitValue = visitable[visitKey];\n        normalized[visitKey] = visit(visitKey, visitValue, remainingDepth - 1, maxProperties, memo);\n        numAdded++;\n    }\n    // Once we've visited all the branches, remove the parent from memo storage\n    unmemoize(value);\n    // Return accumulated values\n    return normalized;\n}\n/* eslint-disable complexity */ /**\n * Stringify the given value. Handles various known special values and types.\n *\n * Not meant to be used on simple primitives which already have a string representation, as it will, for example, turn\n * the number 1231 into \"[Object Number]\", nor on `null`, as it will throw.\n *\n * @param value The value to stringify\n * @returns A stringified representation of the given value\n */ function stringifyValue(key, // this type is a tiny bit of a cheat, since this function does handle NaN (which is technically a number), but for\n// our internal use, it'll do\nvalue) {\n    try {\n        if (key === \"domain\" && value && typeof value === \"object\" && value._events) {\n            return \"[Domain]\";\n        }\n        if (key === \"domainEmitter\") {\n            return \"[DomainEmitter]\";\n        }\n        // It's safe to use `global`, `window`, and `document` here in this manner, as we are asserting using `typeof` first\n        // which won't throw if they are not present.\n        if (typeof global !== \"undefined\" && value === global) {\n            return \"[Global]\";\n        }\n        // eslint-disable-next-line no-restricted-globals\n        if (false) {}\n        // eslint-disable-next-line no-restricted-globals\n        if (typeof document !== \"undefined\" && value === document) {\n            return \"[Document]\";\n        }\n        if ((0,_is_js__WEBPACK_IMPORTED_MODULE_1__.isVueViewModel)(value)) {\n            return \"[VueViewModel]\";\n        }\n        // React's SyntheticEvent thingy\n        if ((0,_is_js__WEBPACK_IMPORTED_MODULE_1__.isSyntheticEvent)(value)) {\n            return \"[SyntheticEvent]\";\n        }\n        if (typeof value === \"number\" && value !== value) {\n            return \"[NaN]\";\n        }\n        if (typeof value === \"function\") {\n            return `[Function: ${(0,_stacktrace_js__WEBPACK_IMPORTED_MODULE_3__.getFunctionName)(value)}]`;\n        }\n        if (typeof value === \"symbol\") {\n            return `[${String(value)}]`;\n        }\n        // stringified BigInts are indistinguishable from regular numbers, so we need to label them to avoid confusion\n        if (typeof value === \"bigint\") {\n            return `[BigInt: ${String(value)}]`;\n        }\n        // Now that we've knocked out all the special cases and the primitives, all we have left are objects. Simply casting\n        // them to strings means that instances of classes which haven't defined their `toStringTag` will just come out as\n        // `\"[object Object]\"`. If we instead look at the constructor's name (which is the same as the name of the class),\n        // we can make sure that only plain objects come out that way.\n        const objName = getConstructorName(value);\n        // Handle HTML Elements\n        if (/^HTML(\\w*)Element$/.test(objName)) {\n            return `[HTMLElement: ${objName}]`;\n        }\n        return `[object ${objName}]`;\n    } catch (err) {\n        return `**non-serializable** (${err})`;\n    }\n}\n/* eslint-enable complexity */ function getConstructorName(value) {\n    const prototype = Object.getPrototypeOf(value);\n    return prototype ? prototype.constructor.name : \"null prototype\";\n}\n/** Calculates bytes size of input string */ function utf8Length(value) {\n    // eslint-disable-next-line no-bitwise\n    return ~-encodeURI(value).split(/%..|./).length;\n}\n/** Calculates bytes size of input object */ // eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction jsonSize(value) {\n    return utf8Length(JSON.stringify(value));\n}\n/**\n * Normalizes URLs in exceptions and stacktraces to a base path so Sentry can fingerprint\n * across platforms and working directory.\n *\n * @param url The URL to be normalized.\n * @param basePath The application base path.\n * @returns The normalized URL.\n */ function normalizeUrlToBase(url, basePath) {\n    const escapedBase = basePath// Backslash to forward\n    .replace(/\\\\/g, \"/\")// Escape RegExp special characters\n    .replace(/[|\\\\{}()[\\]^$+*?.]/g, \"\\\\$&\");\n    let newUrl = url;\n    try {\n        newUrl = decodeURI(url);\n    } catch (_Oo) {\n    // Sometime this breaks\n    }\n    return newUrl.replace(/\\\\/g, \"/\").replace(/webpack:\\/?/g, \"\") // Remove intermediate base path\n    // eslint-disable-next-line @sentry-internal/sdk/no-regexp-constructor\n    .replace(new RegExp(`(file://)?/*${escapedBase}/*`, \"ig\"), \"app:///\");\n}\n //# sourceMappingURL=normalize.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS91dGlscy9lc20vbm9ybWFsaXplLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQWtFO0FBQzFCO0FBQ1c7QUFDRDtBQUVsRDs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBa0JDLEdBQ0QsOERBQThEO0FBQzlELFNBQVNNLFVBQVVDLEtBQUssRUFBRUMsUUFBUSxHQUFHLEVBQUVDLGdCQUFnQixDQUFDQyxRQUFRO0lBQzlELElBQUk7UUFDRiw2REFBNkQ7UUFDN0QsT0FBT0MsTUFBTSxJQUFJSixPQUFPQyxPQUFPQztJQUNqQyxFQUFFLE9BQU9HLEtBQUs7UUFDWixPQUFPO1lBQUVDLE9BQU8sQ0FBQyxzQkFBc0IsRUFBRUQsSUFBSSxDQUFDLENBQUM7UUFBQztJQUNsRDtBQUNGO0FBRUEsVUFBVSxHQUNWLFNBQVNFLGdCQUNQLDhEQUE4RDtBQUM5REMsTUFBTSxFQUNOLDZCQUE2QjtBQUM3QlAsUUFBUSxDQUFDLEVBQ1QsaUVBQWlFO0FBQ2pFUSxVQUFVLE1BQU0sSUFBSTtJQUVwQixNQUFNQyxhQUFhWCxVQUFVUyxRQUFRUDtJQUVyQyxJQUFJVSxTQUFTRCxjQUFjRCxTQUFTO1FBQ2xDLE9BQU9GLGdCQUFnQkMsUUFBUVAsUUFBUSxHQUFHUTtJQUM1QztJQUVBLE9BQU9DO0FBQ1Q7QUFFQTs7Ozs7Ozs7Q0FRQyxHQUNELFNBQVNOLE1BQ1BRLEdBQUcsRUFDSEMsS0FBSyxFQUNMWixRQUFRLENBQUNFLFFBQVEsRUFDakJELGdCQUFnQixDQUFDQyxRQUFRLEVBQ3pCVyxPQUFPbEIscURBQVdBLEVBQUU7SUFFcEIsTUFBTSxDQUFDbUIsU0FBU0MsVUFBVSxHQUFHRjtJQUU3Qiw0Q0FBNEM7SUFDNUMsSUFDRUQsU0FBUyxRQUFRLHFEQUFxRDtJQUNyRTtRQUFDO1FBQVU7UUFBVztLQUFTLENBQUNJLFFBQVEsQ0FBQyxPQUFPSixVQUFVLENBQUNwQiw2Q0FBS0EsQ0FBQ29CLFFBQ2xFO1FBQ0EsT0FBT0E7SUFDVDtJQUVB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QU9DLEdBQ0QsU0FBU3dDLG1CQUFtQkMsR0FBRyxFQUFFQyxRQUFRO0lBQ3ZDLE1BQU1DLGNBQWNELFFBQ2xCLHVCQUF1QjtLQUN0QmpDLE9BQU8sQ0FBQyxPQUFPLElBQ2hCLG1DQUFtQztLQUNsQ0EsT0FBTyxDQUFDLHVCQUF1QjtJQUVsQyxJQUFJbUMsU0FBU0g7SUFDYixJQUFJO1FBQ0ZHLFNBQVNDLFVBQVVKO0lBQ3JCLEVBQUUsT0FBT0ssS0FBSztJQUNaLHVCQUF1QjtJQUN6QjtJQUNBLE9BQ0VGLE9BQ0duQyxPQUFPLENBQUMsT0FBTyxLQUNmQSxPQUFPLENBQUMsZ0JBQWdCLElBQUksZ0NBQWdDO0lBQzdELHNFQUFzRTtLQUNyRUEsT0FBTyxDQUFDLElBQUlzQyxPQUFPLENBQUMsWUFBWSxFQUFFSixZQUFZLEVBQUUsQ0FBQyxFQUFFLE9BQU87QUFFakU7QUFFeUUsQ0FDekUscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb2JyYWxpbmstd2ViLy4vbm9kZV9tb2R1bGVzL0BzZW50cnkvdXRpbHMvZXNtL25vcm1hbGl6ZS5qcz83YjJmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzTmFOLCBpc1Z1ZVZpZXdNb2RlbCwgaXNTeW50aGV0aWNFdmVudCB9IGZyb20gJy4vaXMuanMnO1xuaW1wb3J0IHsgbWVtb0J1aWxkZXIgfSBmcm9tICcuL21lbW8uanMnO1xuaW1wb3J0IHsgY29udmVydFRvUGxhaW5PYmplY3QgfSBmcm9tICcuL29iamVjdC5qcyc7XG5pbXBvcnQgeyBnZXRGdW5jdGlvbk5hbWUgfSBmcm9tICcuL3N0YWNrdHJhY2UuanMnO1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IG5vcm1hbGl6ZXMgdGhlIGdpdmVuIG9iamVjdC5cbiAqXG4gKiAtIENyZWF0ZXMgYSBjb3B5IHRvIHByZXZlbnQgb3JpZ2luYWwgaW5wdXQgbXV0YXRpb25cbiAqIC0gU2tpcHMgbm9uLWVudW1lcmFibGUgcHJvcGVydGllc1xuICogLSBXaGVuIHN0cmluZ2lmeWluZywgY2FsbHMgYHRvSlNPTmAgaWYgaW1wbGVtZW50ZWRcbiAqIC0gUmVtb3ZlcyBjaXJjdWxhciByZWZlcmVuY2VzXG4gKiAtIFRyYW5zbGF0ZXMgbm9uLXNlcmlhbGl6YWJsZSB2YWx1ZXMgKGB1bmRlZmluZWRgL2BOYU5gL2Z1bmN0aW9ucykgdG8gc2VyaWFsaXphYmxlIGZvcm1hdFxuICogLSBUcmFuc2xhdGVzIGtub3duIGdsb2JhbCBvYmplY3RzL2NsYXNzZXMgdG8gYSBzdHJpbmcgcmVwcmVzZW50YXRpb25zXG4gKiAtIFRha2VzIGNhcmUgb2YgYEVycm9yYCBvYmplY3Qgc2VyaWFsaXphdGlvblxuICogLSBPcHRpb25hbGx5IGxpbWl0cyBkZXB0aCBvZiBmaW5hbCBvdXRwdXRcbiAqIC0gT3B0aW9uYWxseSBsaW1pdHMgbnVtYmVyIG9mIHByb3BlcnRpZXMvZWxlbWVudHMgaW5jbHVkZWQgaW4gYW55IHNpbmdsZSBvYmplY3QvYXJyYXlcbiAqXG4gKiBAcGFyYW0gaW5wdXQgVGhlIG9iamVjdCB0byBiZSBub3JtYWxpemVkLlxuICogQHBhcmFtIGRlcHRoIFRoZSBtYXggZGVwdGggdG8gd2hpY2ggdG8gbm9ybWFsaXplIHRoZSBvYmplY3QuIChBbnl0aGluZyBkZWVwZXIgc3RyaW5naWZpZWQgd2hvbGUuKVxuICogQHBhcmFtIG1heFByb3BlcnRpZXMgVGhlIG1heCBudW1iZXIgb2YgZWxlbWVudHMgb3IgcHJvcGVydGllcyB0byBiZSBpbmNsdWRlZCBpbiBhbnkgc2luZ2xlIGFycmF5IG9yXG4gKiBvYmplY3QgaW4gdGhlIG5vcm1hbGxpemVkIG91dHB1dC5cbiAqIEByZXR1cm5zIEEgbm9ybWFsaXplZCB2ZXJzaW9uIG9mIHRoZSBvYmplY3QsIG9yIGBcIioqbm9uLXNlcmlhbGl6YWJsZSoqXCJgIGlmIGFueSBlcnJvcnMgYXJlIHRocm93biBkdXJpbmcgbm9ybWFsaXphdGlvbi5cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIG5vcm1hbGl6ZShpbnB1dCwgZGVwdGggPSAxMDAsIG1heFByb3BlcnRpZXMgPSArSW5maW5pdHkpIHtcbiAgdHJ5IHtcbiAgICAvLyBzaW5jZSB3ZSdyZSBhdCB0aGUgb3V0ZXJtb3N0IGxldmVsLCB3ZSBkb24ndCBwcm92aWRlIGEga2V5XG4gICAgcmV0dXJuIHZpc2l0KCcnLCBpbnB1dCwgZGVwdGgsIG1heFByb3BlcnRpZXMpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4geyBFUlJPUjogYCoqbm9uLXNlcmlhbGl6YWJsZSoqICgke2Vycn0pYCB9O1xuICB9XG59XG5cbi8qKiBKU0RvYyAqL1xuZnVuY3Rpb24gbm9ybWFsaXplVG9TaXplKFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBvYmplY3QsXG4gIC8vIERlZmF1bHQgTm9kZS5qcyBSRVBMIGRlcHRoXG4gIGRlcHRoID0gMyxcbiAgLy8gMTAwa0IsIGFzIDIwMGtCIGlzIG1heCBwYXlsb2FkIHNpemUsIHNvIGhhbGYgc291bmRzIHJlYXNvbmFibGVcbiAgbWF4U2l6ZSA9IDEwMCAqIDEwMjQsXG4pIHtcbiAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZShvYmplY3QsIGRlcHRoKTtcblxuICBpZiAoanNvblNpemUobm9ybWFsaXplZCkgPiBtYXhTaXplKSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZVRvU2l6ZShvYmplY3QsIGRlcHRoIC0gMSwgbWF4U2l6ZSk7XG4gIH1cblxuICByZXR1cm4gbm9ybWFsaXplZCA7XG59XG5cbi8qKlxuICogVmlzaXRzIGEgbm9kZSB0byBwZXJmb3JtIG5vcm1hbGl6YXRpb24gb24gaXRcbiAqXG4gKiBAcGFyYW0ga2V5IFRoZSBrZXkgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gbm9kZVxuICogQHBhcmFtIHZhbHVlIFRoZSBub2RlIHRvIGJlIHZpc2l0ZWRcbiAqIEBwYXJhbSBkZXB0aCBPcHRpb25hbCBudW1iZXIgaW5kaWNhdGluZyB0aGUgbWF4aW11bSByZWN1cnNpb24gZGVwdGhcbiAqIEBwYXJhbSBtYXhQcm9wZXJ0aWVzIE9wdGlvbmFsIG1heGltdW0gbnVtYmVyIG9mIHByb3BlcnRpZXMvZWxlbWVudHMgaW5jbHVkZWQgaW4gYW55IHNpbmdsZSBvYmplY3QvYXJyYXlcbiAqIEBwYXJhbSBtZW1vIE9wdGlvbmFsIE1lbW8gY2xhc3MgaGFuZGxpbmcgZGVjeWNsaW5nXG4gKi9cbmZ1bmN0aW9uIHZpc2l0KFxuICBrZXksXG4gIHZhbHVlLFxuICBkZXB0aCA9ICtJbmZpbml0eSxcbiAgbWF4UHJvcGVydGllcyA9ICtJbmZpbml0eSxcbiAgbWVtbyA9IG1lbW9CdWlsZGVyKCksXG4pIHtcbiAgY29uc3QgW21lbW9pemUsIHVubWVtb2l6ZV0gPSBtZW1vO1xuXG4gIC8vIEdldCB0aGUgc2ltcGxlIGNhc2VzIG91dCBvZiB0aGUgd2F5IGZpcnN0XG4gIGlmIChcbiAgICB2YWx1ZSA9PSBudWxsIHx8IC8vIHRoaXMgbWF0Y2hlcyBudWxsIGFuZCB1bmRlZmluZWQgLT4gZXFlcSBub3QgZXFlcWVxXG4gICAgKFsnbnVtYmVyJywgJ2Jvb2xlYW4nLCAnc3RyaW5nJ10uaW5jbHVkZXModHlwZW9mIHZhbHVlKSAmJiAhaXNOYU4odmFsdWUpKVxuICApIHtcbiAgICByZXR1cm4gdmFsdWUgO1xuICB9XG5cbiAgY29uc3Qgc3RyaW5naWZpZWQgPSBzdHJpbmdpZnlWYWx1ZShrZXksIHZhbHVlKTtcblxuICAvLyBBbnl0aGluZyB3ZSBjb3VsZCBwb3RlbnRpYWxseSBkaWcgaW50byBtb3JlIChvYmplY3RzIG9yIGFycmF5cykgd2lsbCBoYXZlIGNvbWUgYmFjayBhcyBgXCJbb2JqZWN0IFhYWFhdXCJgLlxuICAvLyBFdmVyeXRoaW5nIGVsc2Ugd2lsbCBoYXZlIGFscmVhZHkgYmVlbiBzZXJpYWxpemVkLCBzbyBpZiB3ZSBkb24ndCBzZWUgdGhhdCBwYXR0ZXJuLCB3ZSdyZSBkb25lLlxuICBpZiAoIXN0cmluZ2lmaWVkLnN0YXJ0c1dpdGgoJ1tvYmplY3QgJykpIHtcbiAgICByZXR1cm4gc3RyaW5naWZpZWQ7XG4gIH1cblxuICAvLyBGcm9tIGhlcmUgb24sIHdlIGNhbiBhc3NlcnQgdGhhdCBgdmFsdWVgIGlzIGVpdGhlciBhbiBvYmplY3Qgb3IgYW4gYXJyYXkuXG5cbiAgLy8gRG8gbm90IG5vcm1hbGl6ZSBvYmplY3RzIHRoYXQgd2Uga25vdyBoYXZlIGFscmVhZHkgYmVlbiBub3JtYWxpemVkLiBBcyBhIGdlbmVyYWwgcnVsZSwgdGhlXG4gIC8vIFwiX19zZW50cnlfc2tpcF9ub3JtYWxpemF0aW9uX19cIiBwcm9wZXJ0eSBzaG91bGQgb25seSBiZSB1c2VkIHNwYXJpbmdseSBhbmQgb25seSBzaG91bGQgb25seSBiZSBzZXQgb24gb2JqZWN0cyB0aGF0XG4gIC8vIGhhdmUgYWxyZWFkeSBiZWVuIG5vcm1hbGl6ZWQuXG4gIGlmICgodmFsdWUgKVsnX19zZW50cnlfc2tpcF9ub3JtYWxpemF0aW9uX18nXSkge1xuICAgIHJldHVybiB2YWx1ZSA7XG4gIH1cblxuICAvLyBXZSBjYW4gc2V0IGBfX3NlbnRyeV9vdmVycmlkZV9ub3JtYWxpemF0aW9uX2RlcHRoX19gIG9uIGFuIG9iamVjdCB0byBlbnN1cmUgdGhhdCBmcm9tIHRoZXJlXG4gIC8vIFdlIGtlZXAgYSBjZXJ0YWluIGFtb3VudCBvZiBkZXB0aC5cbiAgLy8gVGhpcyBzaG91bGQgYmUgdXNlZCBzcGFyaW5nbHksIGUuZy4gd2UgdXNlIGl0IGZvciB0aGUgcmVkdXggaW50ZWdyYXRpb24gdG8gZW5zdXJlIHdlIGdldCBhIGNlcnRhaW4gYW1vdW50IG9mIHN0YXRlLlxuICBjb25zdCByZW1haW5pbmdEZXB0aCA9XG4gICAgdHlwZW9mICh2YWx1ZSApWydfX3NlbnRyeV9vdmVycmlkZV9ub3JtYWxpemF0aW9uX2RlcHRoX18nXSA9PT0gJ251bWJlcidcbiAgICAgID8gKCh2YWx1ZSApWydfX3NlbnRyeV9vdmVycmlkZV9ub3JtYWxpemF0aW9uX2RlcHRoX18nXSApXG4gICAgICA6IGRlcHRoO1xuXG4gIC8vIFdlJ3JlIGFsc28gZG9uZSBpZiB3ZSd2ZSByZWFjaGVkIHRoZSBtYXggZGVwdGhcbiAgaWYgKHJlbWFpbmluZ0RlcHRoID09PSAwKSB7XG4gICAgLy8gQXQgdGhpcyBwb2ludCB3ZSBrbm93IGBzZXJpYWxpemVkYCBpcyBhIHN0cmluZyBvZiB0aGUgZm9ybSBgXCJbb2JqZWN0IFhYWFhdXCJgLiBDbGVhbiBpdCB1cCBzbyBpdCdzIGp1c3QgYFwiW1hYWFhdXCJgLlxuICAgIHJldHVybiBzdHJpbmdpZmllZC5yZXBsYWNlKCdvYmplY3QgJywgJycpO1xuICB9XG5cbiAgLy8gSWYgd2UndmUgYWxyZWFkeSB2aXNpdGVkIHRoaXMgYnJhbmNoLCBiYWlsIG91dCwgYXMgaXQncyBjaXJjdWxhciByZWZlcmVuY2UuIElmIG5vdCwgbm90ZSB0aGF0IHdlJ3JlIHNlZWluZyBpdCBub3cuXG4gIGlmIChtZW1vaXplKHZhbHVlKSkge1xuICAgIHJldHVybiAnW0NpcmN1bGFyIH5dJztcbiAgfVxuXG4gIC8vIElmIHRoZSB2YWx1ZSBoYXMgYSBgdG9KU09OYCBtZXRob2QsIHdlIGNhbGwgaXQgdG8gZXh0cmFjdCBtb3JlIGluZm9ybWF0aW9uXG4gIGNvbnN0IHZhbHVlV2l0aFRvSlNPTiA9IHZhbHVlIDtcbiAgaWYgKHZhbHVlV2l0aFRvSlNPTiAmJiB0eXBlb2YgdmFsdWVXaXRoVG9KU09OLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBqc29uVmFsdWUgPSB2YWx1ZVdpdGhUb0pTT04udG9KU09OKCk7XG4gICAgICAvLyBXZSBuZWVkIHRvIG5vcm1hbGl6ZSB0aGUgcmV0dXJuIHZhbHVlIG9mIGAudG9KU09OKClgIGluIGNhc2UgaXQgaGFzIGNpcmN1bGFyIHJlZmVyZW5jZXNcbiAgICAgIHJldHVybiB2aXNpdCgnJywganNvblZhbHVlLCByZW1haW5pbmdEZXB0aCAtIDEsIG1heFByb3BlcnRpZXMsIG1lbW8pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gcGFzcyAoVGhlIGJ1aWx0LWluIGB0b0pTT05gIGZhaWxlZCwgYnV0IHdlIGNhbiBzdGlsbCB0cnkgdG8gZG8gaXQgb3Vyc2VsdmVzKVxuICAgIH1cbiAgfVxuXG4gIC8vIEF0IHRoaXMgcG9pbnQgd2Uga25vdyB3ZSBlaXRoZXIgaGF2ZSBhbiBvYmplY3Qgb3IgYW4gYXJyYXksIHdlIGhhdmVuJ3Qgc2VlbiBpdCBiZWZvcmUsIGFuZCB3ZSdyZSBnb2luZyB0byByZWN1cnNlXG4gIC8vIGJlY2F1c2Ugd2UgaGF2ZW4ndCB5ZXQgcmVhY2hlZCB0aGUgbWF4IGRlcHRoLiBDcmVhdGUgYW4gYWNjdW11bGF0b3IgdG8gaG9sZCB0aGUgcmVzdWx0cyBvZiB2aXNpdGluZyBlYWNoXG4gIC8vIHByb3BlcnR5L2VudHJ5LCBhbmQga2VlcCB0cmFjayBvZiB0aGUgbnVtYmVyIG9mIGl0ZW1zIHdlIGFkZCB0byBpdC5cbiAgY29uc3Qgbm9ybWFsaXplZCA9IChBcnJheS5pc0FycmF5KHZhbHVlKSA/IFtdIDoge30pIDtcbiAgbGV0IG51bUFkZGVkID0gMDtcblxuICAvLyBCZWZvcmUgd2UgYmVnaW4sIGNvbnZlcnRgRXJyb3JgIGFuZGBFdmVudGAgaW5zdGFuY2VzIGludG8gcGxhaW4gb2JqZWN0cywgc2luY2Ugc29tZSBvZiBlYWNoIG9mIHRoZWlyIHJlbGV2YW50XG4gIC8vIHByb3BlcnRpZXMgYXJlIG5vbi1lbnVtZXJhYmxlIGFuZCBvdGhlcndpc2Ugd291bGQgZ2V0IG1pc3NlZC5cbiAgY29uc3QgdmlzaXRhYmxlID0gY29udmVydFRvUGxhaW5PYmplY3QodmFsdWUgKTtcblxuICBmb3IgKGNvbnN0IHZpc2l0S2V5IGluIHZpc2l0YWJsZSkge1xuICAgIC8vIEF2b2lkIGl0ZXJhdGluZyBvdmVyIGZpZWxkcyBpbiB0aGUgcHJvdG90eXBlIGlmIHRoZXkndmUgc29tZWhvdyBiZWVuIGV4cG9zZWQgdG8gZW51bWVyYXRpb24uXG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmlzaXRhYmxlLCB2aXNpdEtleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChudW1BZGRlZCA+PSBtYXhQcm9wZXJ0aWVzKSB7XG4gICAgICBub3JtYWxpemVkW3Zpc2l0S2V5XSA9ICdbTWF4UHJvcGVydGllcyB+XSc7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBSZWN1cnNpdmVseSB2aXNpdCBhbGwgdGhlIGNoaWxkIG5vZGVzXG4gICAgY29uc3QgdmlzaXRWYWx1ZSA9IHZpc2l0YWJsZVt2aXNpdEtleV07XG4gICAgbm9ybWFsaXplZFt2aXNpdEtleV0gPSB2aXNpdCh2aXNpdEtleSwgdmlzaXRWYWx1ZSwgcmVtYWluaW5nRGVwdGggLSAxLCBtYXhQcm9wZXJ0aWVzLCBtZW1vKTtcblxuICAgIG51bUFkZGVkKys7XG4gIH1cblxuICAvLyBPbmNlIHdlJ3ZlIHZpc2l0ZWQgYWxsIHRoZSBicmFuY2hlcywgcmVtb3ZlIHRoZSBwYXJlbnQgZnJvbSBtZW1vIHN0b3JhZ2VcbiAgdW5tZW1vaXplKHZhbHVlKTtcblxuICAvLyBSZXR1cm4gYWNjdW11bGF0ZWQgdmFsdWVzXG4gIHJldHVybiBub3JtYWxpemVkO1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBjb21wbGV4aXR5ICovXG4vKipcbiAqIFN0cmluZ2lmeSB0aGUgZ2l2ZW4gdmFsdWUuIEhhbmRsZXMgdmFyaW91cyBrbm93biBzcGVjaWFsIHZhbHVlcyBhbmQgdHlwZXMuXG4gKlxuICogTm90IG1lYW50IHRvIGJlIHVzZWQgb24gc2ltcGxlIHByaW1pdGl2ZXMgd2hpY2ggYWxyZWFkeSBoYXZlIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uLCBhcyBpdCB3aWxsLCBmb3IgZXhhbXBsZSwgdHVyblxuICogdGhlIG51bWJlciAxMjMxIGludG8gXCJbT2JqZWN0IE51bWJlcl1cIiwgbm9yIG9uIGBudWxsYCwgYXMgaXQgd2lsbCB0aHJvdy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIHN0cmluZ2lmeVxuICogQHJldHVybnMgQSBzdHJpbmdpZmllZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gdmFsdWVcbiAqL1xuZnVuY3Rpb24gc3RyaW5naWZ5VmFsdWUoXG4gIGtleSxcbiAgLy8gdGhpcyB0eXBlIGlzIGEgdGlueSBiaXQgb2YgYSBjaGVhdCwgc2luY2UgdGhpcyBmdW5jdGlvbiBkb2VzIGhhbmRsZSBOYU4gKHdoaWNoIGlzIHRlY2huaWNhbGx5IGEgbnVtYmVyKSwgYnV0IGZvclxuICAvLyBvdXIgaW50ZXJuYWwgdXNlLCBpdCdsbCBkb1xuICB2YWx1ZSxcbikge1xuICB0cnkge1xuICAgIGlmIChrZXkgPT09ICdkb21haW4nICYmIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgKHZhbHVlICkuX2V2ZW50cykge1xuICAgICAgcmV0dXJuICdbRG9tYWluXSc7XG4gICAgfVxuXG4gICAgaWYgKGtleSA9PT0gJ2RvbWFpbkVtaXR0ZXInKSB7XG4gICAgICByZXR1cm4gJ1tEb21haW5FbWl0dGVyXSc7XG4gICAgfVxuXG4gICAgLy8gSXQncyBzYWZlIHRvIHVzZSBgZ2xvYmFsYCwgYHdpbmRvd2AsIGFuZCBgZG9jdW1lbnRgIGhlcmUgaW4gdGhpcyBtYW5uZXIsIGFzIHdlIGFyZSBhc3NlcnRpbmcgdXNpbmcgYHR5cGVvZmAgZmlyc3RcbiAgICAvLyB3aGljaCB3b24ndCB0aHJvdyBpZiB0aGV5IGFyZSBub3QgcHJlc2VudC5cblxuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSA9PT0gZ2xvYmFsKSB7XG4gICAgICByZXR1cm4gJ1tHbG9iYWxdJztcbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlID09PSB3aW5kb3cpIHtcbiAgICAgIHJldHVybiAnW1dpbmRvd10nO1xuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSA9PT0gZG9jdW1lbnQpIHtcbiAgICAgIHJldHVybiAnW0RvY3VtZW50XSc7XG4gICAgfVxuXG4gICAgaWYgKGlzVnVlVmlld01vZGVsKHZhbHVlKSkge1xuICAgICAgcmV0dXJuICdbVnVlVmlld01vZGVsXSc7XG4gICAgfVxuXG4gICAgLy8gUmVhY3QncyBTeW50aGV0aWNFdmVudCB0aGluZ3lcbiAgICBpZiAoaXNTeW50aGV0aWNFdmVudCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiAnW1N5bnRoZXRpY0V2ZW50XSc7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgdmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gJ1tOYU5dJztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gYFtGdW5jdGlvbjogJHtnZXRGdW5jdGlvbk5hbWUodmFsdWUpfV1gO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnKSB7XG4gICAgICByZXR1cm4gYFske1N0cmluZyh2YWx1ZSl9XWA7XG4gICAgfVxuXG4gICAgLy8gc3RyaW5naWZpZWQgQmlnSW50cyBhcmUgaW5kaXN0aW5ndWlzaGFibGUgZnJvbSByZWd1bGFyIG51bWJlcnMsIHNvIHdlIG5lZWQgdG8gbGFiZWwgdGhlbSB0byBhdm9pZCBjb25mdXNpb25cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50Jykge1xuICAgICAgcmV0dXJuIGBbQmlnSW50OiAke1N0cmluZyh2YWx1ZSl9XWA7XG4gICAgfVxuXG4gICAgLy8gTm93IHRoYXQgd2UndmUga25vY2tlZCBvdXQgYWxsIHRoZSBzcGVjaWFsIGNhc2VzIGFuZCB0aGUgcHJpbWl0aXZlcywgYWxsIHdlIGhhdmUgbGVmdCBhcmUgb2JqZWN0cy4gU2ltcGx5IGNhc3RpbmdcbiAgICAvLyB0aGVtIHRvIHN0cmluZ3MgbWVhbnMgdGhhdCBpbnN0YW5jZXMgb2YgY2xhc3NlcyB3aGljaCBoYXZlbid0IGRlZmluZWQgdGhlaXIgYHRvU3RyaW5nVGFnYCB3aWxsIGp1c3QgY29tZSBvdXQgYXNcbiAgICAvLyBgXCJbb2JqZWN0IE9iamVjdF1cImAuIElmIHdlIGluc3RlYWQgbG9vayBhdCB0aGUgY29uc3RydWN0b3IncyBuYW1lICh3aGljaCBpcyB0aGUgc2FtZSBhcyB0aGUgbmFtZSBvZiB0aGUgY2xhc3MpLFxuICAgIC8vIHdlIGNhbiBtYWtlIHN1cmUgdGhhdCBvbmx5IHBsYWluIG9iamVjdHMgY29tZSBvdXQgdGhhdCB3YXkuXG4gICAgY29uc3Qgb2JqTmFtZSA9IGdldENvbnN0cnVjdG9yTmFtZSh2YWx1ZSk7XG5cbiAgICAvLyBIYW5kbGUgSFRNTCBFbGVtZW50c1xuICAgIGlmICgvXkhUTUwoXFx3KilFbGVtZW50JC8udGVzdChvYmpOYW1lKSkge1xuICAgICAgcmV0dXJuIGBbSFRNTEVsZW1lbnQ6ICR7b2JqTmFtZX1dYDtcbiAgICB9XG5cbiAgICByZXR1cm4gYFtvYmplY3QgJHtvYmpOYW1lfV1gO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gYCoqbm9uLXNlcmlhbGl6YWJsZSoqICgke2Vycn0pYDtcbiAgfVxufVxuLyogZXNsaW50LWVuYWJsZSBjb21wbGV4aXR5ICovXG5cbmZ1bmN0aW9uIGdldENvbnN0cnVjdG9yTmFtZSh2YWx1ZSkge1xuICBjb25zdCBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuXG4gIHJldHVybiBwcm90b3R5cGUgPyBwcm90b3R5cGUuY29uc3RydWN0b3IubmFtZSA6ICdudWxsIHByb3RvdHlwZSc7XG59XG5cbi8qKiBDYWxjdWxhdGVzIGJ5dGVzIHNpemUgb2YgaW5wdXQgc3RyaW5nICovXG5mdW5jdGlvbiB1dGY4TGVuZ3RoKHZhbHVlKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gIHJldHVybiB+LWVuY29kZVVSSSh2YWx1ZSkuc3BsaXQoLyUuLnwuLykubGVuZ3RoO1xufVxuXG4vKiogQ2FsY3VsYXRlcyBieXRlcyBzaXplIG9mIGlucHV0IG9iamVjdCAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIGpzb25TaXplKHZhbHVlKSB7XG4gIHJldHVybiB1dGY4TGVuZ3RoKEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG59XG5cbi8qKlxuICogTm9ybWFsaXplcyBVUkxzIGluIGV4Y2VwdGlvbnMgYW5kIHN0YWNrdHJhY2VzIHRvIGEgYmFzZSBwYXRoIHNvIFNlbnRyeSBjYW4gZmluZ2VycHJpbnRcbiAqIGFjcm9zcyBwbGF0Zm9ybXMgYW5kIHdvcmtpbmcgZGlyZWN0b3J5LlxuICpcbiAqIEBwYXJhbSB1cmwgVGhlIFVSTCB0byBiZSBub3JtYWxpemVkLlxuICogQHBhcmFtIGJhc2VQYXRoIFRoZSBhcHBsaWNhdGlvbiBiYXNlIHBhdGguXG4gKiBAcmV0dXJucyBUaGUgbm9ybWFsaXplZCBVUkwuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVVybFRvQmFzZSh1cmwsIGJhc2VQYXRoKSB7XG4gIGNvbnN0IGVzY2FwZWRCYXNlID0gYmFzZVBhdGhcbiAgICAvLyBCYWNrc2xhc2ggdG8gZm9yd2FyZFxuICAgIC5yZXBsYWNlKC9cXFxcL2csICcvJylcbiAgICAvLyBFc2NhcGUgUmVnRXhwIHNwZWNpYWwgY2hhcmFjdGVyc1xuICAgIC5yZXBsYWNlKC9bfFxcXFx7fSgpW1xcXV4kKyo/Ll0vZywgJ1xcXFwkJicpO1xuXG4gIGxldCBuZXdVcmwgPSB1cmw7XG4gIHRyeSB7XG4gICAgbmV3VXJsID0gZGVjb2RlVVJJKHVybCk7XG4gIH0gY2F0Y2ggKF9Pbykge1xuICAgIC8vIFNvbWV0aW1lIHRoaXMgYnJlYWtzXG4gIH1cbiAgcmV0dXJuIChcbiAgICBuZXdVcmxcbiAgICAgIC5yZXBsYWNlKC9cXFxcL2csICcvJylcbiAgICAgIC5yZXBsYWNlKC93ZWJwYWNrOlxcLz8vZywgJycpIC8vIFJlbW92ZSBpbnRlcm1lZGlhdGUgYmFzZSBwYXRoXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHNlbnRyeS1pbnRlcm5hbC9zZGsvbm8tcmVnZXhwLWNvbnN0cnVjdG9yXG4gICAgICAucmVwbGFjZShuZXcgUmVnRXhwKGAoZmlsZTovLyk/Lyoke2VzY2FwZWRCYXNlfS8qYCwgJ2lnJyksICdhcHA6Ly8vJylcbiAgKTtcbn1cblxuZXhwb3J0IHsgbm9ybWFsaXplLCBub3JtYWxpemVUb1NpemUsIG5vcm1hbGl6ZVVybFRvQmFzZSwgdmlzaXQgYXMgd2FsayB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm9ybWFsaXplLmpzLm1hcFxuIl0sIm5hbWVzIjpbImlzTmFOIiwiaXNWdWVWaWV3TW9kZWwiLCJpc1N5bnRoZXRpY0V2ZW50IiwibWVtb0J1aWxkZXIiLCJjb252ZXJ0VG9QbGFpbk9iamVjdCIsImdldEZ1bmN0aW9uTmFtZSIsIm5vcm1hbGl6ZSIsImlucHV0IiwiZGVwdGgiLCJtYXhQcm9wZXJ0aWVzIiwiSW5maW5pdHkiLCJ2aXNpdCIsImVyciIsIkVSUk9SIiwibm9ybWFsaXplVG9TaXplIiwib2JqZWN0IiwibWF4U2l6ZSIsIm5vcm1hbGl6ZWQiLCJqc29uU2l6ZSIsImtleSIsInZhbHVlIiwibWVtbyIsIm1lbW9pemUiLCJ1bm1lbW9pemUiLCJpbmNsdWRlcyIsInN0cmluZ2lmaWVkIiwic3RyaW5naWZ5VmFsdWUiLCJzdGFydHNXaXRoIiwicmVtYWluaW5nRGVwdGgiLCJyZXBsYWNlIiwidmFsdWVXaXRoVG9KU09OIiwidG9KU09OIiwianNvblZhbHVlIiwiQXJyYXkiLCJpc0FycmF5IiwibnVtQWRkZWQiLCJ2aXNpdGFibGUiLCJ2aXNpdEtleSIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsInZpc2l0VmFsdWUiLCJfZXZlbnRzIiwiZ2xvYmFsIiwid2luZG93IiwiZG9jdW1lbnQiLCJTdHJpbmciLCJvYmpOYW1lIiwiZ2V0Q29uc3RydWN0b3JOYW1lIiwidGVzdCIsImdldFByb3RvdHlwZU9mIiwiY29uc3RydWN0b3IiLCJuYW1lIiwidXRmOExlbmd0aCIsImVuY29kZVVSSSIsInNwbGl0IiwibGVuZ3RoIiwiSlNPTiIsInN0cmluZ2lmeSIsIm5vcm1hbGl6ZVVybFRvQmFzZSIsInVybCIsImJhc2VQYXRoIiwiZXNjYXBlZEJhc2UiLCJuZXdVcmwiLCJkZWNvZGVVUkkiLCJfT28iLCJSZWdFeHAiLCJ3YWxrIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/utils/esm/normalize.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sentry/utils/esm/object.js":
/*!**************************************************!*\
  !*** ./node_modules/@sentry/utils/esm/object.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addNonEnumerableProperty: () => (/* binding */ addNonEnumerableProperty),\n/* harmony export */   convertToPlainObject: () => (/* binding */ convertToPlainObject),\n/* harmony export */   dropUndefinedKeys: () => (/* binding */ dropUndefinedKeys),\n/* harmony export */   extractExceptionKeysForMessage: () => (/* binding */ extractExceptionKeysForMessage),\n/* harmony export */   fill: () => (/* binding */ fill),\n/* harmony export */   getOriginalFunction: () => (/* binding */ getOriginalFunction),\n/* harmony export */   markFunctionWrapped: () => (/* binding */ markFunctionWrapped),\n/* harmony export */   objectify: () => (/* binding */ objectify),\n/* harmony export */   urlEncode: () => (/* binding */ urlEncode)\n/* harmony export */ });\n/* harmony import */ var _browser_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./browser.js */ \"(ssr)/./node_modules/@sentry/utils/esm/browser.js\");\n/* harmony import */ var _debug_build_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./debug-build.js */ \"(ssr)/./node_modules/@sentry/utils/esm/debug-build.js\");\n/* harmony import */ var _is_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./is.js */ \"(ssr)/./node_modules/@sentry/utils/esm/is.js\");\n/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./logger.js */ \"(ssr)/./node_modules/@sentry/utils/esm/logger.js\");\n/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./string.js */ \"(ssr)/./node_modules/@sentry/utils/esm/string.js\");\n\n\n\n\n\n/**\n * Replace a method in an object with a wrapped version of itself.\n *\n * @param source An object that contains a method to be wrapped.\n * @param name The name of the method to be wrapped.\n * @param replacementFactory A higher-order function that takes the original version of the given method and returns a\n * wrapped version. Note: The function returned by `replacementFactory` needs to be a non-arrow function, in order to\n * preserve the correct value of `this`, and the original method must be called using `origMethod.call(this, <other\n * args>)` or `origMethod.apply(this, [<other args>])` (rather than being called directly), again to preserve `this`.\n * @returns void\n */ function fill(source, name, replacementFactory) {\n    if (!(name in source)) {\n        return;\n    }\n    const original = source[name];\n    const wrapped = replacementFactory(original);\n    // Make sure it's a function first, as we need to attach an empty prototype for `defineProperties` to work\n    // otherwise it'll throw \"TypeError: Object.defineProperties called on non-object\"\n    if (typeof wrapped === \"function\") {\n        markFunctionWrapped(wrapped, original);\n    }\n    source[name] = wrapped;\n}\n/**\n * Defines a non-enumerable property on the given object.\n *\n * @param obj The object on which to set the property\n * @param name The name of the property to be set\n * @param value The value to which to set the property\n */ function addNonEnumerableProperty(obj, name, value) {\n    try {\n        Object.defineProperty(obj, name, {\n            // enumerable: false, // the default, so we can save on bundle size by not explicitly setting it\n            value: value,\n            writable: true,\n            configurable: true\n        });\n    } catch (o_O) {\n        _debug_build_js__WEBPACK_IMPORTED_MODULE_0__.DEBUG_BUILD && _logger_js__WEBPACK_IMPORTED_MODULE_1__.logger.log(`Failed to add non-enumerable property \"${name}\" to object`, obj);\n    }\n}\n/**\n * Remembers the original function on the wrapped function and\n * patches up the prototype.\n *\n * @param wrapped the wrapper function\n * @param original the original function that gets wrapped\n */ function markFunctionWrapped(wrapped, original) {\n    try {\n        const proto = original.prototype || {};\n        wrapped.prototype = original.prototype = proto;\n        addNonEnumerableProperty(wrapped, \"__sentry_original__\", original);\n    } catch (o_O) {} // eslint-disable-line no-empty\n}\n/**\n * This extracts the original function if available.  See\n * `markFunctionWrapped` for more information.\n *\n * @param func the function to unwrap\n * @returns the unwrapped version of the function if available.\n */ function getOriginalFunction(func) {\n    return func.__sentry_original__;\n}\n/**\n * Encodes given object into url-friendly format\n *\n * @param object An object that contains serializable values\n * @returns string Encoded\n */ function urlEncode(object) {\n    return Object.keys(object).map((key)=>`${encodeURIComponent(key)}=${encodeURIComponent(object[key])}`).join(\"&\");\n}\n/**\n * Transforms any `Error` or `Event` into a plain object with all of their enumerable properties, and some of their\n * non-enumerable properties attached.\n *\n * @param value Initial source that we have to transform in order for it to be usable by the serializer\n * @returns An Event or Error turned into an object - or the value argurment itself, when value is neither an Event nor\n *  an Error.\n */ function convertToPlainObject(value) {\n    if ((0,_is_js__WEBPACK_IMPORTED_MODULE_2__.isError)(value)) {\n        return {\n            message: value.message,\n            name: value.name,\n            stack: value.stack,\n            ...getOwnProperties(value)\n        };\n    } else if ((0,_is_js__WEBPACK_IMPORTED_MODULE_2__.isEvent)(value)) {\n        const newObj = {\n            type: value.type,\n            target: serializeEventTarget(value.target),\n            currentTarget: serializeEventTarget(value.currentTarget),\n            ...getOwnProperties(value)\n        };\n        if (typeof CustomEvent !== \"undefined\" && (0,_is_js__WEBPACK_IMPORTED_MODULE_2__.isInstanceOf)(value, CustomEvent)) {\n            newObj.detail = value.detail;\n        }\n        return newObj;\n    } else {\n        return value;\n    }\n}\n/** Creates a string representation of the target of an `Event` object */ function serializeEventTarget(target) {\n    try {\n        return (0,_is_js__WEBPACK_IMPORTED_MODULE_2__.isElement)(target) ? (0,_browser_js__WEBPACK_IMPORTED_MODULE_3__.htmlTreeAsString)(target) : Object.prototype.toString.call(target);\n    } catch (_oO) {\n        return \"<unknown>\";\n    }\n}\n/** Filters out all but an object's own properties */ function getOwnProperties(obj) {\n    if (typeof obj === \"object\" && obj !== null) {\n        const extractedProps = {};\n        for(const property in obj){\n            if (Object.prototype.hasOwnProperty.call(obj, property)) {\n                extractedProps[property] = obj[property];\n            }\n        }\n        return extractedProps;\n    } else {\n        return {};\n    }\n}\n/**\n * Given any captured exception, extract its keys and create a sorted\n * and truncated list that will be used inside the event message.\n * eg. `Non-error exception captured with keys: foo, bar, baz`\n */ function extractExceptionKeysForMessage(exception, maxLength = 40) {\n    const keys = Object.keys(convertToPlainObject(exception));\n    keys.sort();\n    if (!keys.length) {\n        return \"[object has no keys]\";\n    }\n    if (keys[0].length >= maxLength) {\n        return (0,_string_js__WEBPACK_IMPORTED_MODULE_4__.truncate)(keys[0], maxLength);\n    }\n    for(let includedKeys = keys.length; includedKeys > 0; includedKeys--){\n        const serialized = keys.slice(0, includedKeys).join(\", \");\n        if (serialized.length > maxLength) {\n            continue;\n        }\n        if (includedKeys === keys.length) {\n            return serialized;\n        }\n        return (0,_string_js__WEBPACK_IMPORTED_MODULE_4__.truncate)(serialized, maxLength);\n    }\n    return \"\";\n}\n/**\n * Given any object, return a new object having removed all fields whose value was `undefined`.\n * Works recursively on objects and arrays.\n *\n * Attention: This function keeps circular references in the returned object.\n */ function dropUndefinedKeys(inputValue) {\n    // This map keeps track of what already visited nodes map to.\n    // Our Set - based memoBuilder doesn't work here because we want to the output object to have the same circular\n    // references as the input object.\n    const memoizationMap = new Map();\n    // This function just proxies `_dropUndefinedKeys` to keep the `memoBuilder` out of this function's API\n    return _dropUndefinedKeys(inputValue, memoizationMap);\n}\nfunction _dropUndefinedKeys(inputValue, memoizationMap) {\n    if (isPojo(inputValue)) {\n        // If this node has already been visited due to a circular reference, return the object it was mapped to in the new object\n        const memoVal = memoizationMap.get(inputValue);\n        if (memoVal !== undefined) {\n            return memoVal;\n        }\n        const returnValue = {};\n        // Store the mapping of this value in case we visit it again, in case of circular data\n        memoizationMap.set(inputValue, returnValue);\n        for (const key of Object.keys(inputValue)){\n            if (typeof inputValue[key] !== \"undefined\") {\n                returnValue[key] = _dropUndefinedKeys(inputValue[key], memoizationMap);\n            }\n        }\n        return returnValue;\n    }\n    if (Array.isArray(inputValue)) {\n        // If this node has already been visited due to a circular reference, return the array it was mapped to in the new object\n        const memoVal = memoizationMap.get(inputValue);\n        if (memoVal !== undefined) {\n            return memoVal;\n        }\n        const returnValue = [];\n        // Store the mapping of this value in case we visit it again, in case of circular data\n        memoizationMap.set(inputValue, returnValue);\n        inputValue.forEach((item)=>{\n            returnValue.push(_dropUndefinedKeys(item, memoizationMap));\n        });\n        return returnValue;\n    }\n    return inputValue;\n}\nfunction isPojo(input) {\n    if (!(0,_is_js__WEBPACK_IMPORTED_MODULE_2__.isPlainObject)(input)) {\n        return false;\n    }\n    try {\n        const name = Object.getPrototypeOf(input).constructor.name;\n        return !name || name === \"Object\";\n    } catch (e) {\n        return true;\n    }\n}\n/**\n * Ensure that something is an object.\n *\n * Turns `undefined` and `null` into `String`s and all other primitives into instances of their respective wrapper\n * classes (String, Boolean, Number, etc.). Acts as the identity function on non-primitives.\n *\n * @param wat The subject of the objectification\n * @returns A version of `wat` which can safely be used with `Object` class methods\n */ function objectify(wat) {\n    let objectified;\n    switch(true){\n        case wat === undefined || wat === null:\n            objectified = new String(wat);\n            break;\n        // Though symbols and bigints do have wrapper classes (`Symbol` and `BigInt`, respectively), for whatever reason\n        // those classes don't have constructors which can be used with the `new` keyword. We therefore need to cast each as\n        // an object in order to wrap it.\n        case typeof wat === \"symbol\" || typeof wat === \"bigint\":\n            objectified = Object(wat);\n            break;\n        // this will catch the remaining primitives: `String`, `Number`, and `Boolean`\n        case (0,_is_js__WEBPACK_IMPORTED_MODULE_2__.isPrimitive)(wat):\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n            objectified = new wat.constructor(wat);\n            break;\n        // by process of elimination, at this point we know that `wat` must already be an object\n        default:\n            objectified = wat;\n            break;\n    }\n    return objectified;\n}\n //# sourceMappingURL=object.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS91dGlscy9lc20vb2JqZWN0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWdEO0FBQ0Q7QUFDaUQ7QUFDM0Q7QUFDRTtBQUV2Qzs7Ozs7Ozs7OztDQVVDLEdBQ0QsU0FBU1UsS0FBS0MsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLGtCQUFrQjtJQUM1QyxJQUFJLENBQUVELENBQUFBLFFBQVFELE1BQUssR0FBSTtRQUNyQjtJQUNGO0lBRUEsTUFBTUcsV0FBV0gsTUFBTSxDQUFDQyxLQUFLO0lBQzdCLE1BQU1HLFVBQVVGLG1CQUFtQkM7SUFFbkMsMEdBQTBHO0lBQzFHLGtGQUFrRjtJQUNsRixJQUFJLE9BQU9DLFlBQVksWUFBWTtRQUNqQ0Msb0JBQW9CRCxTQUFTRDtJQUMvQjtJQUVBSCxNQUFNLENBQUNDLEtBQUssR0FBR0c7QUFDakI7QUFFQTs7Ozs7O0NBTUMsR0FDRCxTQUFTRSx5QkFBeUJDLEdBQUcsRUFBRU4sSUFBSSxFQUFFTyxLQUFLO0lBQ2hELElBQUk7UUFDRkMsT0FBT0MsY0FBYyxDQUFDSCxLQUFLTixNQUFNO1lBQy9CLGdHQUFnRztZQUNoR08sT0FBT0E7WUFDUEcsVUFBVTtZQUNWQyxjQUFjO1FBQ2hCO0lBQ0YsRUFBRSxPQUFPQyxLQUFLO1FBQ1p2Qix3REFBV0EsSUFBSU8sOENBQU1BLENBQUNpQixHQUFHLENBQUMsQ0FBQyx1Q0FBdUMsRUFBRWIsS0FBSyxXQUFXLENBQUMsRUFBRU07SUFDekY7QUFDRjtBQUVBOzs7Ozs7Q0FNQyxHQUNELFNBQVNGLG9CQUFvQkQsT0FBTyxFQUFFRCxRQUFRO0lBQzVDLElBQUk7UUFDRixNQUFNWSxRQUFRWixTQUFTYSxTQUFTLElBQUksQ0FBQztRQUNyQ1osUUFBUVksU0FBUyxHQUFHYixTQUFTYSxTQUFTLEdBQUdEO1FBQ3pDVCx5QkFBeUJGLFNBQVMsdUJBQXVCRDtJQUMzRCxFQUFFLE9BQU9VLEtBQUssQ0FBQyxFQUFFLCtCQUErQjtB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QUNUO0lBRUEsSUFBSTtRQUNGLE1BQU1uRSxPQUFPLE9BQVFvRSxjQUFjLENBQUNELE9BQVNFLFdBQVcsQ0FBQ3JFLElBQUk7UUFDN0QsT0FBTyxDQUFDQSxRQUFRQSxTQUFTO0lBQzNCLEVBQUUsT0FBT3NFLEdBQUc7UUFDVixPQUFPO0lBQ1Q7QUFDRjtBQUVBOzs7Ozs7OztDQVFDLEdBQ0QsU0FBU0MsVUFBVUMsR0FBRztJQUNwQixJQUFJQztJQUNKLE9BQVE7UUFDTixLQUFLRCxRQUFRYixhQUFhYSxRQUFRO1lBQ2hDQyxjQUFjLElBQUlDLE9BQU9GO1lBQ3pCO1FBRUYsZ0hBQWdIO1FBQ2hILG9IQUFvSDtRQUNwSCxpQ0FBaUM7UUFDakMsS0FBSyxPQUFPQSxRQUFRLFlBQVksT0FBT0EsUUFBUTtZQUM3Q0MsY0FBY2pFLE9BQU9nRTtZQUNyQjtRQUVGLDhFQUE4RTtRQUM5RSxLQUFLN0UsbURBQVdBLENBQUM2RTtZQUNmLHNFQUFzRTtZQUN0RUMsY0FBYyxJQUFJLElBQU9KLFdBQVcsQ0FBQ0c7WUFDckM7UUFFRix3RkFBd0Y7UUFDeEY7WUFDRUMsY0FBY0Q7WUFDZDtJQUNKO0lBQ0EsT0FBT0M7QUFDVDtBQUVtTCxDQUNuTCxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vYnJhbGluay13ZWIvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS91dGlscy9lc20vb2JqZWN0LmpzPzQxNDgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaHRtbFRyZWVBc1N0cmluZyB9IGZyb20gJy4vYnJvd3Nlci5qcyc7XG5pbXBvcnQgeyBERUJVR19CVUlMRCB9IGZyb20gJy4vZGVidWctYnVpbGQuanMnO1xuaW1wb3J0IHsgaXNFcnJvciwgaXNFdmVudCwgaXNJbnN0YW5jZU9mLCBpc0VsZW1lbnQsIGlzUGxhaW5PYmplY3QsIGlzUHJpbWl0aXZlIH0gZnJvbSAnLi9pcy5qcyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuL2xvZ2dlci5qcyc7XG5pbXBvcnQgeyB0cnVuY2F0ZSB9IGZyb20gJy4vc3RyaW5nLmpzJztcblxuLyoqXG4gKiBSZXBsYWNlIGEgbWV0aG9kIGluIGFuIG9iamVjdCB3aXRoIGEgd3JhcHBlZCB2ZXJzaW9uIG9mIGl0c2VsZi5cbiAqXG4gKiBAcGFyYW0gc291cmNlIEFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgbWV0aG9kIHRvIGJlIHdyYXBwZWQuXG4gKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRvIGJlIHdyYXBwZWQuXG4gKiBAcGFyYW0gcmVwbGFjZW1lbnRGYWN0b3J5IEEgaGlnaGVyLW9yZGVyIGZ1bmN0aW9uIHRoYXQgdGFrZXMgdGhlIG9yaWdpbmFsIHZlcnNpb24gb2YgdGhlIGdpdmVuIG1ldGhvZCBhbmQgcmV0dXJucyBhXG4gKiB3cmFwcGVkIHZlcnNpb24uIE5vdGU6IFRoZSBmdW5jdGlvbiByZXR1cm5lZCBieSBgcmVwbGFjZW1lbnRGYWN0b3J5YCBuZWVkcyB0byBiZSBhIG5vbi1hcnJvdyBmdW5jdGlvbiwgaW4gb3JkZXIgdG9cbiAqIHByZXNlcnZlIHRoZSBjb3JyZWN0IHZhbHVlIG9mIGB0aGlzYCwgYW5kIHRoZSBvcmlnaW5hbCBtZXRob2QgbXVzdCBiZSBjYWxsZWQgdXNpbmcgYG9yaWdNZXRob2QuY2FsbCh0aGlzLCA8b3RoZXJcbiAqIGFyZ3M+KWAgb3IgYG9yaWdNZXRob2QuYXBwbHkodGhpcywgWzxvdGhlciBhcmdzPl0pYCAocmF0aGVyIHRoYW4gYmVpbmcgY2FsbGVkIGRpcmVjdGx5KSwgYWdhaW4gdG8gcHJlc2VydmUgYHRoaXNgLlxuICogQHJldHVybnMgdm9pZFxuICovXG5mdW5jdGlvbiBmaWxsKHNvdXJjZSwgbmFtZSwgcmVwbGFjZW1lbnRGYWN0b3J5KSB7XG4gIGlmICghKG5hbWUgaW4gc291cmNlKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IG9yaWdpbmFsID0gc291cmNlW25hbWVdIDtcbiAgY29uc3Qgd3JhcHBlZCA9IHJlcGxhY2VtZW50RmFjdG9yeShvcmlnaW5hbCkgO1xuXG4gIC8vIE1ha2Ugc3VyZSBpdCdzIGEgZnVuY3Rpb24gZmlyc3QsIGFzIHdlIG5lZWQgdG8gYXR0YWNoIGFuIGVtcHR5IHByb3RvdHlwZSBmb3IgYGRlZmluZVByb3BlcnRpZXNgIHRvIHdvcmtcbiAgLy8gb3RoZXJ3aXNlIGl0J2xsIHRocm93IFwiVHlwZUVycm9yOiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyBjYWxsZWQgb24gbm9uLW9iamVjdFwiXG4gIGlmICh0eXBlb2Ygd3JhcHBlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG1hcmtGdW5jdGlvbldyYXBwZWQod3JhcHBlZCwgb3JpZ2luYWwpO1xuICB9XG5cbiAgc291cmNlW25hbWVdID0gd3JhcHBlZDtcbn1cblxuLyoqXG4gKiBEZWZpbmVzIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHkgb24gdGhlIGdpdmVuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gb2JqIFRoZSBvYmplY3Qgb24gd2hpY2ggdG8gc2V0IHRoZSBwcm9wZXJ0eVxuICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGJlIHNldFxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byB3aGljaCB0byBzZXQgdGhlIHByb3BlcnR5XG4gKi9cbmZ1bmN0aW9uIGFkZE5vbkVudW1lcmFibGVQcm9wZXJ0eShvYmosIG5hbWUsIHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgbmFtZSwge1xuICAgICAgLy8gZW51bWVyYWJsZTogZmFsc2UsIC8vIHRoZSBkZWZhdWx0LCBzbyB3ZSBjYW4gc2F2ZSBvbiBidW5kbGUgc2l6ZSBieSBub3QgZXhwbGljaXRseSBzZXR0aW5nIGl0XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB9KTtcbiAgfSBjYXRjaCAob19PKSB7XG4gICAgREVCVUdfQlVJTEQgJiYgbG9nZ2VyLmxvZyhgRmFpbGVkIHRvIGFkZCBub24tZW51bWVyYWJsZSBwcm9wZXJ0eSBcIiR7bmFtZX1cIiB0byBvYmplY3RgLCBvYmopO1xuICB9XG59XG5cbi8qKlxuICogUmVtZW1iZXJzIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiBvbiB0aGUgd3JhcHBlZCBmdW5jdGlvbiBhbmRcbiAqIHBhdGNoZXMgdXAgdGhlIHByb3RvdHlwZS5cbiAqXG4gKiBAcGFyYW0gd3JhcHBlZCB0aGUgd3JhcHBlciBmdW5jdGlvblxuICogQHBhcmFtIG9yaWdpbmFsIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiB0aGF0IGdldHMgd3JhcHBlZFxuICovXG5mdW5jdGlvbiBtYXJrRnVuY3Rpb25XcmFwcGVkKHdyYXBwZWQsIG9yaWdpbmFsKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcHJvdG8gPSBvcmlnaW5hbC5wcm90b3R5cGUgfHwge307XG4gICAgd3JhcHBlZC5wcm90b3R5cGUgPSBvcmlnaW5hbC5wcm90b3R5cGUgPSBwcm90bztcbiAgICBhZGROb25FbnVtZXJhYmxlUHJvcGVydHkod3JhcHBlZCwgJ19fc2VudHJ5X29yaWdpbmFsX18nLCBvcmlnaW5hbCk7XG4gIH0gY2F0Y2ggKG9fTykge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxufVxuXG4vKipcbiAqIFRoaXMgZXh0cmFjdHMgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIGlmIGF2YWlsYWJsZS4gIFNlZVxuICogYG1hcmtGdW5jdGlvbldyYXBwZWRgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEBwYXJhbSBmdW5jIHRoZSBmdW5jdGlvbiB0byB1bndyYXBcbiAqIEByZXR1cm5zIHRoZSB1bndyYXBwZWQgdmVyc2lvbiBvZiB0aGUgZnVuY3Rpb24gaWYgYXZhaWxhYmxlLlxuICovXG5mdW5jdGlvbiBnZXRPcmlnaW5hbEZ1bmN0aW9uKGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmMuX19zZW50cnlfb3JpZ2luYWxfXztcbn1cblxuLyoqXG4gKiBFbmNvZGVzIGdpdmVuIG9iamVjdCBpbnRvIHVybC1mcmllbmRseSBmb3JtYXRcbiAqXG4gKiBAcGFyYW0gb2JqZWN0IEFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHNlcmlhbGl6YWJsZSB2YWx1ZXNcbiAqIEByZXR1cm5zIHN0cmluZyBFbmNvZGVkXG4gKi9cbmZ1bmN0aW9uIHVybEVuY29kZShvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iamVjdClcbiAgICAubWFwKGtleSA9PiBgJHtlbmNvZGVVUklDb21wb25lbnQoa2V5KX09JHtlbmNvZGVVUklDb21wb25lbnQob2JqZWN0W2tleV0pfWApXG4gICAgLmpvaW4oJyYnKTtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIGFueSBgRXJyb3JgIG9yIGBFdmVudGAgaW50byBhIHBsYWluIG9iamVjdCB3aXRoIGFsbCBvZiB0aGVpciBlbnVtZXJhYmxlIHByb3BlcnRpZXMsIGFuZCBzb21lIG9mIHRoZWlyXG4gKiBub24tZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGF0dGFjaGVkLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSBJbml0aWFsIHNvdXJjZSB0aGF0IHdlIGhhdmUgdG8gdHJhbnNmb3JtIGluIG9yZGVyIGZvciBpdCB0byBiZSB1c2FibGUgYnkgdGhlIHNlcmlhbGl6ZXJcbiAqIEByZXR1cm5zIEFuIEV2ZW50IG9yIEVycm9yIHR1cm5lZCBpbnRvIGFuIG9iamVjdCAtIG9yIHRoZSB2YWx1ZSBhcmd1cm1lbnQgaXRzZWxmLCB3aGVuIHZhbHVlIGlzIG5laXRoZXIgYW4gRXZlbnQgbm9yXG4gKiAgYW4gRXJyb3IuXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRUb1BsYWluT2JqZWN0KFxuICB2YWx1ZSxcbilcblxuIHtcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1lc3NhZ2U6IHZhbHVlLm1lc3NhZ2UsXG4gICAgICBuYW1lOiB2YWx1ZS5uYW1lLFxuICAgICAgc3RhY2s6IHZhbHVlLnN0YWNrLFxuICAgICAgLi4uZ2V0T3duUHJvcGVydGllcyh2YWx1ZSksXG4gICAgfTtcbiAgfSBlbHNlIGlmIChpc0V2ZW50KHZhbHVlKSkge1xuICAgIGNvbnN0IG5ld09ialxuXG4gPSB7XG4gICAgICB0eXBlOiB2YWx1ZS50eXBlLFxuICAgICAgdGFyZ2V0OiBzZXJpYWxpemVFdmVudFRhcmdldCh2YWx1ZS50YXJnZXQpLFxuICAgICAgY3VycmVudFRhcmdldDogc2VyaWFsaXplRXZlbnRUYXJnZXQodmFsdWUuY3VycmVudFRhcmdldCksXG4gICAgICAuLi5nZXRPd25Qcm9wZXJ0aWVzKHZhbHVlKSxcbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiBDdXN0b21FdmVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNJbnN0YW5jZU9mKHZhbHVlLCBDdXN0b21FdmVudCkpIHtcbiAgICAgIG5ld09iai5kZXRhaWwgPSB2YWx1ZS5kZXRhaWw7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld09iajtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuLyoqIENyZWF0ZXMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRhcmdldCBvZiBhbiBgRXZlbnRgIG9iamVjdCAqL1xuZnVuY3Rpb24gc2VyaWFsaXplRXZlbnRUYXJnZXQodGFyZ2V0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGlzRWxlbWVudCh0YXJnZXQpID8gaHRtbFRyZWVBc1N0cmluZyh0YXJnZXQpIDogT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRhcmdldCk7XG4gIH0gY2F0Y2ggKF9vTykge1xuICAgIHJldHVybiAnPHVua25vd24+JztcbiAgfVxufVxuXG4vKiogRmlsdGVycyBvdXQgYWxsIGJ1dCBhbiBvYmplY3QncyBvd24gcHJvcGVydGllcyAqL1xuZnVuY3Rpb24gZ2V0T3duUHJvcGVydGllcyhvYmopIHtcbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCkge1xuICAgIGNvbnN0IGV4dHJhY3RlZFByb3BzID0ge307XG4gICAgZm9yIChjb25zdCBwcm9wZXJ0eSBpbiBvYmopIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgZXh0cmFjdGVkUHJvcHNbcHJvcGVydHldID0gKG9iaiApW3Byb3BlcnR5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV4dHJhY3RlZFByb3BzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7fTtcbiAgfVxufVxuXG4vKipcbiAqIEdpdmVuIGFueSBjYXB0dXJlZCBleGNlcHRpb24sIGV4dHJhY3QgaXRzIGtleXMgYW5kIGNyZWF0ZSBhIHNvcnRlZFxuICogYW5kIHRydW5jYXRlZCBsaXN0IHRoYXQgd2lsbCBiZSB1c2VkIGluc2lkZSB0aGUgZXZlbnQgbWVzc2FnZS5cbiAqIGVnLiBgTm9uLWVycm9yIGV4Y2VwdGlvbiBjYXB0dXJlZCB3aXRoIGtleXM6IGZvbywgYmFyLCBiYXpgXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RFeGNlcHRpb25LZXlzRm9yTWVzc2FnZShleGNlcHRpb24sIG1heExlbmd0aCA9IDQwKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhjb252ZXJ0VG9QbGFpbk9iamVjdChleGNlcHRpb24pKTtcbiAga2V5cy5zb3J0KCk7XG5cbiAgaWYgKCFrZXlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnW29iamVjdCBoYXMgbm8ga2V5c10nO1xuICB9XG5cbiAgaWYgKGtleXNbMF0ubGVuZ3RoID49IG1heExlbmd0aCkge1xuICAgIHJldHVybiB0cnVuY2F0ZShrZXlzWzBdLCBtYXhMZW5ndGgpO1xuICB9XG5cbiAgZm9yIChsZXQgaW5jbHVkZWRLZXlzID0ga2V5cy5sZW5ndGg7IGluY2x1ZGVkS2V5cyA+IDA7IGluY2x1ZGVkS2V5cy0tKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IGtleXMuc2xpY2UoMCwgaW5jbHVkZWRLZXlzKS5qb2luKCcsICcpO1xuICAgIGlmIChzZXJpYWxpemVkLmxlbmd0aCA+IG1heExlbmd0aCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChpbmNsdWRlZEtleXMgPT09IGtleXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9XG4gICAgcmV0dXJuIHRydW5jYXRlKHNlcmlhbGl6ZWQsIG1heExlbmd0aCk7XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogR2l2ZW4gYW55IG9iamVjdCwgcmV0dXJuIGEgbmV3IG9iamVjdCBoYXZpbmcgcmVtb3ZlZCBhbGwgZmllbGRzIHdob3NlIHZhbHVlIHdhcyBgdW5kZWZpbmVkYC5cbiAqIFdvcmtzIHJlY3Vyc2l2ZWx5IG9uIG9iamVjdHMgYW5kIGFycmF5cy5cbiAqXG4gKiBBdHRlbnRpb246IFRoaXMgZnVuY3Rpb24ga2VlcHMgY2lyY3VsYXIgcmVmZXJlbmNlcyBpbiB0aGUgcmV0dXJuZWQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBkcm9wVW5kZWZpbmVkS2V5cyhpbnB1dFZhbHVlKSB7XG4gIC8vIFRoaXMgbWFwIGtlZXBzIHRyYWNrIG9mIHdoYXQgYWxyZWFkeSB2aXNpdGVkIG5vZGVzIG1hcCB0by5cbiAgLy8gT3VyIFNldCAtIGJhc2VkIG1lbW9CdWlsZGVyIGRvZXNuJ3Qgd29yayBoZXJlIGJlY2F1c2Ugd2Ugd2FudCB0byB0aGUgb3V0cHV0IG9iamVjdCB0byBoYXZlIHRoZSBzYW1lIGNpcmN1bGFyXG4gIC8vIHJlZmVyZW5jZXMgYXMgdGhlIGlucHV0IG9iamVjdC5cbiAgY29uc3QgbWVtb2l6YXRpb25NYXAgPSBuZXcgTWFwKCk7XG5cbiAgLy8gVGhpcyBmdW5jdGlvbiBqdXN0IHByb3hpZXMgYF9kcm9wVW5kZWZpbmVkS2V5c2AgdG8ga2VlcCB0aGUgYG1lbW9CdWlsZGVyYCBvdXQgb2YgdGhpcyBmdW5jdGlvbidzIEFQSVxuICByZXR1cm4gX2Ryb3BVbmRlZmluZWRLZXlzKGlucHV0VmFsdWUsIG1lbW9pemF0aW9uTWFwKTtcbn1cblxuZnVuY3Rpb24gX2Ryb3BVbmRlZmluZWRLZXlzKGlucHV0VmFsdWUsIG1lbW9pemF0aW9uTWFwKSB7XG4gIGlmIChpc1Bvam8oaW5wdXRWYWx1ZSkpIHtcbiAgICAvLyBJZiB0aGlzIG5vZGUgaGFzIGFscmVhZHkgYmVlbiB2aXNpdGVkIGR1ZSB0byBhIGNpcmN1bGFyIHJlZmVyZW5jZSwgcmV0dXJuIHRoZSBvYmplY3QgaXQgd2FzIG1hcHBlZCB0byBpbiB0aGUgbmV3IG9iamVjdFxuICAgIGNvbnN0IG1lbW9WYWwgPSBtZW1vaXphdGlvbk1hcC5nZXQoaW5wdXRWYWx1ZSk7XG4gICAgaWYgKG1lbW9WYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG1lbW9WYWwgO1xuICAgIH1cblxuICAgIGNvbnN0IHJldHVyblZhbHVlID0ge307XG4gICAgLy8gU3RvcmUgdGhlIG1hcHBpbmcgb2YgdGhpcyB2YWx1ZSBpbiBjYXNlIHdlIHZpc2l0IGl0IGFnYWluLCBpbiBjYXNlIG9mIGNpcmN1bGFyIGRhdGFcbiAgICBtZW1vaXphdGlvbk1hcC5zZXQoaW5wdXRWYWx1ZSwgcmV0dXJuVmFsdWUpO1xuXG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoaW5wdXRWYWx1ZSkpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5wdXRWYWx1ZVtrZXldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm5WYWx1ZVtrZXldID0gX2Ryb3BVbmRlZmluZWRLZXlzKGlucHV0VmFsdWVba2V5XSwgbWVtb2l6YXRpb25NYXApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXR1cm5WYWx1ZSA7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dFZhbHVlKSkge1xuICAgIC8vIElmIHRoaXMgbm9kZSBoYXMgYWxyZWFkeSBiZWVuIHZpc2l0ZWQgZHVlIHRvIGEgY2lyY3VsYXIgcmVmZXJlbmNlLCByZXR1cm4gdGhlIGFycmF5IGl0IHdhcyBtYXBwZWQgdG8gaW4gdGhlIG5ldyBvYmplY3RcbiAgICBjb25zdCBtZW1vVmFsID0gbWVtb2l6YXRpb25NYXAuZ2V0KGlucHV0VmFsdWUpO1xuICAgIGlmIChtZW1vVmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBtZW1vVmFsIDtcbiAgICB9XG5cbiAgICBjb25zdCByZXR1cm5WYWx1ZSA9IFtdO1xuICAgIC8vIFN0b3JlIHRoZSBtYXBwaW5nIG9mIHRoaXMgdmFsdWUgaW4gY2FzZSB3ZSB2aXNpdCBpdCBhZ2FpbiwgaW4gY2FzZSBvZiBjaXJjdWxhciBkYXRhXG4gICAgbWVtb2l6YXRpb25NYXAuc2V0KGlucHV0VmFsdWUsIHJldHVyblZhbHVlKTtcblxuICAgIGlucHV0VmFsdWUuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgcmV0dXJuVmFsdWUucHVzaChfZHJvcFVuZGVmaW5lZEtleXMoaXRlbSwgbWVtb2l6YXRpb25NYXApKTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXR1cm5WYWx1ZSA7XG4gIH1cblxuICByZXR1cm4gaW5wdXRWYWx1ZTtcbn1cblxuZnVuY3Rpb24gaXNQb2pvKGlucHV0KSB7XG4gIGlmICghaXNQbGFpbk9iamVjdChpbnB1dCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IG5hbWUgPSAoT2JqZWN0LmdldFByb3RvdHlwZU9mKGlucHV0KSApLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgcmV0dXJuICFuYW1lIHx8IG5hbWUgPT09ICdPYmplY3QnO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBzb21ldGhpbmcgaXMgYW4gb2JqZWN0LlxuICpcbiAqIFR1cm5zIGB1bmRlZmluZWRgIGFuZCBgbnVsbGAgaW50byBgU3RyaW5nYHMgYW5kIGFsbCBvdGhlciBwcmltaXRpdmVzIGludG8gaW5zdGFuY2VzIG9mIHRoZWlyIHJlc3BlY3RpdmUgd3JhcHBlclxuICogY2xhc3NlcyAoU3RyaW5nLCBCb29sZWFuLCBOdW1iZXIsIGV0Yy4pLiBBY3RzIGFzIHRoZSBpZGVudGl0eSBmdW5jdGlvbiBvbiBub24tcHJpbWl0aXZlcy5cbiAqXG4gKiBAcGFyYW0gd2F0IFRoZSBzdWJqZWN0IG9mIHRoZSBvYmplY3RpZmljYXRpb25cbiAqIEByZXR1cm5zIEEgdmVyc2lvbiBvZiBgd2F0YCB3aGljaCBjYW4gc2FmZWx5IGJlIHVzZWQgd2l0aCBgT2JqZWN0YCBjbGFzcyBtZXRob2RzXG4gKi9cbmZ1bmN0aW9uIG9iamVjdGlmeSh3YXQpIHtcbiAgbGV0IG9iamVjdGlmaWVkO1xuICBzd2l0Y2ggKHRydWUpIHtcbiAgICBjYXNlIHdhdCA9PT0gdW5kZWZpbmVkIHx8IHdhdCA9PT0gbnVsbDpcbiAgICAgIG9iamVjdGlmaWVkID0gbmV3IFN0cmluZyh3YXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICAvLyBUaG91Z2ggc3ltYm9scyBhbmQgYmlnaW50cyBkbyBoYXZlIHdyYXBwZXIgY2xhc3NlcyAoYFN5bWJvbGAgYW5kIGBCaWdJbnRgLCByZXNwZWN0aXZlbHkpLCBmb3Igd2hhdGV2ZXIgcmVhc29uXG4gICAgLy8gdGhvc2UgY2xhc3NlcyBkb24ndCBoYXZlIGNvbnN0cnVjdG9ycyB3aGljaCBjYW4gYmUgdXNlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkLiBXZSB0aGVyZWZvcmUgbmVlZCB0byBjYXN0IGVhY2ggYXNcbiAgICAvLyBhbiBvYmplY3QgaW4gb3JkZXIgdG8gd3JhcCBpdC5cbiAgICBjYXNlIHR5cGVvZiB3YXQgPT09ICdzeW1ib2wnIHx8IHR5cGVvZiB3YXQgPT09ICdiaWdpbnQnOlxuICAgICAgb2JqZWN0aWZpZWQgPSBPYmplY3Qod2F0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgLy8gdGhpcyB3aWxsIGNhdGNoIHRoZSByZW1haW5pbmcgcHJpbWl0aXZlczogYFN0cmluZ2AsIGBOdW1iZXJgLCBhbmQgYEJvb2xlYW5gXG4gICAgY2FzZSBpc1ByaW1pdGl2ZSh3YXQpOlxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgb2JqZWN0aWZpZWQgPSBuZXcgKHdhdCApLmNvbnN0cnVjdG9yKHdhdCk7XG4gICAgICBicmVhaztcblxuICAgIC8vIGJ5IHByb2Nlc3Mgb2YgZWxpbWluYXRpb24sIGF0IHRoaXMgcG9pbnQgd2Uga25vdyB0aGF0IGB3YXRgIG11c3QgYWxyZWFkeSBiZSBhbiBvYmplY3RcbiAgICBkZWZhdWx0OlxuICAgICAgb2JqZWN0aWZpZWQgPSB3YXQ7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gb2JqZWN0aWZpZWQ7XG59XG5cbmV4cG9ydCB7IGFkZE5vbkVudW1lcmFibGVQcm9wZXJ0eSwgY29udmVydFRvUGxhaW5PYmplY3QsIGRyb3BVbmRlZmluZWRLZXlzLCBleHRyYWN0RXhjZXB0aW9uS2V5c0Zvck1lc3NhZ2UsIGZpbGwsIGdldE9yaWdpbmFsRnVuY3Rpb24sIG1hcmtGdW5jdGlvbldyYXBwZWQsIG9iamVjdGlmeSwgdXJsRW5jb2RlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vYmplY3QuanMubWFwXG4iXSwibmFtZXMiOlsiaHRtbFRyZWVBc1N0cmluZyIsIkRFQlVHX0JVSUxEIiwiaXNFcnJvciIsImlzRXZlbnQiLCJpc0luc3RhbmNlT2YiLCJpc0VsZW1lbnQiLCJpc1BsYWluT2JqZWN0IiwiaXNQcmltaXRpdmUiLCJsb2dnZXIiLCJ0cnVuY2F0ZSIsImZpbGwiLCJzb3VyY2UiLCJuYW1lIiwicmVwbGFjZW1lbnRGYWN0b3J5Iiwib3JpZ2luYWwiLCJ3cmFwcGVkIiwibWFya0Z1bmN0aW9uV3JhcHBlZCIsImFkZE5vbkVudW1lcmFibGVQcm9wZXJ0eSIsIm9iaiIsInZhbHVlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsIm9fTyIsImxvZyIsInByb3RvIiwicHJvdG90eXBlIiwiZ2V0T3JpZ2luYWxGdW5jdGlvbiIsImZ1bmMiLCJfX3NlbnRyeV9vcmlnaW5hbF9fIiwidXJsRW5jb2RlIiwib2JqZWN0Iiwia2V5cyIsIm1hcCIsImtleSIsImVuY29kZVVSSUNvbXBvbmVudCIsImpvaW4iLCJjb252ZXJ0VG9QbGFpbk9iamVjdCIsIm1lc3NhZ2UiLCJzdGFjayIsImdldE93blByb3BlcnRpZXMiLCJuZXdPYmoiLCJ0eXBlIiwidGFyZ2V0Iiwic2VyaWFsaXplRXZlbnRUYXJnZXQiLCJjdXJyZW50VGFyZ2V0IiwiQ3VzdG9tRXZlbnQiLCJkZXRhaWwiLCJ0b1N0cmluZyIsImNhbGwiLCJfb08iLCJleHRyYWN0ZWRQcm9wcyIsInByb3BlcnR5IiwiaGFzT3duUHJvcGVydHkiLCJleHRyYWN0RXhjZXB0aW9uS2V5c0Zvck1lc3NhZ2UiLCJleGNlcHRpb24iLCJtYXhMZW5ndGgiLCJzb3J0IiwibGVuZ3RoIiwiaW5jbHVkZWRLZXlzIiwic2VyaWFsaXplZCIsInNsaWNlIiwiZHJvcFVuZGVmaW5lZEtleXMiLCJpbnB1dFZhbHVlIiwibWVtb2l6YXRpb25NYXAiLCJNYXAiLCJfZHJvcFVuZGVmaW5lZEtleXMiLCJpc1Bvam8iLCJtZW1vVmFsIiwiZ2V0IiwidW5kZWZpbmVkIiwicmV0dXJuVmFsdWUiLCJzZXQiLCJBcnJheSIsImlzQXJyYXkiLCJmb3JFYWNoIiwiaXRlbSIsInB1c2giLCJpbnB1dCIsImdldFByb3RvdHlwZU9mIiwiY29uc3RydWN0b3IiLCJlIiwib2JqZWN0aWZ5Iiwid2F0Iiwib2JqZWN0aWZpZWQiLCJTdHJpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/utils/esm/object.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sentry/utils/esm/stacktrace.js":
/*!******************************************************!*\
  !*** ./node_modules/@sentry/utils/esm/stacktrace.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createStackParser: () => (/* binding */ createStackParser),\n/* harmony export */   filenameIsInApp: () => (/* reexport safe */ _node_stack_trace_js__WEBPACK_IMPORTED_MODULE_0__.filenameIsInApp),\n/* harmony export */   getFunctionName: () => (/* binding */ getFunctionName),\n/* harmony export */   nodeStackLineParser: () => (/* binding */ nodeStackLineParser),\n/* harmony export */   stackParserFromStackParserOptions: () => (/* binding */ stackParserFromStackParserOptions),\n/* harmony export */   stripSentryFramesAndReverse: () => (/* binding */ stripSentryFramesAndReverse)\n/* harmony export */ });\n/* harmony import */ var _node_stack_trace_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node-stack-trace.js */ \"(ssr)/./node_modules/@sentry/utils/esm/node-stack-trace.js\");\n\n\nconst STACKTRACE_FRAME_LIMIT = 50;\n// Used to sanitize webpack (error: *) wrapped stack errors\nconst WEBPACK_ERROR_REGEXP = /\\(error: (.*)\\)/;\nconst STRIP_FRAME_REGEXP = /captureMessage|captureException/;\n/**\n * Creates a stack parser with the supplied line parsers\n *\n * StackFrames are returned in the correct order for Sentry Exception\n * frames and with Sentry SDK internal frames removed from the top and bottom\n *\n */ function createStackParser(...parsers) {\n    const sortedParsers = parsers.sort((a, b)=>a[0] - b[0]).map((p)=>p[1]);\n    return (stack, skipFirst = 0)=>{\n        const frames = [];\n        const lines = stack.split(\"\\n\");\n        for(let i = skipFirst; i < lines.length; i++){\n            const line = lines[i];\n            // Ignore lines over 1kb as they are unlikely to be stack frames.\n            // Many of the regular expressions use backtracking which results in run time that increases exponentially with\n            // input size. Huge strings can result in hangs/Denial of Service:\n            // https://github.com/getsentry/sentry-javascript/issues/2286\n            if (line.length > 1024) {\n                continue;\n            }\n            // https://github.com/getsentry/sentry-javascript/issues/5459\n            // Remove webpack (error: *) wrappers\n            const cleanedLine = WEBPACK_ERROR_REGEXP.test(line) ? line.replace(WEBPACK_ERROR_REGEXP, \"$1\") : line;\n            // https://github.com/getsentry/sentry-javascript/issues/7813\n            // Skip Error: lines\n            if (cleanedLine.match(/\\S*Error: /)) {\n                continue;\n            }\n            for (const parser of sortedParsers){\n                const frame = parser(cleanedLine);\n                if (frame) {\n                    frames.push(frame);\n                    break;\n                }\n            }\n            if (frames.length >= STACKTRACE_FRAME_LIMIT) {\n                break;\n            }\n        }\n        return stripSentryFramesAndReverse(frames);\n    };\n}\n/**\n * Gets a stack parser implementation from Options.stackParser\n * @see Options\n *\n * If options contains an array of line parsers, it is converted into a parser\n */ function stackParserFromStackParserOptions(stackParser) {\n    if (Array.isArray(stackParser)) {\n        return createStackParser(...stackParser);\n    }\n    return stackParser;\n}\n/**\n * Removes Sentry frames from the top and bottom of the stack if present and enforces a limit of max number of frames.\n * Assumes stack input is ordered from top to bottom and returns the reverse representation so call site of the\n * function that caused the crash is the last frame in the array.\n * @hidden\n */ function stripSentryFramesAndReverse(stack) {\n    if (!stack.length) {\n        return [];\n    }\n    const localStack = Array.from(stack);\n    // If stack starts with one of our API calls, remove it (starts, meaning it's the top of the stack - aka last call)\n    if (/sentryWrapped/.test(localStack[localStack.length - 1].function || \"\")) {\n        localStack.pop();\n    }\n    // Reversing in the middle of the procedure allows us to just pop the values off the stack\n    localStack.reverse();\n    // If stack ends with one of our internal API calls, remove it (ends, meaning it's the bottom of the stack - aka top-most call)\n    if (STRIP_FRAME_REGEXP.test(localStack[localStack.length - 1].function || \"\")) {\n        localStack.pop();\n        // When using synthetic events, we will have a 2 levels deep stack, as `new Error('Sentry syntheticException')`\n        // is produced within the hub itself, making it:\n        //\n        //   Sentry.captureException()\n        //   getCurrentHub().captureException()\n        //\n        // instead of just the top `Sentry` call itself.\n        // This forces us to possibly strip an additional frame in the exact same was as above.\n        if (STRIP_FRAME_REGEXP.test(localStack[localStack.length - 1].function || \"\")) {\n            localStack.pop();\n        }\n    }\n    return localStack.slice(0, STACKTRACE_FRAME_LIMIT).map((frame)=>({\n            ...frame,\n            filename: frame.filename || localStack[localStack.length - 1].filename,\n            function: frame.function || \"?\"\n        }));\n}\nconst defaultFunctionName = \"<anonymous>\";\n/**\n * Safely extract function name from itself\n */ function getFunctionName(fn) {\n    try {\n        if (!fn || typeof fn !== \"function\") {\n            return defaultFunctionName;\n        }\n        return fn.name || defaultFunctionName;\n    } catch (e) {\n        // Just accessing custom props in some Selenium environments\n        // can cause a \"Permission denied\" exception (see raven-js#495).\n        return defaultFunctionName;\n    }\n}\n/**\n * Node.js stack line parser\n *\n * This is in @sentry/utils so it can be used from the Electron SDK in the browser for when `nodeIntegration == true`.\n * This allows it to be used without referencing or importing any node specific code which causes bundlers to complain\n */ function nodeStackLineParser(getModule) {\n    return [\n        90,\n        (0,_node_stack_trace_js__WEBPACK_IMPORTED_MODULE_0__.node)(getModule)\n    ];\n}\n //# sourceMappingURL=stacktrace.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS91dGlscy9lc20vc3RhY2t0cmFjZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQTZDO0FBQ1c7QUFFeEQsTUFBTUUseUJBQXlCO0FBQy9CLDJEQUEyRDtBQUMzRCxNQUFNQyx1QkFBdUI7QUFDN0IsTUFBTUMscUJBQXFCO0FBRTNCOzs7Ozs7Q0FNQyxHQUNELFNBQVNDLGtCQUFrQixHQUFHQyxPQUFPO0lBQ25DLE1BQU1DLGdCQUFnQkQsUUFBUUUsSUFBSSxDQUFDLENBQUNDLEdBQUdDLElBQU1ELENBQUMsQ0FBQyxFQUFFLEdBQUdDLENBQUMsQ0FBQyxFQUFFLEVBQUVDLEdBQUcsQ0FBQ0MsQ0FBQUEsSUFBS0EsQ0FBQyxDQUFDLEVBQUU7SUFFdkUsT0FBTyxDQUFDQyxPQUFPQyxZQUFZLENBQUM7UUFDMUIsTUFBTUMsU0FBUyxFQUFFO1FBQ2pCLE1BQU1DLFFBQVFILE1BQU1JLEtBQUssQ0FBQztRQUUxQixJQUFLLElBQUlDLElBQUlKLFdBQVdJLElBQUlGLE1BQU1HLE1BQU0sRUFBRUQsSUFBSztZQUM3QyxNQUFNRSxPQUFPSixLQUFLLENBQUNFLEVBQUU7WUFDckIsaUVBQWlFO1lBQ2pFLCtHQUErRztZQUMvRyxrRUFBa0U7WUFDbEUsNkRBQTZEO1lBQzdELElBQUlFLEtBQUtELE1BQU0sR0FBRyxNQUFNO2dCQUN0QjtZQUNGO1lBRUEsNkRBQTZEO1lBQzdELHFDQUFxQztZQUNyQyxNQUFNRSxjQUFjbEIscUJBQXFCbUIsSUFBSSxDQUFDRixRQUFRQSxLQUFLRyxPQUFPLENBQUNwQixzQkFBc0IsUUFBUWlCO1lBRWpHLDZEQUE2RDtZQUM3RCxvQkFBb0I7WUFDcEIsSUFBSUMsWUFBWUcsS0FBSyxDQUFDLGVBQWU7Z0JBQ25DO1lBQ0Y7WUFFQSxLQUFLLE1BQU1DLFVBQVVsQixjQUFlO2dCQUNsQyxNQUFNbUIsUUFBUUQsT0FBT0o7Z0JBRXJCLElBQUlLLE9BQU87b0JBQ1RYLE9BQU9ZLElBQUksQ0FBQ0Q7b0JBQ1o7Z0JBQ0Y7WUFDRjtZQUVBLElBQUlYLE9BQU9JLE1BQU0sSUFBSWpCLHdCQUF3QjtnQkFDM0M7WUFDRjtRQUNGO1FBRUEsT0FBTzBCLDRCQUE0QmI7SUFDckM7QUFDRjtBQUVBOzs7OztDQUtDLEdBQ0QsU0FBU2Msa0NBQWtDQyxXQUFXO0lBQ3BELElBQUlDLE1BQU1DLE9BQU8sQ0FBQ0YsY0FBYztRQUM5QixPQUFPekIscUJBQXFCeUI7SUFDOUI7SUFDQSxPQUFPQTtBQUNUO0FBRUE7Ozs7O0NBS0MsR0FDRCxTQUFTRiw0QkFBNEJmLEtBQUs7SUFDeEMsSUFBSSxDQUFDQSxNQUFNTSxNQUFNLEVBQUU7UUFDakIsT0FBTyxFQUFFO0lBQ1g7SUFFQSxNQUFNYyxhQUFhRixNQUFNRyxJQUFJLENBQUNyQjtJQUU5QixtSEFBbUg7SUFDbkgsSUFBSSxnQkFBZ0JTLElBQUksQ0FBQ1csVUFBVSxDQUFDQSxXQUFXZCxNQUFNLEdBQUcsRUFBRSxDQUFDZ0IsUUFBUSxJQUFJLEtBQUs7UUFDMUVGLFdBQVdHLEdBQUc7SUFDaEI7SUFFQSwwRkFBMEY7SUFDMUZILFdBQVdJLE9BQU87SUFFbEIsK0hBQStIO0lBQy9ILElBQUlqQyxtQkFBbUJrQixJQUFJLENBQUNXLFVBQVUsQ0FBQ0EsV0FBV2QsTUFBTSxHQUFHLEVBQUUsQ0FBQ2dCLFFBQVEsSUFBSSxLQUFLO1FBQzdFRixXQUFXRyxHQUFHO1FBRWQsK0dBQStHO1FBQy9HLGdEQUFnRDtRQUNoRCxFQUFFO1FBQ0YsOEJBQThCO1FBQzlCLHVDQUF1QztRQUN2QyxFQUFFO1FBQ0YsZ0RBQWdEO1FBQ2hELHVGQUF1RjtRQUN2RixJQUFJaEMsbUJBQW1Ca0IsSUFBSSxDQUFDVyxVQUFVLENBQUNBLFdBQVdkLE1BQU0sR0FBRyxFQUFFLENBQUNnQixRQUFRLElBQUksS0FBSztZQUM3RUYsV0FBV0csR0FBRztRQUNoQjtJQUNGO0lBRUEsT0FBT0gsV0FBV0ssS0FBSyxDQUFDLEdBQUdwQyx3QkFBd0JTLEdBQUcsQ0FBQ2UsQ0FBQUEsUUFBVTtZQUMvRCxHQUFHQSxLQUFLO1lBQ1JhLFVBQVViLE1BQU1hLFFBQVEsSUFBSU4sVUFBVSxDQUFDQSxXQUFXZCxNQUFNLEdBQUcsRUFBRSxDQUFDb0IsUUFBUTtZQUN0RUosVUFBVVQsTUFBTVMsUUFBUSxJQUFJO1FBQzlCO0FBQ0Y7QUFFQSxNQUFNSyxzQkFBc0I7QUFFNUI7O0NBRUMsR0FDRCxTQUFTQyxnQkFBZ0JDLEVBQUU7SUFDekIsSUFBSTtRQUNGLElBQUksQ0FBQ0EsTUFBTSxPQUFPQSxPQUFPLFlBQVk7WUFDbkMsT0FBT0Y7UUFDVDtRQUNBLE9BQU9FLEdBQUdDLElBQUksSUFBSUg7SUFDcEIsRUFBRSxPQUFPSSxHQUFHO1FBQ1YsNERBQTREO1FBQzVELGdFQUFnRTtRQUNoRSxPQUFPSjtJQUNUO0FBQ0Y7QUFFQTs7Ozs7Q0FLQyxHQUNELFNBQVNLLG9CQUFvQkMsU0FBUztJQUNwQyxPQUFPO1FBQUM7UUFBSTlDLDBEQUFJQSxDQUFDOEM7S0FBVztBQUM5QjtBQUVtSSxDQUNuSSxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vYnJhbGluay13ZWIvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS91dGlscy9lc20vc3RhY2t0cmFjZS5qcz81NmQ4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG5vZGUgfSBmcm9tICcuL25vZGUtc3RhY2stdHJhY2UuanMnO1xuZXhwb3J0IHsgZmlsZW5hbWVJc0luQXBwIH0gZnJvbSAnLi9ub2RlLXN0YWNrLXRyYWNlLmpzJztcblxuY29uc3QgU1RBQ0tUUkFDRV9GUkFNRV9MSU1JVCA9IDUwO1xuLy8gVXNlZCB0byBzYW5pdGl6ZSB3ZWJwYWNrIChlcnJvcjogKikgd3JhcHBlZCBzdGFjayBlcnJvcnNcbmNvbnN0IFdFQlBBQ0tfRVJST1JfUkVHRVhQID0gL1xcKGVycm9yOiAoLiopXFwpLztcbmNvbnN0IFNUUklQX0ZSQU1FX1JFR0VYUCA9IC9jYXB0dXJlTWVzc2FnZXxjYXB0dXJlRXhjZXB0aW9uLztcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhY2sgcGFyc2VyIHdpdGggdGhlIHN1cHBsaWVkIGxpbmUgcGFyc2Vyc1xuICpcbiAqIFN0YWNrRnJhbWVzIGFyZSByZXR1cm5lZCBpbiB0aGUgY29ycmVjdCBvcmRlciBmb3IgU2VudHJ5IEV4Y2VwdGlvblxuICogZnJhbWVzIGFuZCB3aXRoIFNlbnRyeSBTREsgaW50ZXJuYWwgZnJhbWVzIHJlbW92ZWQgZnJvbSB0aGUgdG9wIGFuZCBib3R0b21cbiAqXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVN0YWNrUGFyc2VyKC4uLnBhcnNlcnMpIHtcbiAgY29uc3Qgc29ydGVkUGFyc2VycyA9IHBhcnNlcnMuc29ydCgoYSwgYikgPT4gYVswXSAtIGJbMF0pLm1hcChwID0+IHBbMV0pO1xuXG4gIHJldHVybiAoc3RhY2ssIHNraXBGaXJzdCA9IDApID0+IHtcbiAgICBjb25zdCBmcmFtZXMgPSBbXTtcbiAgICBjb25zdCBsaW5lcyA9IHN0YWNrLnNwbGl0KCdcXG4nKTtcblxuICAgIGZvciAobGV0IGkgPSBza2lwRmlyc3Q7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbGluZSA9IGxpbmVzW2ldO1xuICAgICAgLy8gSWdub3JlIGxpbmVzIG92ZXIgMWtiIGFzIHRoZXkgYXJlIHVubGlrZWx5IHRvIGJlIHN0YWNrIGZyYW1lcy5cbiAgICAgIC8vIE1hbnkgb2YgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbnMgdXNlIGJhY2t0cmFja2luZyB3aGljaCByZXN1bHRzIGluIHJ1biB0aW1lIHRoYXQgaW5jcmVhc2VzIGV4cG9uZW50aWFsbHkgd2l0aFxuICAgICAgLy8gaW5wdXQgc2l6ZS4gSHVnZSBzdHJpbmdzIGNhbiByZXN1bHQgaW4gaGFuZ3MvRGVuaWFsIG9mIFNlcnZpY2U6XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ2V0c2VudHJ5L3NlbnRyeS1qYXZhc2NyaXB0L2lzc3Vlcy8yMjg2XG4gICAgICBpZiAobGluZS5sZW5ndGggPiAxMDI0KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ2V0c2VudHJ5L3NlbnRyeS1qYXZhc2NyaXB0L2lzc3Vlcy81NDU5XG4gICAgICAvLyBSZW1vdmUgd2VicGFjayAoZXJyb3I6ICopIHdyYXBwZXJzXG4gICAgICBjb25zdCBjbGVhbmVkTGluZSA9IFdFQlBBQ0tfRVJST1JfUkVHRVhQLnRlc3QobGluZSkgPyBsaW5lLnJlcGxhY2UoV0VCUEFDS19FUlJPUl9SRUdFWFAsICckMScpIDogbGluZTtcblxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dldHNlbnRyeS9zZW50cnktamF2YXNjcmlwdC9pc3N1ZXMvNzgxM1xuICAgICAgLy8gU2tpcCBFcnJvcjogbGluZXNcbiAgICAgIGlmIChjbGVhbmVkTGluZS5tYXRjaCgvXFxTKkVycm9yOiAvKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBwYXJzZXIgb2Ygc29ydGVkUGFyc2Vycykge1xuICAgICAgICBjb25zdCBmcmFtZSA9IHBhcnNlcihjbGVhbmVkTGluZSk7XG5cbiAgICAgICAgaWYgKGZyYW1lKSB7XG4gICAgICAgICAgZnJhbWVzLnB1c2goZnJhbWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmcmFtZXMubGVuZ3RoID49IFNUQUNLVFJBQ0VfRlJBTUVfTElNSVQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmlwU2VudHJ5RnJhbWVzQW5kUmV2ZXJzZShmcmFtZXMpO1xuICB9O1xufVxuXG4vKipcbiAqIEdldHMgYSBzdGFjayBwYXJzZXIgaW1wbGVtZW50YXRpb24gZnJvbSBPcHRpb25zLnN0YWNrUGFyc2VyXG4gKiBAc2VlIE9wdGlvbnNcbiAqXG4gKiBJZiBvcHRpb25zIGNvbnRhaW5zIGFuIGFycmF5IG9mIGxpbmUgcGFyc2VycywgaXQgaXMgY29udmVydGVkIGludG8gYSBwYXJzZXJcbiAqL1xuZnVuY3Rpb24gc3RhY2tQYXJzZXJGcm9tU3RhY2tQYXJzZXJPcHRpb25zKHN0YWNrUGFyc2VyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHN0YWNrUGFyc2VyKSkge1xuICAgIHJldHVybiBjcmVhdGVTdGFja1BhcnNlciguLi5zdGFja1BhcnNlcik7XG4gIH1cbiAgcmV0dXJuIHN0YWNrUGFyc2VyO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgU2VudHJ5IGZyYW1lcyBmcm9tIHRoZSB0b3AgYW5kIGJvdHRvbSBvZiB0aGUgc3RhY2sgaWYgcHJlc2VudCBhbmQgZW5mb3JjZXMgYSBsaW1pdCBvZiBtYXggbnVtYmVyIG9mIGZyYW1lcy5cbiAqIEFzc3VtZXMgc3RhY2sgaW5wdXQgaXMgb3JkZXJlZCBmcm9tIHRvcCB0byBib3R0b20gYW5kIHJldHVybnMgdGhlIHJldmVyc2UgcmVwcmVzZW50YXRpb24gc28gY2FsbCBzaXRlIG9mIHRoZVxuICogZnVuY3Rpb24gdGhhdCBjYXVzZWQgdGhlIGNyYXNoIGlzIHRoZSBsYXN0IGZyYW1lIGluIHRoZSBhcnJheS5cbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gc3RyaXBTZW50cnlGcmFtZXNBbmRSZXZlcnNlKHN0YWNrKSB7XG4gIGlmICghc3RhY2subGVuZ3RoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgY29uc3QgbG9jYWxTdGFjayA9IEFycmF5LmZyb20oc3RhY2spO1xuXG4gIC8vIElmIHN0YWNrIHN0YXJ0cyB3aXRoIG9uZSBvZiBvdXIgQVBJIGNhbGxzLCByZW1vdmUgaXQgKHN0YXJ0cywgbWVhbmluZyBpdCdzIHRoZSB0b3Agb2YgdGhlIHN0YWNrIC0gYWthIGxhc3QgY2FsbClcbiAgaWYgKC9zZW50cnlXcmFwcGVkLy50ZXN0KGxvY2FsU3RhY2tbbG9jYWxTdGFjay5sZW5ndGggLSAxXS5mdW5jdGlvbiB8fCAnJykpIHtcbiAgICBsb2NhbFN0YWNrLnBvcCgpO1xuICB9XG5cbiAgLy8gUmV2ZXJzaW5nIGluIHRoZSBtaWRkbGUgb2YgdGhlIHByb2NlZHVyZSBhbGxvd3MgdXMgdG8ganVzdCBwb3AgdGhlIHZhbHVlcyBvZmYgdGhlIHN0YWNrXG4gIGxvY2FsU3RhY2sucmV2ZXJzZSgpO1xuXG4gIC8vIElmIHN0YWNrIGVuZHMgd2l0aCBvbmUgb2Ygb3VyIGludGVybmFsIEFQSSBjYWxscywgcmVtb3ZlIGl0IChlbmRzLCBtZWFuaW5nIGl0J3MgdGhlIGJvdHRvbSBvZiB0aGUgc3RhY2sgLSBha2EgdG9wLW1vc3QgY2FsbClcbiAgaWYgKFNUUklQX0ZSQU1FX1JFR0VYUC50ZXN0KGxvY2FsU3RhY2tbbG9jYWxTdGFjay5sZW5ndGggLSAxXS5mdW5jdGlvbiB8fCAnJykpIHtcbiAgICBsb2NhbFN0YWNrLnBvcCgpO1xuXG4gICAgLy8gV2hlbiB1c2luZyBzeW50aGV0aWMgZXZlbnRzLCB3ZSB3aWxsIGhhdmUgYSAyIGxldmVscyBkZWVwIHN0YWNrLCBhcyBgbmV3IEVycm9yKCdTZW50cnkgc3ludGhldGljRXhjZXB0aW9uJylgXG4gICAgLy8gaXMgcHJvZHVjZWQgd2l0aGluIHRoZSBodWIgaXRzZWxmLCBtYWtpbmcgaXQ6XG4gICAgLy9cbiAgICAvLyAgIFNlbnRyeS5jYXB0dXJlRXhjZXB0aW9uKClcbiAgICAvLyAgIGdldEN1cnJlbnRIdWIoKS5jYXB0dXJlRXhjZXB0aW9uKClcbiAgICAvL1xuICAgIC8vIGluc3RlYWQgb2YganVzdCB0aGUgdG9wIGBTZW50cnlgIGNhbGwgaXRzZWxmLlxuICAgIC8vIFRoaXMgZm9yY2VzIHVzIHRvIHBvc3NpYmx5IHN0cmlwIGFuIGFkZGl0aW9uYWwgZnJhbWUgaW4gdGhlIGV4YWN0IHNhbWUgd2FzIGFzIGFib3ZlLlxuICAgIGlmIChTVFJJUF9GUkFNRV9SRUdFWFAudGVzdChsb2NhbFN0YWNrW2xvY2FsU3RhY2subGVuZ3RoIC0gMV0uZnVuY3Rpb24gfHwgJycpKSB7XG4gICAgICBsb2NhbFN0YWNrLnBvcCgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsb2NhbFN0YWNrLnNsaWNlKDAsIFNUQUNLVFJBQ0VfRlJBTUVfTElNSVQpLm1hcChmcmFtZSA9PiAoe1xuICAgIC4uLmZyYW1lLFxuICAgIGZpbGVuYW1lOiBmcmFtZS5maWxlbmFtZSB8fCBsb2NhbFN0YWNrW2xvY2FsU3RhY2subGVuZ3RoIC0gMV0uZmlsZW5hbWUsXG4gICAgZnVuY3Rpb246IGZyYW1lLmZ1bmN0aW9uIHx8ICc/JyxcbiAgfSkpO1xufVxuXG5jb25zdCBkZWZhdWx0RnVuY3Rpb25OYW1lID0gJzxhbm9ueW1vdXM+JztcblxuLyoqXG4gKiBTYWZlbHkgZXh0cmFjdCBmdW5jdGlvbiBuYW1lIGZyb20gaXRzZWxmXG4gKi9cbmZ1bmN0aW9uIGdldEZ1bmN0aW9uTmFtZShmbikge1xuICB0cnkge1xuICAgIGlmICghZm4gfHwgdHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdEZ1bmN0aW9uTmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLm5hbWUgfHwgZGVmYXVsdEZ1bmN0aW9uTmFtZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIEp1c3QgYWNjZXNzaW5nIGN1c3RvbSBwcm9wcyBpbiBzb21lIFNlbGVuaXVtIGVudmlyb25tZW50c1xuICAgIC8vIGNhbiBjYXVzZSBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBleGNlcHRpb24gKHNlZSByYXZlbi1qcyM0OTUpLlxuICAgIHJldHVybiBkZWZhdWx0RnVuY3Rpb25OYW1lO1xuICB9XG59XG5cbi8qKlxuICogTm9kZS5qcyBzdGFjayBsaW5lIHBhcnNlclxuICpcbiAqIFRoaXMgaXMgaW4gQHNlbnRyeS91dGlscyBzbyBpdCBjYW4gYmUgdXNlZCBmcm9tIHRoZSBFbGVjdHJvbiBTREsgaW4gdGhlIGJyb3dzZXIgZm9yIHdoZW4gYG5vZGVJbnRlZ3JhdGlvbiA9PSB0cnVlYC5cbiAqIFRoaXMgYWxsb3dzIGl0IHRvIGJlIHVzZWQgd2l0aG91dCByZWZlcmVuY2luZyBvciBpbXBvcnRpbmcgYW55IG5vZGUgc3BlY2lmaWMgY29kZSB3aGljaCBjYXVzZXMgYnVuZGxlcnMgdG8gY29tcGxhaW5cbiAqL1xuZnVuY3Rpb24gbm9kZVN0YWNrTGluZVBhcnNlcihnZXRNb2R1bGUpIHtcbiAgcmV0dXJuIFs5MCwgbm9kZShnZXRNb2R1bGUpXTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlU3RhY2tQYXJzZXIsIGdldEZ1bmN0aW9uTmFtZSwgbm9kZVN0YWNrTGluZVBhcnNlciwgc3RhY2tQYXJzZXJGcm9tU3RhY2tQYXJzZXJPcHRpb25zLCBzdHJpcFNlbnRyeUZyYW1lc0FuZFJldmVyc2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YWNrdHJhY2UuanMubWFwXG4iXSwibmFtZXMiOlsibm9kZSIsImZpbGVuYW1lSXNJbkFwcCIsIlNUQUNLVFJBQ0VfRlJBTUVfTElNSVQiLCJXRUJQQUNLX0VSUk9SX1JFR0VYUCIsIlNUUklQX0ZSQU1FX1JFR0VYUCIsImNyZWF0ZVN0YWNrUGFyc2VyIiwicGFyc2VycyIsInNvcnRlZFBhcnNlcnMiLCJzb3J0IiwiYSIsImIiLCJtYXAiLCJwIiwic3RhY2siLCJza2lwRmlyc3QiLCJmcmFtZXMiLCJsaW5lcyIsInNwbGl0IiwiaSIsImxlbmd0aCIsImxpbmUiLCJjbGVhbmVkTGluZSIsInRlc3QiLCJyZXBsYWNlIiwibWF0Y2giLCJwYXJzZXIiLCJmcmFtZSIsInB1c2giLCJzdHJpcFNlbnRyeUZyYW1lc0FuZFJldmVyc2UiLCJzdGFja1BhcnNlckZyb21TdGFja1BhcnNlck9wdGlvbnMiLCJzdGFja1BhcnNlciIsIkFycmF5IiwiaXNBcnJheSIsImxvY2FsU3RhY2siLCJmcm9tIiwiZnVuY3Rpb24iLCJwb3AiLCJyZXZlcnNlIiwic2xpY2UiLCJmaWxlbmFtZSIsImRlZmF1bHRGdW5jdGlvbk5hbWUiLCJnZXRGdW5jdGlvbk5hbWUiLCJmbiIsIm5hbWUiLCJlIiwibm9kZVN0YWNrTGluZVBhcnNlciIsImdldE1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/utils/esm/stacktrace.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sentry/utils/esm/string.js":
/*!**************************************************!*\
  !*** ./node_modules/@sentry/utils/esm/string.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isMatchingPattern: () => (/* binding */ isMatchingPattern),\n/* harmony export */   safeJoin: () => (/* binding */ safeJoin),\n/* harmony export */   snipLine: () => (/* binding */ snipLine),\n/* harmony export */   stringMatchesSomePattern: () => (/* binding */ stringMatchesSomePattern),\n/* harmony export */   truncate: () => (/* binding */ truncate)\n/* harmony export */ });\n/* harmony import */ var _is_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is.js */ \"(ssr)/./node_modules/@sentry/utils/esm/is.js\");\n\n/**\n * Truncates given string to the maximum characters count\n *\n * @param str An object that contains serializable values\n * @param max Maximum number of characters in truncated string (0 = unlimited)\n * @returns string Encoded\n */ function truncate(str, max = 0) {\n    if (typeof str !== \"string\" || max === 0) {\n        return str;\n    }\n    return str.length <= max ? str : `${str.slice(0, max)}...`;\n}\n/**\n * This is basically just `trim_line` from\n * https://github.com/getsentry/sentry/blob/master/src/sentry/lang/javascript/processor.py#L67\n *\n * @param str An object that contains serializable values\n * @param max Maximum number of characters in truncated string\n * @returns string Encoded\n */ function snipLine(line, colno) {\n    let newLine = line;\n    const lineLength = newLine.length;\n    if (lineLength <= 150) {\n        return newLine;\n    }\n    if (colno > lineLength) {\n        // eslint-disable-next-line no-param-reassign\n        colno = lineLength;\n    }\n    let start = Math.max(colno - 60, 0);\n    if (start < 5) {\n        start = 0;\n    }\n    let end = Math.min(start + 140, lineLength);\n    if (end > lineLength - 5) {\n        end = lineLength;\n    }\n    if (end === lineLength) {\n        start = Math.max(end - 140, 0);\n    }\n    newLine = newLine.slice(start, end);\n    if (start > 0) {\n        newLine = `'{snip} ${newLine}`;\n    }\n    if (end < lineLength) {\n        newLine += \" {snip}\";\n    }\n    return newLine;\n}\n/**\n * Join values in array\n * @param input array of values to be joined together\n * @param delimiter string to be placed in-between values\n * @returns Joined values\n */ // eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction safeJoin(input, delimiter) {\n    if (!Array.isArray(input)) {\n        return \"\";\n    }\n    const output = [];\n    // eslint-disable-next-line @typescript-eslint/prefer-for-of\n    for(let i = 0; i < input.length; i++){\n        const value = input[i];\n        try {\n            // This is a hack to fix a Vue3-specific bug that causes an infinite loop of\n            // console warnings. This happens when a Vue template is rendered with\n            // an undeclared variable, which we try to stringify, ultimately causing\n            // Vue to issue another warning which repeats indefinitely.\n            // see: https://github.com/getsentry/sentry-javascript/pull/8981\n            if ((0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isVueViewModel)(value)) {\n                output.push(\"[VueViewModel]\");\n            } else {\n                output.push(String(value));\n            }\n        } catch (e) {\n            output.push(\"[value cannot be serialized]\");\n        }\n    }\n    return output.join(delimiter);\n}\n/**\n * Checks if the given value matches a regex or string\n *\n * @param value The string to test\n * @param pattern Either a regex or a string against which `value` will be matched\n * @param requireExactStringMatch If true, `value` must match `pattern` exactly. If false, `value` will match\n * `pattern` if it contains `pattern`. Only applies to string-type patterns.\n */ function isMatchingPattern(value, pattern, requireExactStringMatch = false) {\n    if (!(0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isString)(value)) {\n        return false;\n    }\n    if ((0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isRegExp)(pattern)) {\n        return pattern.test(value);\n    }\n    if ((0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isString)(pattern)) {\n        return requireExactStringMatch ? value === pattern : value.includes(pattern);\n    }\n    return false;\n}\n/**\n * Test the given string against an array of strings and regexes. By default, string matching is done on a\n * substring-inclusion basis rather than a strict equality basis\n *\n * @param testString The string to test\n * @param patterns The patterns against which to test the string\n * @param requireExactStringMatch If true, `testString` must match one of the given string patterns exactly in order to\n * count. If false, `testString` will match a string pattern if it contains that pattern.\n * @returns\n */ function stringMatchesSomePattern(testString, patterns = [], requireExactStringMatch = false) {\n    return patterns.some((pattern)=>isMatchingPattern(testString, pattern, requireExactStringMatch));\n}\n //# sourceMappingURL=string.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS91dGlscy9lc20vc3RyaW5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUE2RDtBQUU3RDs7Ozs7O0NBTUMsR0FDRCxTQUFTRyxTQUFTQyxHQUFHLEVBQUVDLE1BQU0sQ0FBQztJQUM1QixJQUFJLE9BQU9ELFFBQVEsWUFBWUMsUUFBUSxHQUFHO1FBQ3hDLE9BQU9EO0lBQ1Q7SUFDQSxPQUFPQSxJQUFJRSxNQUFNLElBQUlELE1BQU1ELE1BQU0sQ0FBQyxFQUFFQSxJQUFJRyxLQUFLLENBQUMsR0FBR0YsS0FBSyxHQUFHLENBQUM7QUFDNUQ7QUFFQTs7Ozs7OztDQU9DLEdBQ0QsU0FBU0csU0FBU0MsSUFBSSxFQUFFQyxLQUFLO0lBQzNCLElBQUlDLFVBQVVGO0lBQ2QsTUFBTUcsYUFBYUQsUUFBUUwsTUFBTTtJQUNqQyxJQUFJTSxjQUFjLEtBQUs7UUFDckIsT0FBT0Q7SUFDVDtJQUNBLElBQUlELFFBQVFFLFlBQVk7UUFDdEIsNkNBQTZDO1FBQzdDRixRQUFRRTtJQUNWO0lBRUEsSUFBSUMsUUFBUUMsS0FBS1QsR0FBRyxDQUFDSyxRQUFRLElBQUk7SUFDakMsSUFBSUcsUUFBUSxHQUFHO1FBQ2JBLFFBQVE7SUFDVjtJQUVBLElBQUlFLE1BQU1ELEtBQUtFLEdBQUcsQ0FBQ0gsUUFBUSxLQUFLRDtJQUNoQyxJQUFJRyxNQUFNSCxhQUFhLEdBQUc7UUFDeEJHLE1BQU1IO0lBQ1I7SUFDQSxJQUFJRyxRQUFRSCxZQUFZO1FBQ3RCQyxRQUFRQyxLQUFLVCxHQUFHLENBQUNVLE1BQU0sS0FBSztJQUM5QjtJQUVBSixVQUFVQSxRQUFRSixLQUFLLENBQUNNLE9BQU9FO0lBQy9CLElBQUlGLFFBQVEsR0FBRztRQUNiRixVQUFVLENBQUMsUUFBUSxFQUFFQSxRQUFRLENBQUM7SUFDaEM7SUFDQSxJQUFJSSxNQUFNSCxZQUFZO1FBQ3BCRCxXQUFXO0lBQ2I7SUFFQSxPQUFPQTtBQUNUO0FBRUE7Ozs7O0NBS0MsR0FDRCw4REFBOEQ7QUFDOUQsU0FBU00sU0FBU0MsS0FBSyxFQUFFQyxTQUFTO0lBQ2hDLElBQUksQ0FBQ0MsTUFBTUMsT0FBTyxDQUFDSCxRQUFRO1FBQ3pCLE9BQU87SUFDVDtJQUVBLE1BQU1JLFNBQVMsRUFBRTtJQUNqQiw0REFBNEQ7SUFDNUQsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlMLE1BQU1aLE1BQU0sRUFBRWlCLElBQUs7UUFDckMsTUFBTUMsUUFBUU4sS0FBSyxDQUFDSyxFQUFFO1FBQ3RCLElBQUk7WUFDRiw0RUFBNEU7WUFDNUUsc0VBQXNFO1lBQ3RFLHdFQUF3RTtZQUN4RSwyREFBMkQ7WUFDM0QsZ0VBQWdFO1lBQ2hFLElBQUl2QixzREFBY0EsQ0FBQ3dCLFFBQVE7Z0JBQ3pCRixPQUFPRyxJQUFJLENBQUM7WUFDZCxPQUFPO2dCQUNMSCxPQUFPRyxJQUFJLENBQUNDLE9BQU9GO1lBQ3JCO1FBQ0YsRUFBRSxPQUFPRyxHQUFHO1lBQ1ZMLE9BQU9HLElBQUksQ0FBQztRQUNkO0lBQ0Y7SUFFQSxPQUFPSCxPQUFPTSxJQUFJLENBQUNUO0FBQ3JCO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNELFNBQVNVLGtCQUNQTCxLQUFLLEVBQ0xNLE9BQU8sRUFDUEMsMEJBQTBCLEtBQUs7SUFFL0IsSUFBSSxDQUFDOUIsZ0RBQVFBLENBQUN1QixRQUFRO1FBQ3BCLE9BQU87SUFDVDtJQUVBLElBQUl0QixnREFBUUEsQ0FBQzRCLFVBQVU7UUFDckIsT0FBT0EsUUFBUUUsSUFBSSxDQUFDUjtJQUN0QjtJQUNBLElBQUl2QixnREFBUUEsQ0FBQzZCLFVBQVU7UUFDckIsT0FBT0MsMEJBQTBCUCxVQUFVTSxVQUFVTixNQUFNUyxRQUFRLENBQUNIO0lBQ3RFO0lBRUEsT0FBTztBQUNUO0FBRUE7Ozs7Ozs7OztDQVNDLEdBQ0QsU0FBU0kseUJBQ1BDLFVBQVUsRUFDVkMsV0FBVyxFQUFFLEVBQ2JMLDBCQUEwQixLQUFLO0lBRS9CLE9BQU9LLFNBQVNDLElBQUksQ0FBQ1AsQ0FBQUEsVUFBV0Qsa0JBQWtCTSxZQUFZTCxTQUFTQztBQUN6RTtBQUVxRixDQUNyRixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vYnJhbGluay13ZWIvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS91dGlscy9lc20vc3RyaW5nLmpzP2M4OTEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNWdWVWaWV3TW9kZWwsIGlzU3RyaW5nLCBpc1JlZ0V4cCB9IGZyb20gJy4vaXMuanMnO1xuXG4vKipcbiAqIFRydW5jYXRlcyBnaXZlbiBzdHJpbmcgdG8gdGhlIG1heGltdW0gY2hhcmFjdGVycyBjb3VudFxuICpcbiAqIEBwYXJhbSBzdHIgQW4gb2JqZWN0IHRoYXQgY29udGFpbnMgc2VyaWFsaXphYmxlIHZhbHVlc1xuICogQHBhcmFtIG1heCBNYXhpbXVtIG51bWJlciBvZiBjaGFyYWN0ZXJzIGluIHRydW5jYXRlZCBzdHJpbmcgKDAgPSB1bmxpbWl0ZWQpXG4gKiBAcmV0dXJucyBzdHJpbmcgRW5jb2RlZFxuICovXG5mdW5jdGlvbiB0cnVuY2F0ZShzdHIsIG1heCA9IDApIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnIHx8IG1heCA9PT0gMCkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgcmV0dXJuIHN0ci5sZW5ndGggPD0gbWF4ID8gc3RyIDogYCR7c3RyLnNsaWNlKDAsIG1heCl9Li4uYDtcbn1cblxuLyoqXG4gKiBUaGlzIGlzIGJhc2ljYWxseSBqdXN0IGB0cmltX2xpbmVgIGZyb21cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nZXRzZW50cnkvc2VudHJ5L2Jsb2IvbWFzdGVyL3NyYy9zZW50cnkvbGFuZy9qYXZhc2NyaXB0L3Byb2Nlc3Nvci5weSNMNjdcbiAqXG4gKiBAcGFyYW0gc3RyIEFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHNlcmlhbGl6YWJsZSB2YWx1ZXNcbiAqIEBwYXJhbSBtYXggTWF4aW11bSBudW1iZXIgb2YgY2hhcmFjdGVycyBpbiB0cnVuY2F0ZWQgc3RyaW5nXG4gKiBAcmV0dXJucyBzdHJpbmcgRW5jb2RlZFxuICovXG5mdW5jdGlvbiBzbmlwTGluZShsaW5lLCBjb2xubykge1xuICBsZXQgbmV3TGluZSA9IGxpbmU7XG4gIGNvbnN0IGxpbmVMZW5ndGggPSBuZXdMaW5lLmxlbmd0aDtcbiAgaWYgKGxpbmVMZW5ndGggPD0gMTUwKSB7XG4gICAgcmV0dXJuIG5ld0xpbmU7XG4gIH1cbiAgaWYgKGNvbG5vID4gbGluZUxlbmd0aCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIGNvbG5vID0gbGluZUxlbmd0aDtcbiAgfVxuXG4gIGxldCBzdGFydCA9IE1hdGgubWF4KGNvbG5vIC0gNjAsIDApO1xuICBpZiAoc3RhcnQgPCA1KSB7XG4gICAgc3RhcnQgPSAwO1xuICB9XG5cbiAgbGV0IGVuZCA9IE1hdGgubWluKHN0YXJ0ICsgMTQwLCBsaW5lTGVuZ3RoKTtcbiAgaWYgKGVuZCA+IGxpbmVMZW5ndGggLSA1KSB7XG4gICAgZW5kID0gbGluZUxlbmd0aDtcbiAgfVxuICBpZiAoZW5kID09PSBsaW5lTGVuZ3RoKSB7XG4gICAgc3RhcnQgPSBNYXRoLm1heChlbmQgLSAxNDAsIDApO1xuICB9XG5cbiAgbmV3TGluZSA9IG5ld0xpbmUuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gIGlmIChzdGFydCA+IDApIHtcbiAgICBuZXdMaW5lID0gYCd7c25pcH0gJHtuZXdMaW5lfWA7XG4gIH1cbiAgaWYgKGVuZCA8IGxpbmVMZW5ndGgpIHtcbiAgICBuZXdMaW5lICs9ICcge3NuaXB9JztcbiAgfVxuXG4gIHJldHVybiBuZXdMaW5lO1xufVxuXG4vKipcbiAqIEpvaW4gdmFsdWVzIGluIGFycmF5XG4gKiBAcGFyYW0gaW5wdXQgYXJyYXkgb2YgdmFsdWVzIHRvIGJlIGpvaW5lZCB0b2dldGhlclxuICogQHBhcmFtIGRlbGltaXRlciBzdHJpbmcgdG8gYmUgcGxhY2VkIGluLWJldHdlZW4gdmFsdWVzXG4gKiBAcmV0dXJucyBKb2luZWQgdmFsdWVzXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBzYWZlSm9pbihpbnB1dCwgZGVsaW1pdGVyKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItZm9yLW9mXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB2YWx1ZSA9IGlucHV0W2ldO1xuICAgIHRyeSB7XG4gICAgICAvLyBUaGlzIGlzIGEgaGFjayB0byBmaXggYSBWdWUzLXNwZWNpZmljIGJ1ZyB0aGF0IGNhdXNlcyBhbiBpbmZpbml0ZSBsb29wIG9mXG4gICAgICAvLyBjb25zb2xlIHdhcm5pbmdzLiBUaGlzIGhhcHBlbnMgd2hlbiBhIFZ1ZSB0ZW1wbGF0ZSBpcyByZW5kZXJlZCB3aXRoXG4gICAgICAvLyBhbiB1bmRlY2xhcmVkIHZhcmlhYmxlLCB3aGljaCB3ZSB0cnkgdG8gc3RyaW5naWZ5LCB1bHRpbWF0ZWx5IGNhdXNpbmdcbiAgICAgIC8vIFZ1ZSB0byBpc3N1ZSBhbm90aGVyIHdhcm5pbmcgd2hpY2ggcmVwZWF0cyBpbmRlZmluaXRlbHkuXG4gICAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9nZXRzZW50cnkvc2VudHJ5LWphdmFzY3JpcHQvcHVsbC84OTgxXG4gICAgICBpZiAoaXNWdWVWaWV3TW9kZWwodmFsdWUpKSB7XG4gICAgICAgIG91dHB1dC5wdXNoKCdbVnVlVmlld01vZGVsXScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0LnB1c2goU3RyaW5nKHZhbHVlKSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgb3V0cHV0LnB1c2goJ1t2YWx1ZSBjYW5ub3QgYmUgc2VyaWFsaXplZF0nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0cHV0LmpvaW4oZGVsaW1pdGVyKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIHZhbHVlIG1hdGNoZXMgYSByZWdleCBvciBzdHJpbmdcbiAqXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHN0cmluZyB0byB0ZXN0XG4gKiBAcGFyYW0gcGF0dGVybiBFaXRoZXIgYSByZWdleCBvciBhIHN0cmluZyBhZ2FpbnN0IHdoaWNoIGB2YWx1ZWAgd2lsbCBiZSBtYXRjaGVkXG4gKiBAcGFyYW0gcmVxdWlyZUV4YWN0U3RyaW5nTWF0Y2ggSWYgdHJ1ZSwgYHZhbHVlYCBtdXN0IG1hdGNoIGBwYXR0ZXJuYCBleGFjdGx5LiBJZiBmYWxzZSwgYHZhbHVlYCB3aWxsIG1hdGNoXG4gKiBgcGF0dGVybmAgaWYgaXQgY29udGFpbnMgYHBhdHRlcm5gLiBPbmx5IGFwcGxpZXMgdG8gc3RyaW5nLXR5cGUgcGF0dGVybnMuXG4gKi9cbmZ1bmN0aW9uIGlzTWF0Y2hpbmdQYXR0ZXJuKFxuICB2YWx1ZSxcbiAgcGF0dGVybixcbiAgcmVxdWlyZUV4YWN0U3RyaW5nTWF0Y2ggPSBmYWxzZSxcbikge1xuICBpZiAoIWlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChpc1JlZ0V4cChwYXR0ZXJuKSkge1xuICAgIHJldHVybiBwYXR0ZXJuLnRlc3QodmFsdWUpO1xuICB9XG4gIGlmIChpc1N0cmluZyhwYXR0ZXJuKSkge1xuICAgIHJldHVybiByZXF1aXJlRXhhY3RTdHJpbmdNYXRjaCA/IHZhbHVlID09PSBwYXR0ZXJuIDogdmFsdWUuaW5jbHVkZXMocGF0dGVybik7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogVGVzdCB0aGUgZ2l2ZW4gc3RyaW5nIGFnYWluc3QgYW4gYXJyYXkgb2Ygc3RyaW5ncyBhbmQgcmVnZXhlcy4gQnkgZGVmYXVsdCwgc3RyaW5nIG1hdGNoaW5nIGlzIGRvbmUgb24gYVxuICogc3Vic3RyaW5nLWluY2x1c2lvbiBiYXNpcyByYXRoZXIgdGhhbiBhIHN0cmljdCBlcXVhbGl0eSBiYXNpc1xuICpcbiAqIEBwYXJhbSB0ZXN0U3RyaW5nIFRoZSBzdHJpbmcgdG8gdGVzdFxuICogQHBhcmFtIHBhdHRlcm5zIFRoZSBwYXR0ZXJucyBhZ2FpbnN0IHdoaWNoIHRvIHRlc3QgdGhlIHN0cmluZ1xuICogQHBhcmFtIHJlcXVpcmVFeGFjdFN0cmluZ01hdGNoIElmIHRydWUsIGB0ZXN0U3RyaW5nYCBtdXN0IG1hdGNoIG9uZSBvZiB0aGUgZ2l2ZW4gc3RyaW5nIHBhdHRlcm5zIGV4YWN0bHkgaW4gb3JkZXIgdG9cbiAqIGNvdW50LiBJZiBmYWxzZSwgYHRlc3RTdHJpbmdgIHdpbGwgbWF0Y2ggYSBzdHJpbmcgcGF0dGVybiBpZiBpdCBjb250YWlucyB0aGF0IHBhdHRlcm4uXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBzdHJpbmdNYXRjaGVzU29tZVBhdHRlcm4oXG4gIHRlc3RTdHJpbmcsXG4gIHBhdHRlcm5zID0gW10sXG4gIHJlcXVpcmVFeGFjdFN0cmluZ01hdGNoID0gZmFsc2UsXG4pIHtcbiAgcmV0dXJuIHBhdHRlcm5zLnNvbWUocGF0dGVybiA9PiBpc01hdGNoaW5nUGF0dGVybih0ZXN0U3RyaW5nLCBwYXR0ZXJuLCByZXF1aXJlRXhhY3RTdHJpbmdNYXRjaCkpO1xufVxuXG5leHBvcnQgeyBpc01hdGNoaW5nUGF0dGVybiwgc2FmZUpvaW4sIHNuaXBMaW5lLCBzdHJpbmdNYXRjaGVzU29tZVBhdHRlcm4sIHRydW5jYXRlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJpbmcuanMubWFwXG4iXSwibmFtZXMiOlsiaXNWdWVWaWV3TW9kZWwiLCJpc1N0cmluZyIsImlzUmVnRXhwIiwidHJ1bmNhdGUiLCJzdHIiLCJtYXgiLCJsZW5ndGgiLCJzbGljZSIsInNuaXBMaW5lIiwibGluZSIsImNvbG5vIiwibmV3TGluZSIsImxpbmVMZW5ndGgiLCJzdGFydCIsIk1hdGgiLCJlbmQiLCJtaW4iLCJzYWZlSm9pbiIsImlucHV0IiwiZGVsaW1pdGVyIiwiQXJyYXkiLCJpc0FycmF5Iiwib3V0cHV0IiwiaSIsInZhbHVlIiwicHVzaCIsIlN0cmluZyIsImUiLCJqb2luIiwiaXNNYXRjaGluZ1BhdHRlcm4iLCJwYXR0ZXJuIiwicmVxdWlyZUV4YWN0U3RyaW5nTWF0Y2giLCJ0ZXN0IiwiaW5jbHVkZXMiLCJzdHJpbmdNYXRjaGVzU29tZVBhdHRlcm4iLCJ0ZXN0U3RyaW5nIiwicGF0dGVybnMiLCJzb21lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/utils/esm/string.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sentry/utils/esm/syncpromise.js":
/*!*******************************************************!*\
  !*** ./node_modules/@sentry/utils/esm/syncpromise.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SyncPromise: () => (/* binding */ SyncPromise),\n/* harmony export */   rejectedSyncPromise: () => (/* binding */ rejectedSyncPromise),\n/* harmony export */   resolvedSyncPromise: () => (/* binding */ resolvedSyncPromise)\n/* harmony export */ });\n/* harmony import */ var _is_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is.js */ \"(ssr)/./node_modules/@sentry/utils/esm/is.js\");\n\n/* eslint-disable @typescript-eslint/explicit-function-return-type */ /** SyncPromise internal states */ var States;\n(function(States) {\n    /** Pending */ const PENDING = 0;\n    States[States[\"PENDING\"] = PENDING] = \"PENDING\";\n    /** Resolved / OK */ const RESOLVED = 1;\n    States[States[\"RESOLVED\"] = RESOLVED] = \"RESOLVED\";\n    /** Rejected / Error */ const REJECTED = 2;\n    States[States[\"REJECTED\"] = REJECTED] = \"REJECTED\";\n})(States || (States = {}));\n// Overloads so we can call resolvedSyncPromise without arguments and generic argument\n/**\n * Creates a resolved sync promise.\n *\n * @param value the value to resolve the promise with\n * @returns the resolved sync promise\n */ function resolvedSyncPromise(value) {\n    return new SyncPromise((resolve)=>{\n        resolve(value);\n    });\n}\n/**\n * Creates a rejected sync promise.\n *\n * @param value the value to reject the promise with\n * @returns the rejected sync promise\n */ function rejectedSyncPromise(reason) {\n    return new SyncPromise((_, reject)=>{\n        reject(reason);\n    });\n}\n/**\n * Thenable class that behaves like a Promise and follows it's interface\n * but is not async internally\n */ class SyncPromise {\n    constructor(executor){\n        SyncPromise.prototype.__init.call(this);\n        SyncPromise.prototype.__init2.call(this);\n        SyncPromise.prototype.__init3.call(this);\n        SyncPromise.prototype.__init4.call(this);\n        this._state = States.PENDING;\n        this._handlers = [];\n        try {\n            executor(this._resolve, this._reject);\n        } catch (e) {\n            this._reject(e);\n        }\n    }\n    /** JSDoc */ then(onfulfilled, onrejected) {\n        return new SyncPromise((resolve, reject)=>{\n            this._handlers.push([\n                false,\n                (result)=>{\n                    if (!onfulfilled) {\n                        // TODO: ¯\\_(ツ)_/¯\n                        // TODO: FIXME\n                        resolve(result);\n                    } else {\n                        try {\n                            resolve(onfulfilled(result));\n                        } catch (e) {\n                            reject(e);\n                        }\n                    }\n                },\n                (reason)=>{\n                    if (!onrejected) {\n                        reject(reason);\n                    } else {\n                        try {\n                            resolve(onrejected(reason));\n                        } catch (e) {\n                            reject(e);\n                        }\n                    }\n                }\n            ]);\n            this._executeHandlers();\n        });\n    }\n    /** JSDoc */ catch(onrejected) {\n        return this.then((val)=>val, onrejected);\n    }\n    /** JSDoc */ finally(onfinally) {\n        return new SyncPromise((resolve, reject)=>{\n            let val;\n            let isRejected;\n            return this.then((value)=>{\n                isRejected = false;\n                val = value;\n                if (onfinally) {\n                    onfinally();\n                }\n            }, (reason)=>{\n                isRejected = true;\n                val = reason;\n                if (onfinally) {\n                    onfinally();\n                }\n            }).then(()=>{\n                if (isRejected) {\n                    reject(val);\n                    return;\n                }\n                resolve(val);\n            });\n        });\n    }\n    /** JSDoc */ __init() {\n        this._resolve = (value)=>{\n            this._setResult(States.RESOLVED, value);\n        };\n    }\n    /** JSDoc */ __init2() {\n        this._reject = (reason)=>{\n            this._setResult(States.REJECTED, reason);\n        };\n    }\n    /** JSDoc */ __init3() {\n        this._setResult = (state, value)=>{\n            if (this._state !== States.PENDING) {\n                return;\n            }\n            if ((0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isThenable)(value)) {\n                void value.then(this._resolve, this._reject);\n                return;\n            }\n            this._state = state;\n            this._value = value;\n            this._executeHandlers();\n        };\n    }\n    /** JSDoc */ __init4() {\n        this._executeHandlers = ()=>{\n            if (this._state === States.PENDING) {\n                return;\n            }\n            const cachedHandlers = this._handlers.slice();\n            this._handlers = [];\n            cachedHandlers.forEach((handler)=>{\n                if (handler[0]) {\n                    return;\n                }\n                if (this._state === States.RESOLVED) {\n                    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n                    handler[1](this._value);\n                }\n                if (this._state === States.REJECTED) {\n                    handler[2](this._value);\n                }\n                handler[0] = true;\n            });\n        };\n    }\n}\n //# sourceMappingURL=syncpromise.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS91dGlscy9lc20vc3luY3Byb21pc2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFxQztBQUVyQyxtRUFBbUUsR0FFbkUsZ0NBQWdDLEdBQ2hDLElBQUlDO0FBQVMsVUFBVUEsTUFBTTtJQUMzQixZQUFZLEdBQ1osTUFBTUMsVUFBVTtJQUFHRCxNQUFNLENBQUNBLE1BQU0sQ0FBQyxVQUFVLEdBQUdDLFFBQVEsR0FBRztJQUN6RCxrQkFBa0IsR0FDbEIsTUFBTUMsV0FBVztJQUFHRixNQUFNLENBQUNBLE1BQU0sQ0FBQyxXQUFXLEdBQUdFLFNBQVMsR0FBRztJQUM1RCxxQkFBcUIsR0FDckIsTUFBTUMsV0FBVztJQUFHSCxNQUFNLENBQUNBLE1BQU0sQ0FBQyxXQUFXLEdBQUdHLFNBQVMsR0FBRztBQUM5RCxHQUFHSCxVQUFXQSxDQUFBQSxTQUFTLENBQUM7QUFFeEIsc0ZBQXNGO0FBRXRGOzs7OztDQUtDLEdBQ0QsU0FBU0ksb0JBQW9CQyxLQUFLO0lBQ2hDLE9BQU8sSUFBSUMsWUFBWUMsQ0FBQUE7UUFDckJBLFFBQVFGO0lBQ1Y7QUFDRjtBQUVBOzs7OztDQUtDLEdBQ0QsU0FBU0csb0JBQW9CQyxNQUFNO0lBQ2pDLE9BQU8sSUFBSUgsWUFBWSxDQUFDSSxHQUFHQztRQUN6QkEsT0FBT0Y7SUFDVDtBQUNGO0FBRUE7OztDQUdDLEdBQ0QsTUFBTUg7SUFFSE0sWUFDQ0MsUUFBUSxDQUNSO1FBQUNQLFlBQVlRLFNBQVMsQ0FBQ0MsTUFBTSxDQUFDQyxJQUFJLENBQUMsSUFBSTtRQUFFVixZQUFZUSxTQUFTLENBQUNHLE9BQU8sQ0FBQ0QsSUFBSSxDQUFDLElBQUk7UUFBRVYsWUFBWVEsU0FBUyxDQUFDSSxPQUFPLENBQUNGLElBQUksQ0FBQyxJQUFJO1FBQUVWLFlBQVlRLFNBQVMsQ0FBQ0ssT0FBTyxDQUFDSCxJQUFJLENBQUMsSUFBSTtRQUNsSyxJQUFJLENBQUNJLE1BQU0sR0FBR3BCLE9BQU9DLE9BQU87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LFNBQVMsR0FBRyxFQUFFO1lBRW5Ca0IsZUFBZUUsT0FBTyxDQUFDQyxDQUFBQTtnQkFDckIsSUFBSUEsT0FBTyxDQUFDLEVBQUUsRUFBRTtvQkFDZDtnQkFDRjtnQkFFQSxJQUFJLElBQUksQ0FBQ3RCLE1BQU0sS0FBS3BCLE9BQU9FLFFBQVEsRUFBRTtvQkFDbkMsbUVBQW1FO29CQUNuRXdDLE9BQU8sQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDSixNQUFNO2dCQUN4QjtnQkFFQSxJQUFJLElBQUksQ0FBQ2xCLE1BQU0sS0FBS3BCLE9BQU9HLFFBQVEsRUFBRTtvQkFDbkN1QyxPQUFPLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQ0osTUFBTTtnQkFDeEI7Z0JBRUFJLE9BQU8sQ0FBQyxFQUFFLEdBQUc7WUFDZjtRQUNGO0lBQUU7QUFDSjtBQUVpRSxDQUNqRSx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vYnJhbGluay13ZWIvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS91dGlscy9lc20vc3luY3Byb21pc2UuanM/ZTgwMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc1RoZW5hYmxlIH0gZnJvbSAnLi9pcy5qcyc7XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1mdW5jdGlvbi1yZXR1cm4tdHlwZSAqL1xuXG4vKiogU3luY1Byb21pc2UgaW50ZXJuYWwgc3RhdGVzICovXG52YXIgU3RhdGVzOyAoZnVuY3Rpb24gKFN0YXRlcykge1xuICAvKiogUGVuZGluZyAqL1xuICBjb25zdCBQRU5ESU5HID0gMDsgU3RhdGVzW1N0YXRlc1tcIlBFTkRJTkdcIl0gPSBQRU5ESU5HXSA9IFwiUEVORElOR1wiO1xuICAvKiogUmVzb2x2ZWQgLyBPSyAqL1xuICBjb25zdCBSRVNPTFZFRCA9IDE7IFN0YXRlc1tTdGF0ZXNbXCJSRVNPTFZFRFwiXSA9IFJFU09MVkVEXSA9IFwiUkVTT0xWRURcIjtcbiAgLyoqIFJlamVjdGVkIC8gRXJyb3IgKi9cbiAgY29uc3QgUkVKRUNURUQgPSAyOyBTdGF0ZXNbU3RhdGVzW1wiUkVKRUNURURcIl0gPSBSRUpFQ1RFRF0gPSBcIlJFSkVDVEVEXCI7XG59KShTdGF0ZXMgfHwgKFN0YXRlcyA9IHt9KSk7XG5cbi8vIE92ZXJsb2FkcyBzbyB3ZSBjYW4gY2FsbCByZXNvbHZlZFN5bmNQcm9taXNlIHdpdGhvdXQgYXJndW1lbnRzIGFuZCBnZW5lcmljIGFyZ3VtZW50XG5cbi8qKlxuICogQ3JlYXRlcyBhIHJlc29sdmVkIHN5bmMgcHJvbWlzZS5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgdGhlIHZhbHVlIHRvIHJlc29sdmUgdGhlIHByb21pc2Ugd2l0aFxuICogQHJldHVybnMgdGhlIHJlc29sdmVkIHN5bmMgcHJvbWlzZVxuICovXG5mdW5jdGlvbiByZXNvbHZlZFN5bmNQcm9taXNlKHZhbHVlKSB7XG4gIHJldHVybiBuZXcgU3luY1Byb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSByZWplY3RlZCBzeW5jIHByb21pc2UuXG4gKlxuICogQHBhcmFtIHZhbHVlIHRoZSB2YWx1ZSB0byByZWplY3QgdGhlIHByb21pc2Ugd2l0aFxuICogQHJldHVybnMgdGhlIHJlamVjdGVkIHN5bmMgcHJvbWlzZVxuICovXG5mdW5jdGlvbiByZWplY3RlZFN5bmNQcm9taXNlKHJlYXNvbikge1xuICByZXR1cm4gbmV3IFN5bmNQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICByZWplY3QocmVhc29uKTtcbiAgfSk7XG59XG5cbi8qKlxuICogVGhlbmFibGUgY2xhc3MgdGhhdCBiZWhhdmVzIGxpa2UgYSBQcm9taXNlIGFuZCBmb2xsb3dzIGl0J3MgaW50ZXJmYWNlXG4gKiBidXQgaXMgbm90IGFzeW5jIGludGVybmFsbHlcbiAqL1xuY2xhc3MgU3luY1Byb21pc2Uge1xuXG4gICBjb25zdHJ1Y3RvcihcbiAgICBleGVjdXRvcixcbiAgKSB7U3luY1Byb21pc2UucHJvdG90eXBlLl9faW5pdC5jYWxsKHRoaXMpO1N5bmNQcm9taXNlLnByb3RvdHlwZS5fX2luaXQyLmNhbGwodGhpcyk7U3luY1Byb21pc2UucHJvdG90eXBlLl9faW5pdDMuY2FsbCh0aGlzKTtTeW5jUHJvbWlzZS5wcm90b3R5cGUuX19pbml0NC5jYWxsKHRoaXMpO1xuICAgIHRoaXMuX3N0YXRlID0gU3RhdGVzLlBFTkRJTkc7XG4gICAgdGhpcy5faGFuZGxlcnMgPSBbXTtcblxuICAgIHRyeSB7XG4gICAgICBleGVjdXRvcih0aGlzLl9yZXNvbHZlLCB0aGlzLl9yZWplY3QpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMuX3JlamVjdChlKTtcbiAgICB9XG4gIH1cblxuICAvKiogSlNEb2MgKi9cbiAgIHRoZW4oXG4gICAgb25mdWxmaWxsZWQsXG4gICAgb25yZWplY3RlZCxcbiAgKSB7XG4gICAgcmV0dXJuIG5ldyBTeW5jUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLl9oYW5kbGVycy5wdXNoKFtcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHJlc3VsdCA9PiB7XG4gICAgICAgICAgaWYgKCFvbmZ1bGZpbGxlZCkge1xuICAgICAgICAgICAgLy8gVE9ETzogwq9cXF8o44OEKV8vwq9cbiAgICAgICAgICAgIC8vIFRPRE86IEZJWE1FXG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXNvbHZlKG9uZnVsZmlsbGVkKHJlc3VsdCkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZWFzb24gPT4ge1xuICAgICAgICAgIGlmICghb25yZWplY3RlZCkge1xuICAgICAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJlc29sdmUob25yZWplY3RlZChyZWFzb24pKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgIF0pO1xuICAgICAgdGhpcy5fZXhlY3V0ZUhhbmRsZXJzKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKiogSlNEb2MgKi9cbiAgIGNhdGNoKFxuICAgIG9ucmVqZWN0ZWQsXG4gICkge1xuICAgIHJldHVybiB0aGlzLnRoZW4odmFsID0+IHZhbCwgb25yZWplY3RlZCk7XG4gIH1cblxuICAvKiogSlNEb2MgKi9cbiAgIGZpbmFsbHkob25maW5hbGx5KSB7XG4gICAgcmV0dXJuIG5ldyBTeW5jUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsZXQgdmFsO1xuICAgICAgbGV0IGlzUmVqZWN0ZWQ7XG5cbiAgICAgIHJldHVybiB0aGlzLnRoZW4oXG4gICAgICAgIHZhbHVlID0+IHtcbiAgICAgICAgICBpc1JlamVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgdmFsID0gdmFsdWU7XG4gICAgICAgICAgaWYgKG9uZmluYWxseSkge1xuICAgICAgICAgICAgb25maW5hbGx5KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZWFzb24gPT4ge1xuICAgICAgICAgIGlzUmVqZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgIHZhbCA9IHJlYXNvbjtcbiAgICAgICAgICBpZiAob25maW5hbGx5KSB7XG4gICAgICAgICAgICBvbmZpbmFsbHkoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICApLnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAoaXNSZWplY3RlZCkge1xuICAgICAgICAgIHJlamVjdCh2YWwpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc29sdmUodmFsICk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBKU0RvYyAqL1xuICAgIF9faW5pdCgpIHt0aGlzLl9yZXNvbHZlID0gKHZhbHVlKSA9PiB7XG4gICAgdGhpcy5fc2V0UmVzdWx0KFN0YXRlcy5SRVNPTFZFRCwgdmFsdWUpO1xuICB9O31cblxuICAvKiogSlNEb2MgKi9cbiAgICBfX2luaXQyKCkge3RoaXMuX3JlamVjdCA9IChyZWFzb24pID0+IHtcbiAgICB0aGlzLl9zZXRSZXN1bHQoU3RhdGVzLlJFSkVDVEVELCByZWFzb24pO1xuICB9O31cblxuICAvKiogSlNEb2MgKi9cbiAgICBfX2luaXQzKCkge3RoaXMuX3NldFJlc3VsdCA9IChzdGF0ZSwgdmFsdWUpID0+IHtcbiAgICBpZiAodGhpcy5fc3RhdGUgIT09IFN0YXRlcy5QRU5ESU5HKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzVGhlbmFibGUodmFsdWUpKSB7XG4gICAgICB2b2lkICh2YWx1ZSApLnRoZW4odGhpcy5fcmVzb2x2ZSwgdGhpcy5fcmVqZWN0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xuICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG5cbiAgICB0aGlzLl9leGVjdXRlSGFuZGxlcnMoKTtcbiAgfTt9XG5cbiAgLyoqIEpTRG9jICovXG4gICAgX19pbml0NCgpIHt0aGlzLl9leGVjdXRlSGFuZGxlcnMgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMuX3N0YXRlID09PSBTdGF0ZXMuUEVORElORykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNhY2hlZEhhbmRsZXJzID0gdGhpcy5faGFuZGxlcnMuc2xpY2UoKTtcbiAgICB0aGlzLl9oYW5kbGVycyA9IFtdO1xuXG4gICAgY2FjaGVkSGFuZGxlcnMuZm9yRWFjaChoYW5kbGVyID0+IHtcbiAgICAgIGlmIChoYW5kbGVyWzBdKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSBTdGF0ZXMuUkVTT0xWRUQpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xuICAgICAgICBoYW5kbGVyWzFdKHRoaXMuX3ZhbHVlICk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gU3RhdGVzLlJFSkVDVEVEKSB7XG4gICAgICAgIGhhbmRsZXJbMl0odGhpcy5fdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBoYW5kbGVyWzBdID0gdHJ1ZTtcbiAgICB9KTtcbiAgfTt9XG59XG5cbmV4cG9ydCB7IFN5bmNQcm9taXNlLCByZWplY3RlZFN5bmNQcm9taXNlLCByZXNvbHZlZFN5bmNQcm9taXNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zeW5jcHJvbWlzZS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJpc1RoZW5hYmxlIiwiU3RhdGVzIiwiUEVORElORyIsIlJFU09MVkVEIiwiUkVKRUNURUQiLCJyZXNvbHZlZFN5bmNQcm9taXNlIiwidmFsdWUiLCJTeW5jUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3RlZFN5bmNQcm9taXNlIiwicmVhc29uIiwiXyIsInJlamVjdCIsImNvbnN0cnVjdG9yIiwiZXhlY3V0b3IiLCJwcm90b3R5cGUiLCJfX2luaXQiLCJjYWxsIiwiX19pbml0MiIsIl9faW5pdDMiLCJfX2luaXQ0IiwiX3N0YXRlIiwiX2hhbmRsZXJzIiwiX3Jlc29sdmUiLCJfcmVqZWN0IiwiZSIsInRoZW4iLCJvbmZ1bGZpbGxlZCIsIm9ucmVqZWN0ZWQiLCJwdXNoIiwicmVzdWx0IiwiX2V4ZWN1dGVIYW5kbGVycyIsImNhdGNoIiwidmFsIiwiZmluYWxseSIsIm9uZmluYWxseSIsImlzUmVqZWN0ZWQiLCJfc2V0UmVzdWx0Iiwic3RhdGUiLCJfdmFsdWUiLCJjYWNoZWRIYW5kbGVycyIsInNsaWNlIiwiZm9yRWFjaCIsImhhbmRsZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/utils/esm/syncpromise.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sentry/utils/esm/time.js":
/*!************************************************!*\
  !*** ./node_modules/@sentry/utils/esm/time.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _browserPerformanceTimeOriginMode: () => (/* binding */ _browserPerformanceTimeOriginMode),\n/* harmony export */   browserPerformanceTimeOrigin: () => (/* binding */ browserPerformanceTimeOrigin),\n/* harmony export */   dateTimestampInSeconds: () => (/* binding */ dateTimestampInSeconds),\n/* harmony export */   timestampInSeconds: () => (/* binding */ timestampInSeconds),\n/* harmony export */   timestampWithMs: () => (/* binding */ timestampWithMs)\n/* harmony export */ });\n/* harmony import */ var _worldwide_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./worldwide.js */ \"(ssr)/./node_modules/@sentry/utils/esm/worldwide.js\");\n\nconst ONE_SECOND_IN_MS = 1000;\n/**\n * A partial definition of the [Performance Web API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Performance}\n * for accessing a high-resolution monotonic clock.\n */ /**\n * Returns a timestamp in seconds since the UNIX epoch using the Date API.\n *\n * TODO(v8): Return type should be rounded.\n */ function dateTimestampInSeconds() {\n    return Date.now() / ONE_SECOND_IN_MS;\n}\n/**\n * Returns a wrapper around the native Performance API browser implementation, or undefined for browsers that do not\n * support the API.\n *\n * Wrapping the native API works around differences in behavior from different browsers.\n */ function createUnixTimestampInSecondsFunc() {\n    const { performance } = _worldwide_js__WEBPACK_IMPORTED_MODULE_0__.GLOBAL_OBJ;\n    if (!performance || !performance.now) {\n        return dateTimestampInSeconds;\n    }\n    // Some browser and environments don't have a timeOrigin, so we fallback to\n    // using Date.now() to compute the starting time.\n    const approxStartingTimeOrigin = Date.now() - performance.now();\n    const timeOrigin = performance.timeOrigin == undefined ? approxStartingTimeOrigin : performance.timeOrigin;\n    // performance.now() is a monotonic clock, which means it starts at 0 when the process begins. To get the current\n    // wall clock time (actual UNIX timestamp), we need to add the starting time origin and the current time elapsed.\n    //\n    // TODO: This does not account for the case where the monotonic clock that powers performance.now() drifts from the\n    // wall clock time, which causes the returned timestamp to be inaccurate. We should investigate how to detect and\n    // correct for this.\n    // See: https://github.com/getsentry/sentry-javascript/issues/2590\n    // See: https://github.com/mdn/content/issues/4713\n    // See: https://dev.to/noamr/when-a-millisecond-is-not-a-millisecond-3h6\n    return ()=>{\n        return (timeOrigin + performance.now()) / ONE_SECOND_IN_MS;\n    };\n}\n/**\n * Returns a timestamp in seconds since the UNIX epoch using either the Performance or Date APIs, depending on the\n * availability of the Performance API.\n *\n * BUG: Note that because of how browsers implement the Performance API, the clock might stop when the computer is\n * asleep. This creates a skew between `dateTimestampInSeconds` and `timestampInSeconds`. The\n * skew can grow to arbitrary amounts like days, weeks or months.\n * See https://github.com/getsentry/sentry-javascript/issues/2590.\n */ const timestampInSeconds = createUnixTimestampInSecondsFunc();\n/**\n * Re-exported with an old name for backwards-compatibility.\n * TODO (v8): Remove this\n *\n * @deprecated Use `timestampInSeconds` instead.\n */ const timestampWithMs = timestampInSeconds;\n/**\n * Internal helper to store what is the source of browserPerformanceTimeOrigin below. For debugging only.\n */ let _browserPerformanceTimeOriginMode;\n/**\n * The number of milliseconds since the UNIX epoch. This value is only usable in a browser, and only when the\n * performance API is available.\n */ const browserPerformanceTimeOrigin = (()=>{\n    // Unfortunately browsers may report an inaccurate time origin data, through either performance.timeOrigin or\n    // performance.timing.navigationStart, which results in poor results in performance data. We only treat time origin\n    // data as reliable if they are within a reasonable threshold of the current time.\n    const { performance } = _worldwide_js__WEBPACK_IMPORTED_MODULE_0__.GLOBAL_OBJ;\n    if (!performance || !performance.now) {\n        _browserPerformanceTimeOriginMode = \"none\";\n        return undefined;\n    }\n    const threshold = 3600 * 1000;\n    const performanceNow = performance.now();\n    const dateNow = Date.now();\n    // if timeOrigin isn't available set delta to threshold so it isn't used\n    const timeOriginDelta = performance.timeOrigin ? Math.abs(performance.timeOrigin + performanceNow - dateNow) : threshold;\n    const timeOriginIsReliable = timeOriginDelta < threshold;\n    // While performance.timing.navigationStart is deprecated in favor of performance.timeOrigin, performance.timeOrigin\n    // is not as widely supported. Namely, performance.timeOrigin is undefined in Safari as of writing.\n    // Also as of writing, performance.timing is not available in Web Workers in mainstream browsers, so it is not always\n    // a valid fallback. In the absence of an initial time provided by the browser, fallback to the current time from the\n    // Date API.\n    // eslint-disable-next-line deprecation/deprecation\n    const navigationStart = performance.timing && performance.timing.navigationStart;\n    const hasNavigationStart = typeof navigationStart === \"number\";\n    // if navigationStart isn't available set delta to threshold so it isn't used\n    const navigationStartDelta = hasNavigationStart ? Math.abs(navigationStart + performanceNow - dateNow) : threshold;\n    const navigationStartIsReliable = navigationStartDelta < threshold;\n    if (timeOriginIsReliable || navigationStartIsReliable) {\n        // Use the more reliable time origin\n        if (timeOriginDelta <= navigationStartDelta) {\n            _browserPerformanceTimeOriginMode = \"timeOrigin\";\n            return performance.timeOrigin;\n        } else {\n            _browserPerformanceTimeOriginMode = \"navigationStart\";\n            return navigationStart;\n        }\n    }\n    // Either both timeOrigin and navigationStart are skewed or neither is available, fallback to Date.\n    _browserPerformanceTimeOriginMode = \"dateNow\";\n    return dateNow;\n})();\n //# sourceMappingURL=time.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS91dGlscy9lc20vdGltZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBNEM7QUFFNUMsTUFBTUMsbUJBQW1CO0FBRXpCOzs7Q0FHQyxHQUVEOzs7O0NBSUMsR0FDRCxTQUFTQztJQUNQLE9BQU9DLEtBQUtDLEdBQUcsS0FBS0g7QUFDdEI7QUFFQTs7Ozs7Q0FLQyxHQUNELFNBQVNJO0lBQ1AsTUFBTSxFQUFFQyxXQUFXLEVBQUUsR0FBR04scURBQVVBO0lBQ2xDLElBQUksQ0FBQ00sZUFBZSxDQUFDQSxZQUFZRixHQUFHLEVBQUU7UUFDcEMsT0FBT0Y7SUFDVDtJQUVBLDJFQUEyRTtJQUMzRSxpREFBaUQ7SUFDakQsTUFBTUssMkJBQTJCSixLQUFLQyxHQUFHLEtBQUtFLFlBQVlGLEdBQUc7SUFDN0QsTUFBTUksYUFBYUYsWUFBWUUsVUFBVSxJQUFJQyxZQUFZRiwyQkFBMkJELFlBQVlFLFVBQVU7SUFFMUcsaUhBQWlIO0lBQ2pILGlIQUFpSDtJQUNqSCxFQUFFO0lBQ0YsbUhBQW1IO0lBQ25ILGlIQUFpSDtJQUNqSCxvQkFBb0I7SUFDcEIsa0VBQWtFO0lBQ2xFLGtEQUFrRDtJQUNsRCx3RUFBd0U7SUFDeEUsT0FBTztRQUNMLE9BQU8sQ0FBQ0EsYUFBYUYsWUFBWUYsR0FBRyxFQUFDLElBQUtIO0lBQzVDO0FBQ0Y7QUFFQTs7Ozs7Ozs7Q0FRQyxHQUNELE1BQU1TLHFCQUFxQkw7QUFFM0I7Ozs7O0NBS0MsR0FDRCxNQUFNTSxrQkFBa0JEO0FBRXhCOztDQUVDLEdBQ0QsSUFBSUU7QUFFSjs7O0NBR0MsR0FDRCxNQUFNQywrQkFBK0IsQ0FBQztJQUNwQyw2R0FBNkc7SUFDN0csbUhBQW1IO0lBQ25ILGtGQUFrRjtJQUVsRixNQUFNLEVBQUVQLFdBQVcsRUFBRSxHQUFHTixxREFBVUE7SUFDbEMsSUFBSSxDQUFDTSxlQUFlLENBQUNBLFlBQVlGLEdBQUcsRUFBRTtRQUNwQ1Esb0NBQW9DO1FBQ3BDLE9BQU9IO0lBQ1Q7SUFFQSxNQUFNSyxZQUFZLE9BQU87SUFDekIsTUFBTUMsaUJBQWlCVCxZQUFZRixHQUFHO0lBQ3RDLE1BQU1ZLFVBQVViLEtBQUtDLEdBQUc7SUFFeEIsd0VBQXdFO0lBQ3hFLE1BQU1hLGtCQUFrQlgsWUFBWUUsVUFBVSxHQUMxQ1UsS0FBS0MsR0FBRyxDQUFDYixZQUFZRSxVQUFVLEdBQUdPLGlCQUFpQkMsV0FDbkRGO0lBQ0osTUFBTU0sdUJBQXVCSCxrQkFBa0JIO0lBRS9DLG9IQUFvSDtJQUNwSCxtR0FBbUc7SUFDbkcscUhBQXFIO0lBQ3JILHFIQUFxSDtJQUNySCxZQUFZO0lBQ1osbURBQW1EO0lBQ25ELE1BQU1PLGtCQUFrQmYsWUFBWWdCLE1BQU0sSUFBSWhCLFlBQVlnQixNQUFNLENBQUNELGVBQWU7SUFDaEYsTUFBTUUscUJBQXFCLE9BQU9GLG9CQUFvQjtJQUN0RCw2RUFBNkU7SUFDN0UsTUFBTUcsdUJBQXVCRCxxQkFBcUJMLEtBQUtDLEdBQUcsQ0FBQ0Usa0JBQWtCTixpQkFBaUJDLFdBQVdGO0lBQ3pHLE1BQU1XLDRCQUE0QkQsdUJBQXVCVjtJQUV6RCxJQUFJTSx3QkFBd0JLLDJCQUEyQjtRQUNyRCxvQ0FBb0M7UUFDcEMsSUFBSVIsbUJBQW1CTyxzQkFBc0I7WUFDM0NaLG9DQUFvQztZQUNwQyxPQUFPTixZQUFZRSxVQUFVO1FBQy9CLE9BQU87WUFDTEksb0NBQW9DO1lBQ3BDLE9BQU9TO1FBQ1Q7SUFDRjtJQUVBLG1HQUFtRztJQUNuR1Qsb0NBQW9DO0lBQ3BDLE9BQU9JO0FBQ1Q7QUFFd0ksQ0FDeEksZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb2JyYWxpbmstd2ViLy4vbm9kZV9tb2R1bGVzL0BzZW50cnkvdXRpbHMvZXNtL3RpbWUuanM/N2UyZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBHTE9CQUxfT0JKIH0gZnJvbSAnLi93b3JsZHdpZGUuanMnO1xuXG5jb25zdCBPTkVfU0VDT05EX0lOX01TID0gMTAwMDtcblxuLyoqXG4gKiBBIHBhcnRpYWwgZGVmaW5pdGlvbiBvZiB0aGUgW1BlcmZvcm1hbmNlIFdlYiBBUElde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9QZXJmb3JtYW5jZX1cbiAqIGZvciBhY2Nlc3NpbmcgYSBoaWdoLXJlc29sdXRpb24gbW9ub3RvbmljIGNsb2NrLlxuICovXG5cbi8qKlxuICogUmV0dXJucyBhIHRpbWVzdGFtcCBpbiBzZWNvbmRzIHNpbmNlIHRoZSBVTklYIGVwb2NoIHVzaW5nIHRoZSBEYXRlIEFQSS5cbiAqXG4gKiBUT0RPKHY4KTogUmV0dXJuIHR5cGUgc2hvdWxkIGJlIHJvdW5kZWQuXG4gKi9cbmZ1bmN0aW9uIGRhdGVUaW1lc3RhbXBJblNlY29uZHMoKSB7XG4gIHJldHVybiBEYXRlLm5vdygpIC8gT05FX1NFQ09ORF9JTl9NUztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgd3JhcHBlciBhcm91bmQgdGhlIG5hdGl2ZSBQZXJmb3JtYW5jZSBBUEkgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiwgb3IgdW5kZWZpbmVkIGZvciBicm93c2VycyB0aGF0IGRvIG5vdFxuICogc3VwcG9ydCB0aGUgQVBJLlxuICpcbiAqIFdyYXBwaW5nIHRoZSBuYXRpdmUgQVBJIHdvcmtzIGFyb3VuZCBkaWZmZXJlbmNlcyBpbiBiZWhhdmlvciBmcm9tIGRpZmZlcmVudCBicm93c2Vycy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVW5peFRpbWVzdGFtcEluU2Vjb25kc0Z1bmMoKSB7XG4gIGNvbnN0IHsgcGVyZm9ybWFuY2UgfSA9IEdMT0JBTF9PQkogO1xuICBpZiAoIXBlcmZvcm1hbmNlIHx8ICFwZXJmb3JtYW5jZS5ub3cpIHtcbiAgICByZXR1cm4gZGF0ZVRpbWVzdGFtcEluU2Vjb25kcztcbiAgfVxuXG4gIC8vIFNvbWUgYnJvd3NlciBhbmQgZW52aXJvbm1lbnRzIGRvbid0IGhhdmUgYSB0aW1lT3JpZ2luLCBzbyB3ZSBmYWxsYmFjayB0b1xuICAvLyB1c2luZyBEYXRlLm5vdygpIHRvIGNvbXB1dGUgdGhlIHN0YXJ0aW5nIHRpbWUuXG4gIGNvbnN0IGFwcHJveFN0YXJ0aW5nVGltZU9yaWdpbiA9IERhdGUubm93KCkgLSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgY29uc3QgdGltZU9yaWdpbiA9IHBlcmZvcm1hbmNlLnRpbWVPcmlnaW4gPT0gdW5kZWZpbmVkID8gYXBwcm94U3RhcnRpbmdUaW1lT3JpZ2luIDogcGVyZm9ybWFuY2UudGltZU9yaWdpbjtcblxuICAvLyBwZXJmb3JtYW5jZS5ub3coKSBpcyBhIG1vbm90b25pYyBjbG9jaywgd2hpY2ggbWVhbnMgaXQgc3RhcnRzIGF0IDAgd2hlbiB0aGUgcHJvY2VzcyBiZWdpbnMuIFRvIGdldCB0aGUgY3VycmVudFxuICAvLyB3YWxsIGNsb2NrIHRpbWUgKGFjdHVhbCBVTklYIHRpbWVzdGFtcCksIHdlIG5lZWQgdG8gYWRkIHRoZSBzdGFydGluZyB0aW1lIG9yaWdpbiBhbmQgdGhlIGN1cnJlbnQgdGltZSBlbGFwc2VkLlxuICAvL1xuICAvLyBUT0RPOiBUaGlzIGRvZXMgbm90IGFjY291bnQgZm9yIHRoZSBjYXNlIHdoZXJlIHRoZSBtb25vdG9uaWMgY2xvY2sgdGhhdCBwb3dlcnMgcGVyZm9ybWFuY2Uubm93KCkgZHJpZnRzIGZyb20gdGhlXG4gIC8vIHdhbGwgY2xvY2sgdGltZSwgd2hpY2ggY2F1c2VzIHRoZSByZXR1cm5lZCB0aW1lc3RhbXAgdG8gYmUgaW5hY2N1cmF0ZS4gV2Ugc2hvdWxkIGludmVzdGlnYXRlIGhvdyB0byBkZXRlY3QgYW5kXG4gIC8vIGNvcnJlY3QgZm9yIHRoaXMuXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2dldHNlbnRyeS9zZW50cnktamF2YXNjcmlwdC9pc3N1ZXMvMjU5MFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9tZG4vY29udGVudC9pc3N1ZXMvNDcxM1xuICAvLyBTZWU6IGh0dHBzOi8vZGV2LnRvL25vYW1yL3doZW4tYS1taWxsaXNlY29uZC1pcy1ub3QtYS1taWxsaXNlY29uZC0zaDZcbiAgcmV0dXJuICgpID0+IHtcbiAgICByZXR1cm4gKHRpbWVPcmlnaW4gKyBwZXJmb3JtYW5jZS5ub3coKSkgLyBPTkVfU0VDT05EX0lOX01TO1xuICB9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSB0aW1lc3RhbXAgaW4gc2Vjb25kcyBzaW5jZSB0aGUgVU5JWCBlcG9jaCB1c2luZyBlaXRoZXIgdGhlIFBlcmZvcm1hbmNlIG9yIERhdGUgQVBJcywgZGVwZW5kaW5nIG9uIHRoZVxuICogYXZhaWxhYmlsaXR5IG9mIHRoZSBQZXJmb3JtYW5jZSBBUEkuXG4gKlxuICogQlVHOiBOb3RlIHRoYXQgYmVjYXVzZSBvZiBob3cgYnJvd3NlcnMgaW1wbGVtZW50IHRoZSBQZXJmb3JtYW5jZSBBUEksIHRoZSBjbG9jayBtaWdodCBzdG9wIHdoZW4gdGhlIGNvbXB1dGVyIGlzXG4gKiBhc2xlZXAuIFRoaXMgY3JlYXRlcyBhIHNrZXcgYmV0d2VlbiBgZGF0ZVRpbWVzdGFtcEluU2Vjb25kc2AgYW5kIGB0aW1lc3RhbXBJblNlY29uZHNgLiBUaGVcbiAqIHNrZXcgY2FuIGdyb3cgdG8gYXJiaXRyYXJ5IGFtb3VudHMgbGlrZSBkYXlzLCB3ZWVrcyBvciBtb250aHMuXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2dldHNlbnRyeS9zZW50cnktamF2YXNjcmlwdC9pc3N1ZXMvMjU5MC5cbiAqL1xuY29uc3QgdGltZXN0YW1wSW5TZWNvbmRzID0gY3JlYXRlVW5peFRpbWVzdGFtcEluU2Vjb25kc0Z1bmMoKTtcblxuLyoqXG4gKiBSZS1leHBvcnRlZCB3aXRoIGFuIG9sZCBuYW1lIGZvciBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eS5cbiAqIFRPRE8gKHY4KTogUmVtb3ZlIHRoaXNcbiAqXG4gKiBAZGVwcmVjYXRlZCBVc2UgYHRpbWVzdGFtcEluU2Vjb25kc2AgaW5zdGVhZC5cbiAqL1xuY29uc3QgdGltZXN0YW1wV2l0aE1zID0gdGltZXN0YW1wSW5TZWNvbmRzO1xuXG4vKipcbiAqIEludGVybmFsIGhlbHBlciB0byBzdG9yZSB3aGF0IGlzIHRoZSBzb3VyY2Ugb2YgYnJvd3NlclBlcmZvcm1hbmNlVGltZU9yaWdpbiBiZWxvdy4gRm9yIGRlYnVnZ2luZyBvbmx5LlxuICovXG5sZXQgX2Jyb3dzZXJQZXJmb3JtYW5jZVRpbWVPcmlnaW5Nb2RlO1xuXG4vKipcbiAqIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIHRoZSBVTklYIGVwb2NoLiBUaGlzIHZhbHVlIGlzIG9ubHkgdXNhYmxlIGluIGEgYnJvd3NlciwgYW5kIG9ubHkgd2hlbiB0aGVcbiAqIHBlcmZvcm1hbmNlIEFQSSBpcyBhdmFpbGFibGUuXG4gKi9cbmNvbnN0IGJyb3dzZXJQZXJmb3JtYW5jZVRpbWVPcmlnaW4gPSAoKCkgPT4ge1xuICAvLyBVbmZvcnR1bmF0ZWx5IGJyb3dzZXJzIG1heSByZXBvcnQgYW4gaW5hY2N1cmF0ZSB0aW1lIG9yaWdpbiBkYXRhLCB0aHJvdWdoIGVpdGhlciBwZXJmb3JtYW5jZS50aW1lT3JpZ2luIG9yXG4gIC8vIHBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQsIHdoaWNoIHJlc3VsdHMgaW4gcG9vciByZXN1bHRzIGluIHBlcmZvcm1hbmNlIGRhdGEuIFdlIG9ubHkgdHJlYXQgdGltZSBvcmlnaW5cbiAgLy8gZGF0YSBhcyByZWxpYWJsZSBpZiB0aGV5IGFyZSB3aXRoaW4gYSByZWFzb25hYmxlIHRocmVzaG9sZCBvZiB0aGUgY3VycmVudCB0aW1lLlxuXG4gIGNvbnN0IHsgcGVyZm9ybWFuY2UgfSA9IEdMT0JBTF9PQkogO1xuICBpZiAoIXBlcmZvcm1hbmNlIHx8ICFwZXJmb3JtYW5jZS5ub3cpIHtcbiAgICBfYnJvd3NlclBlcmZvcm1hbmNlVGltZU9yaWdpbk1vZGUgPSAnbm9uZSc7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGNvbnN0IHRocmVzaG9sZCA9IDM2MDAgKiAxMDAwO1xuICBjb25zdCBwZXJmb3JtYW5jZU5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICBjb25zdCBkYXRlTm93ID0gRGF0ZS5ub3coKTtcblxuICAvLyBpZiB0aW1lT3JpZ2luIGlzbid0IGF2YWlsYWJsZSBzZXQgZGVsdGEgdG8gdGhyZXNob2xkIHNvIGl0IGlzbid0IHVzZWRcbiAgY29uc3QgdGltZU9yaWdpbkRlbHRhID0gcGVyZm9ybWFuY2UudGltZU9yaWdpblxuICAgID8gTWF0aC5hYnMocGVyZm9ybWFuY2UudGltZU9yaWdpbiArIHBlcmZvcm1hbmNlTm93IC0gZGF0ZU5vdylcbiAgICA6IHRocmVzaG9sZDtcbiAgY29uc3QgdGltZU9yaWdpbklzUmVsaWFibGUgPSB0aW1lT3JpZ2luRGVsdGEgPCB0aHJlc2hvbGQ7XG5cbiAgLy8gV2hpbGUgcGVyZm9ybWFuY2UudGltaW5nLm5hdmlnYXRpb25TdGFydCBpcyBkZXByZWNhdGVkIGluIGZhdm9yIG9mIHBlcmZvcm1hbmNlLnRpbWVPcmlnaW4sIHBlcmZvcm1hbmNlLnRpbWVPcmlnaW5cbiAgLy8gaXMgbm90IGFzIHdpZGVseSBzdXBwb3J0ZWQuIE5hbWVseSwgcGVyZm9ybWFuY2UudGltZU9yaWdpbiBpcyB1bmRlZmluZWQgaW4gU2FmYXJpIGFzIG9mIHdyaXRpbmcuXG4gIC8vIEFsc28gYXMgb2Ygd3JpdGluZywgcGVyZm9ybWFuY2UudGltaW5nIGlzIG5vdCBhdmFpbGFibGUgaW4gV2ViIFdvcmtlcnMgaW4gbWFpbnN0cmVhbSBicm93c2Vycywgc28gaXQgaXMgbm90IGFsd2F5c1xuICAvLyBhIHZhbGlkIGZhbGxiYWNrLiBJbiB0aGUgYWJzZW5jZSBvZiBhbiBpbml0aWFsIHRpbWUgcHJvdmlkZWQgYnkgdGhlIGJyb3dzZXIsIGZhbGxiYWNrIHRvIHRoZSBjdXJyZW50IHRpbWUgZnJvbSB0aGVcbiAgLy8gRGF0ZSBBUEkuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICBjb25zdCBuYXZpZ2F0aW9uU3RhcnQgPSBwZXJmb3JtYW5jZS50aW1pbmcgJiYgcGVyZm9ybWFuY2UudGltaW5nLm5hdmlnYXRpb25TdGFydDtcbiAgY29uc3QgaGFzTmF2aWdhdGlvblN0YXJ0ID0gdHlwZW9mIG5hdmlnYXRpb25TdGFydCA9PT0gJ251bWJlcic7XG4gIC8vIGlmIG5hdmlnYXRpb25TdGFydCBpc24ndCBhdmFpbGFibGUgc2V0IGRlbHRhIHRvIHRocmVzaG9sZCBzbyBpdCBpc24ndCB1c2VkXG4gIGNvbnN0IG5hdmlnYXRpb25TdGFydERlbHRhID0gaGFzTmF2aWdhdGlvblN0YXJ0ID8gTWF0aC5hYnMobmF2aWdhdGlvblN0YXJ0ICsgcGVyZm9ybWFuY2VOb3cgLSBkYXRlTm93KSA6IHRocmVzaG9sZDtcbiAgY29uc3QgbmF2aWdhdGlvblN0YXJ0SXNSZWxpYWJsZSA9IG5hdmlnYXRpb25TdGFydERlbHRhIDwgdGhyZXNob2xkO1xuXG4gIGlmICh0aW1lT3JpZ2luSXNSZWxpYWJsZSB8fCBuYXZpZ2F0aW9uU3RhcnRJc1JlbGlhYmxlKSB7XG4gICAgLy8gVXNlIHRoZSBtb3JlIHJlbGlhYmxlIHRpbWUgb3JpZ2luXG4gICAgaWYgKHRpbWVPcmlnaW5EZWx0YSA8PSBuYXZpZ2F0aW9uU3RhcnREZWx0YSkge1xuICAgICAgX2Jyb3dzZXJQZXJmb3JtYW5jZVRpbWVPcmlnaW5Nb2RlID0gJ3RpbWVPcmlnaW4nO1xuICAgICAgcmV0dXJuIHBlcmZvcm1hbmNlLnRpbWVPcmlnaW47XG4gICAgfSBlbHNlIHtcbiAgICAgIF9icm93c2VyUGVyZm9ybWFuY2VUaW1lT3JpZ2luTW9kZSA9ICduYXZpZ2F0aW9uU3RhcnQnO1xuICAgICAgcmV0dXJuIG5hdmlnYXRpb25TdGFydDtcbiAgICB9XG4gIH1cblxuICAvLyBFaXRoZXIgYm90aCB0aW1lT3JpZ2luIGFuZCBuYXZpZ2F0aW9uU3RhcnQgYXJlIHNrZXdlZCBvciBuZWl0aGVyIGlzIGF2YWlsYWJsZSwgZmFsbGJhY2sgdG8gRGF0ZS5cbiAgX2Jyb3dzZXJQZXJmb3JtYW5jZVRpbWVPcmlnaW5Nb2RlID0gJ2RhdGVOb3cnO1xuICByZXR1cm4gZGF0ZU5vdztcbn0pKCk7XG5cbmV4cG9ydCB7IF9icm93c2VyUGVyZm9ybWFuY2VUaW1lT3JpZ2luTW9kZSwgYnJvd3NlclBlcmZvcm1hbmNlVGltZU9yaWdpbiwgZGF0ZVRpbWVzdGFtcEluU2Vjb25kcywgdGltZXN0YW1wSW5TZWNvbmRzLCB0aW1lc3RhbXBXaXRoTXMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpbWUuanMubWFwXG4iXSwibmFtZXMiOlsiR0xPQkFMX09CSiIsIk9ORV9TRUNPTkRfSU5fTVMiLCJkYXRlVGltZXN0YW1wSW5TZWNvbmRzIiwiRGF0ZSIsIm5vdyIsImNyZWF0ZVVuaXhUaW1lc3RhbXBJblNlY29uZHNGdW5jIiwicGVyZm9ybWFuY2UiLCJhcHByb3hTdGFydGluZ1RpbWVPcmlnaW4iLCJ0aW1lT3JpZ2luIiwidW5kZWZpbmVkIiwidGltZXN0YW1wSW5TZWNvbmRzIiwidGltZXN0YW1wV2l0aE1zIiwiX2Jyb3dzZXJQZXJmb3JtYW5jZVRpbWVPcmlnaW5Nb2RlIiwiYnJvd3NlclBlcmZvcm1hbmNlVGltZU9yaWdpbiIsInRocmVzaG9sZCIsInBlcmZvcm1hbmNlTm93IiwiZGF0ZU5vdyIsInRpbWVPcmlnaW5EZWx0YSIsIk1hdGgiLCJhYnMiLCJ0aW1lT3JpZ2luSXNSZWxpYWJsZSIsIm5hdmlnYXRpb25TdGFydCIsInRpbWluZyIsImhhc05hdmlnYXRpb25TdGFydCIsIm5hdmlnYXRpb25TdGFydERlbHRhIiwibmF2aWdhdGlvblN0YXJ0SXNSZWxpYWJsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/utils/esm/time.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sentry/utils/esm/tracing.js":
/*!***************************************************!*\
  !*** ./node_modules/@sentry/utils/esm/tracing.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TRACEPARENT_REGEXP: () => (/* binding */ TRACEPARENT_REGEXP),\n/* harmony export */   extractTraceparentData: () => (/* binding */ extractTraceparentData),\n/* harmony export */   generateSentryTraceHeader: () => (/* binding */ generateSentryTraceHeader),\n/* harmony export */   propagationContextFromHeaders: () => (/* binding */ propagationContextFromHeaders),\n/* harmony export */   tracingContextFromHeaders: () => (/* binding */ tracingContextFromHeaders)\n/* harmony export */ });\n/* harmony import */ var _baggage_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./baggage.js */ \"(ssr)/./node_modules/@sentry/utils/esm/baggage.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/./node_modules/@sentry/utils/esm/misc.js\");\n\n\n// eslint-disable-next-line @sentry-internal/sdk/no-regexp-constructor -- RegExp is used for readability here\nconst TRACEPARENT_REGEXP = new RegExp(\"^[ \\\\t]*\" + // whitespace\n\"([0-9a-f]{32})?\" + // trace_id\n\"-?([0-9a-f]{16})?\" + // span_id\n\"-?([01])?\" + // sampled\n\"[ \\\\t]*$\");\n/**\n * Extract transaction context data from a `sentry-trace` header.\n *\n * @param traceparent Traceparent string\n *\n * @returns Object containing data from the header, or undefined if traceparent string is malformed\n */ function extractTraceparentData(traceparent) {\n    if (!traceparent) {\n        return undefined;\n    }\n    const matches = traceparent.match(TRACEPARENT_REGEXP);\n    if (!matches) {\n        return undefined;\n    }\n    let parentSampled;\n    if (matches[3] === \"1\") {\n        parentSampled = true;\n    } else if (matches[3] === \"0\") {\n        parentSampled = false;\n    }\n    return {\n        traceId: matches[1],\n        parentSampled,\n        parentSpanId: matches[2]\n    };\n}\n/**\n * Create tracing context from incoming headers.\n *\n * @deprecated Use `propagationContextFromHeaders` instead.\n */ // TODO(v8): Remove this function\nfunction tracingContextFromHeaders(sentryTrace, baggage) {\n    const traceparentData = extractTraceparentData(sentryTrace);\n    const dynamicSamplingContext = (0,_baggage_js__WEBPACK_IMPORTED_MODULE_0__.baggageHeaderToDynamicSamplingContext)(baggage);\n    const { traceId, parentSpanId, parentSampled } = traceparentData || {};\n    if (!traceparentData) {\n        return {\n            traceparentData,\n            dynamicSamplingContext: undefined,\n            propagationContext: {\n                traceId: traceId || (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.uuid4)(),\n                spanId: (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.uuid4)().substring(16)\n            }\n        };\n    } else {\n        return {\n            traceparentData,\n            dynamicSamplingContext: dynamicSamplingContext || {},\n            propagationContext: {\n                traceId: traceId || (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.uuid4)(),\n                parentSpanId: parentSpanId || (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.uuid4)().substring(16),\n                spanId: (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.uuid4)().substring(16),\n                sampled: parentSampled,\n                dsc: dynamicSamplingContext || {}\n            }\n        };\n    }\n}\n/**\n * Create a propagation context from incoming headers.\n */ function propagationContextFromHeaders(sentryTrace, baggage) {\n    const traceparentData = extractTraceparentData(sentryTrace);\n    const dynamicSamplingContext = (0,_baggage_js__WEBPACK_IMPORTED_MODULE_0__.baggageHeaderToDynamicSamplingContext)(baggage);\n    const { traceId, parentSpanId, parentSampled } = traceparentData || {};\n    if (!traceparentData) {\n        return {\n            traceId: traceId || (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.uuid4)(),\n            spanId: (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.uuid4)().substring(16)\n        };\n    } else {\n        return {\n            traceId: traceId || (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.uuid4)(),\n            parentSpanId: parentSpanId || (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.uuid4)().substring(16),\n            spanId: (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.uuid4)().substring(16),\n            sampled: parentSampled,\n            dsc: dynamicSamplingContext || {}\n        };\n    }\n}\n/**\n * Create sentry-trace header from span context values.\n */ function generateSentryTraceHeader(traceId = (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.uuid4)(), spanId = (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.uuid4)().substring(16), sampled) {\n    let sampledString = \"\";\n    if (sampled !== undefined) {\n        sampledString = sampled ? \"-1\" : \"-0\";\n    }\n    return `${traceId}-${spanId}${sampledString}`;\n}\n //# sourceMappingURL=tracing.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS91dGlscy9lc20vdHJhY2luZy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXFFO0FBQ25DO0FBRWxDLDZHQUE2RztBQUM3RyxNQUFNRSxxQkFBcUIsSUFBSUMsT0FDN0IsYUFBYSxhQUFhO0FBQ3hCLG9CQUFvQixXQUFXO0FBQy9CLHNCQUFzQixVQUFVO0FBQ2hDLGNBQWMsVUFBVTtBQUN4QjtBQUdKOzs7Ozs7Q0FNQyxHQUNELFNBQVNDLHVCQUF1QkMsV0FBVztJQUN6QyxJQUFJLENBQUNBLGFBQWE7UUFDaEIsT0FBT0M7SUFDVDtJQUVBLE1BQU1DLFVBQVVGLFlBQVlHLEtBQUssQ0FBQ047SUFDbEMsSUFBSSxDQUFDSyxTQUFTO1FBQ1osT0FBT0Q7SUFDVDtJQUVBLElBQUlHO0lBQ0osSUFBSUYsT0FBTyxDQUFDLEVBQUUsS0FBSyxLQUFLO1FBQ3RCRSxnQkFBZ0I7SUFDbEIsT0FBTyxJQUFJRixPQUFPLENBQUMsRUFBRSxLQUFLLEtBQUs7UUFDN0JFLGdCQUFnQjtJQUNsQjtJQUVBLE9BQU87UUFDTEMsU0FBU0gsT0FBTyxDQUFDLEVBQUU7UUFDbkJFO1FBQ0FFLGNBQWNKLE9BQU8sQ0FBQyxFQUFFO0lBQzFCO0FBQ0Y7QUFFQTs7OztDQUlDLEdBQ0QsaUNBQWlDO0FBQ2pDLFNBQVNLLDBCQUNQQyxXQUFXLEVBQ1hDLE9BQU87SUFJUCxNQUFNQyxrQkFBa0JYLHVCQUF1QlM7SUFDL0MsTUFBTUcseUJBQXlCaEIsa0ZBQXFDQSxDQUFDYztJQUVyRSxNQUFNLEVBQUVKLE9BQU8sRUFBRUMsWUFBWSxFQUFFRixhQUFhLEVBQUUsR0FBR00sbUJBQW1CLENBQUM7SUFFckUsSUFBSSxDQUFDQSxpQkFBaUI7UUFDcEIsT0FBTztZQUNMQTtZQUNBQyx3QkFBd0JWO1lBQ3hCVyxvQkFBb0I7Z0JBQ2xCUCxTQUFTQSxXQUFXVCwrQ0FBS0E7Z0JBQ3pCaUIsUUFBUWpCLCtDQUFLQSxHQUFHa0IsU0FBUyxDQUFDO1lBQzVCO1FBQ0Y7SUFDRixPQUFPO1FBQ0wsT0FBTztZQUNMSjtZQUNBQyx3QkFBd0JBLDBCQUEwQixDQUFDO1lBQ25EQyxvQkFBb0I7Z0JBQ2xCUCxTQUFTQSxXQUFXVCwrQ0FBS0E7Z0JBQ3pCVSxjQUFjQSxnQkFBZ0JWLCtDQUFLQSxHQUFHa0IsU0FBUyxDQUFDO2dCQUNoREQsUUFBUWpCLCtDQUFLQSxHQUFHa0IsU0FBUyxDQUFDO2dCQUMxQkMsU0FBU1g7Z0JBQ1RZLEtBQUtMLDBCQUEwQixDQUFDO1lBQ2xDO1FBQ0Y7SUFDRjtBQUNGO0FBRUE7O0NBRUMsR0FDRCxTQUFTTSw4QkFDUFQsV0FBVyxFQUNYQyxPQUFPO0lBRVAsTUFBTUMsa0JBQWtCWCx1QkFBdUJTO0lBQy9DLE1BQU1HLHlCQUF5QmhCLGtGQUFxQ0EsQ0FBQ2M7SUFFckUsTUFBTSxFQUFFSixPQUFPLEVBQUVDLFlBQVksRUFBRUYsYUFBYSxFQUFFLEdBQUdNLG1CQUFtQixDQUFDO0lBRXJFLElBQUksQ0FBQ0EsaUJBQWlCO1FBQ3BCLE9BQU87WUFDTEwsU0FBU0EsV0FBV1QsK0NBQUtBO1lBQ3pCaUIsUUFBUWpCLCtDQUFLQSxHQUFHa0IsU0FBUyxDQUFDO1FBQzVCO0lBQ0YsT0FBTztRQUNMLE9BQU87WUFDTFQsU0FBU0EsV0FBV1QsK0NBQUtBO1lBQ3pCVSxjQUFjQSxnQkFBZ0JWLCtDQUFLQSxHQUFHa0IsU0FBUyxDQUFDO1lBQ2hERCxRQUFRakIsK0NBQUtBLEdBQUdrQixTQUFTLENBQUM7WUFDMUJDLFNBQVNYO1lBQ1RZLEtBQUtMLDBCQUEwQixDQUFDO1FBQ2xDO0lBQ0Y7QUFDRjtBQUVBOztDQUVDLEdBQ0QsU0FBU08sMEJBQ1BiLFVBQVVULCtDQUFLQSxFQUFFLEVBQ2pCaUIsU0FBU2pCLCtDQUFLQSxHQUFHa0IsU0FBUyxDQUFDLEdBQUcsRUFDOUJDLE9BQU87SUFFUCxJQUFJSSxnQkFBZ0I7SUFDcEIsSUFBSUosWUFBWWQsV0FBVztRQUN6QmtCLGdCQUFnQkosVUFBVSxPQUFPO0lBQ25DO0lBQ0EsT0FBTyxDQUFDLEVBQUVWLFFBQVEsQ0FBQyxFQUFFUSxPQUFPLEVBQUVNLGNBQWMsQ0FBQztBQUMvQztBQUUySSxDQUMzSSxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vYnJhbGluay13ZWIvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS91dGlscy9lc20vdHJhY2luZy5qcz8yYmJlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGJhZ2dhZ2VIZWFkZXJUb0R5bmFtaWNTYW1wbGluZ0NvbnRleHQgfSBmcm9tICcuL2JhZ2dhZ2UuanMnO1xuaW1wb3J0IHsgdXVpZDQgfSBmcm9tICcuL21pc2MuanMnO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHNlbnRyeS1pbnRlcm5hbC9zZGsvbm8tcmVnZXhwLWNvbnN0cnVjdG9yIC0tIFJlZ0V4cCBpcyB1c2VkIGZvciByZWFkYWJpbGl0eSBoZXJlXG5jb25zdCBUUkFDRVBBUkVOVF9SRUdFWFAgPSBuZXcgUmVnRXhwKFxuICAnXlsgXFxcXHRdKicgKyAvLyB3aGl0ZXNwYWNlXG4gICAgJyhbMC05YS1mXXszMn0pPycgKyAvLyB0cmFjZV9pZFxuICAgICctPyhbMC05YS1mXXsxNn0pPycgKyAvLyBzcGFuX2lkXG4gICAgJy0/KFswMV0pPycgKyAvLyBzYW1wbGVkXG4gICAgJ1sgXFxcXHRdKiQnLCAvLyB3aGl0ZXNwYWNlXG4pO1xuXG4vKipcbiAqIEV4dHJhY3QgdHJhbnNhY3Rpb24gY29udGV4dCBkYXRhIGZyb20gYSBgc2VudHJ5LXRyYWNlYCBoZWFkZXIuXG4gKlxuICogQHBhcmFtIHRyYWNlcGFyZW50IFRyYWNlcGFyZW50IHN0cmluZ1xuICpcbiAqIEByZXR1cm5zIE9iamVjdCBjb250YWluaW5nIGRhdGEgZnJvbSB0aGUgaGVhZGVyLCBvciB1bmRlZmluZWQgaWYgdHJhY2VwYXJlbnQgc3RyaW5nIGlzIG1hbGZvcm1lZFxuICovXG5mdW5jdGlvbiBleHRyYWN0VHJhY2VwYXJlbnREYXRhKHRyYWNlcGFyZW50KSB7XG4gIGlmICghdHJhY2VwYXJlbnQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgY29uc3QgbWF0Y2hlcyA9IHRyYWNlcGFyZW50Lm1hdGNoKFRSQUNFUEFSRU5UX1JFR0VYUCk7XG4gIGlmICghbWF0Y2hlcykge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBsZXQgcGFyZW50U2FtcGxlZDtcbiAgaWYgKG1hdGNoZXNbM10gPT09ICcxJykge1xuICAgIHBhcmVudFNhbXBsZWQgPSB0cnVlO1xuICB9IGVsc2UgaWYgKG1hdGNoZXNbM10gPT09ICcwJykge1xuICAgIHBhcmVudFNhbXBsZWQgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdHJhY2VJZDogbWF0Y2hlc1sxXSxcbiAgICBwYXJlbnRTYW1wbGVkLFxuICAgIHBhcmVudFNwYW5JZDogbWF0Y2hlc1syXSxcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgdHJhY2luZyBjb250ZXh0IGZyb20gaW5jb21pbmcgaGVhZGVycy5cbiAqXG4gKiBAZGVwcmVjYXRlZCBVc2UgYHByb3BhZ2F0aW9uQ29udGV4dEZyb21IZWFkZXJzYCBpbnN0ZWFkLlxuICovXG4vLyBUT0RPKHY4KTogUmVtb3ZlIHRoaXMgZnVuY3Rpb25cbmZ1bmN0aW9uIHRyYWNpbmdDb250ZXh0RnJvbUhlYWRlcnMoXG4gIHNlbnRyeVRyYWNlLFxuICBiYWdnYWdlLFxuKVxuXG4ge1xuICBjb25zdCB0cmFjZXBhcmVudERhdGEgPSBleHRyYWN0VHJhY2VwYXJlbnREYXRhKHNlbnRyeVRyYWNlKTtcbiAgY29uc3QgZHluYW1pY1NhbXBsaW5nQ29udGV4dCA9IGJhZ2dhZ2VIZWFkZXJUb0R5bmFtaWNTYW1wbGluZ0NvbnRleHQoYmFnZ2FnZSk7XG5cbiAgY29uc3QgeyB0cmFjZUlkLCBwYXJlbnRTcGFuSWQsIHBhcmVudFNhbXBsZWQgfSA9IHRyYWNlcGFyZW50RGF0YSB8fCB7fTtcblxuICBpZiAoIXRyYWNlcGFyZW50RGF0YSkge1xuICAgIHJldHVybiB7XG4gICAgICB0cmFjZXBhcmVudERhdGEsXG4gICAgICBkeW5hbWljU2FtcGxpbmdDb250ZXh0OiB1bmRlZmluZWQsXG4gICAgICBwcm9wYWdhdGlvbkNvbnRleHQ6IHtcbiAgICAgICAgdHJhY2VJZDogdHJhY2VJZCB8fCB1dWlkNCgpLFxuICAgICAgICBzcGFuSWQ6IHV1aWQ0KCkuc3Vic3RyaW5nKDE2KSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHJhY2VwYXJlbnREYXRhLFxuICAgICAgZHluYW1pY1NhbXBsaW5nQ29udGV4dDogZHluYW1pY1NhbXBsaW5nQ29udGV4dCB8fCB7fSwgLy8gSWYgd2UgaGF2ZSB0cmFjZXBhcmVudCBkYXRhIGJ1dCBubyBEU0MgaXQgbWVhbnMgd2UgYXJlIG5vdCBoZWFkIG9mIHRyYWNlIGFuZCB3ZSBtdXN0IGZyZWV6ZSBpdFxuICAgICAgcHJvcGFnYXRpb25Db250ZXh0OiB7XG4gICAgICAgIHRyYWNlSWQ6IHRyYWNlSWQgfHwgdXVpZDQoKSxcbiAgICAgICAgcGFyZW50U3BhbklkOiBwYXJlbnRTcGFuSWQgfHwgdXVpZDQoKS5zdWJzdHJpbmcoMTYpLFxuICAgICAgICBzcGFuSWQ6IHV1aWQ0KCkuc3Vic3RyaW5nKDE2KSxcbiAgICAgICAgc2FtcGxlZDogcGFyZW50U2FtcGxlZCxcbiAgICAgICAgZHNjOiBkeW5hbWljU2FtcGxpbmdDb250ZXh0IHx8IHt9LCAvLyBJZiB3ZSBoYXZlIHRyYWNlcGFyZW50IGRhdGEgYnV0IG5vIERTQyBpdCBtZWFucyB3ZSBhcmUgbm90IGhlYWQgb2YgdHJhY2UgYW5kIHdlIG11c3QgZnJlZXplIGl0XG4gICAgICB9LFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBwcm9wYWdhdGlvbiBjb250ZXh0IGZyb20gaW5jb21pbmcgaGVhZGVycy5cbiAqL1xuZnVuY3Rpb24gcHJvcGFnYXRpb25Db250ZXh0RnJvbUhlYWRlcnMoXG4gIHNlbnRyeVRyYWNlLFxuICBiYWdnYWdlLFxuKSB7XG4gIGNvbnN0IHRyYWNlcGFyZW50RGF0YSA9IGV4dHJhY3RUcmFjZXBhcmVudERhdGEoc2VudHJ5VHJhY2UpO1xuICBjb25zdCBkeW5hbWljU2FtcGxpbmdDb250ZXh0ID0gYmFnZ2FnZUhlYWRlclRvRHluYW1pY1NhbXBsaW5nQ29udGV4dChiYWdnYWdlKTtcblxuICBjb25zdCB7IHRyYWNlSWQsIHBhcmVudFNwYW5JZCwgcGFyZW50U2FtcGxlZCB9ID0gdHJhY2VwYXJlbnREYXRhIHx8IHt9O1xuXG4gIGlmICghdHJhY2VwYXJlbnREYXRhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRyYWNlSWQ6IHRyYWNlSWQgfHwgdXVpZDQoKSxcbiAgICAgIHNwYW5JZDogdXVpZDQoKS5zdWJzdHJpbmcoMTYpLFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRyYWNlSWQ6IHRyYWNlSWQgfHwgdXVpZDQoKSxcbiAgICAgIHBhcmVudFNwYW5JZDogcGFyZW50U3BhbklkIHx8IHV1aWQ0KCkuc3Vic3RyaW5nKDE2KSxcbiAgICAgIHNwYW5JZDogdXVpZDQoKS5zdWJzdHJpbmcoMTYpLFxuICAgICAgc2FtcGxlZDogcGFyZW50U2FtcGxlZCxcbiAgICAgIGRzYzogZHluYW1pY1NhbXBsaW5nQ29udGV4dCB8fCB7fSwgLy8gSWYgd2UgaGF2ZSB0cmFjZXBhcmVudCBkYXRhIGJ1dCBubyBEU0MgaXQgbWVhbnMgd2UgYXJlIG5vdCBoZWFkIG9mIHRyYWNlIGFuZCB3ZSBtdXN0IGZyZWV6ZSBpdFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgc2VudHJ5LXRyYWNlIGhlYWRlciBmcm9tIHNwYW4gY29udGV4dCB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlU2VudHJ5VHJhY2VIZWFkZXIoXG4gIHRyYWNlSWQgPSB1dWlkNCgpLFxuICBzcGFuSWQgPSB1dWlkNCgpLnN1YnN0cmluZygxNiksXG4gIHNhbXBsZWQsXG4pIHtcbiAgbGV0IHNhbXBsZWRTdHJpbmcgPSAnJztcbiAgaWYgKHNhbXBsZWQgIT09IHVuZGVmaW5lZCkge1xuICAgIHNhbXBsZWRTdHJpbmcgPSBzYW1wbGVkID8gJy0xJyA6ICctMCc7XG4gIH1cbiAgcmV0dXJuIGAke3RyYWNlSWR9LSR7c3BhbklkfSR7c2FtcGxlZFN0cmluZ31gO1xufVxuXG5leHBvcnQgeyBUUkFDRVBBUkVOVF9SRUdFWFAsIGV4dHJhY3RUcmFjZXBhcmVudERhdGEsIGdlbmVyYXRlU2VudHJ5VHJhY2VIZWFkZXIsIHByb3BhZ2F0aW9uQ29udGV4dEZyb21IZWFkZXJzLCB0cmFjaW5nQ29udGV4dEZyb21IZWFkZXJzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFjaW5nLmpzLm1hcFxuIl0sIm5hbWVzIjpbImJhZ2dhZ2VIZWFkZXJUb0R5bmFtaWNTYW1wbGluZ0NvbnRleHQiLCJ1dWlkNCIsIlRSQUNFUEFSRU5UX1JFR0VYUCIsIlJlZ0V4cCIsImV4dHJhY3RUcmFjZXBhcmVudERhdGEiLCJ0cmFjZXBhcmVudCIsInVuZGVmaW5lZCIsIm1hdGNoZXMiLCJtYXRjaCIsInBhcmVudFNhbXBsZWQiLCJ0cmFjZUlkIiwicGFyZW50U3BhbklkIiwidHJhY2luZ0NvbnRleHRGcm9tSGVhZGVycyIsInNlbnRyeVRyYWNlIiwiYmFnZ2FnZSIsInRyYWNlcGFyZW50RGF0YSIsImR5bmFtaWNTYW1wbGluZ0NvbnRleHQiLCJwcm9wYWdhdGlvbkNvbnRleHQiLCJzcGFuSWQiLCJzdWJzdHJpbmciLCJzYW1wbGVkIiwiZHNjIiwicHJvcGFnYXRpb25Db250ZXh0RnJvbUhlYWRlcnMiLCJnZW5lcmF0ZVNlbnRyeVRyYWNlSGVhZGVyIiwic2FtcGxlZFN0cmluZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/utils/esm/tracing.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sentry/utils/esm/worldwide.js":
/*!*****************************************************!*\
  !*** ./node_modules/@sentry/utils/esm/worldwide.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GLOBAL_OBJ: () => (/* binding */ GLOBAL_OBJ),\n/* harmony export */   getGlobalObject: () => (/* binding */ getGlobalObject),\n/* harmony export */   getGlobalSingleton: () => (/* binding */ getGlobalSingleton)\n/* harmony export */ });\n/** Internal global with common properties and Sentry extensions  */ // The code below for 'isGlobalObj' and 'GLOBAL_OBJ' was copied from core-js before modification\n// https://github.com/zloirock/core-js/blob/1b944df55282cdc99c90db5f49eb0b6eda2cc0a3/packages/core-js/internals/global.js\n// core-js has the following licence:\n//\n// Copyright (c) 2014-2022 Denis Pushkarev\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n/** Returns 'obj' if it's the global object, otherwise returns undefined */ function isGlobalObj(obj) {\n    return obj && obj.Math == Math ? obj : undefined;\n}\n/** Get's the global object for the current JavaScript runtime */ const GLOBAL_OBJ = typeof globalThis == \"object\" && isGlobalObj(globalThis) || // eslint-disable-next-line no-restricted-globals\n false && 0 || typeof self == \"object\" && isGlobalObj(self) || typeof global == \"object\" && isGlobalObj(global) || function() {\n    return this;\n}() || {};\n/**\n * @deprecated Use GLOBAL_OBJ instead or WINDOW from @sentry/browser. This will be removed in v8\n */ function getGlobalObject() {\n    return GLOBAL_OBJ;\n}\n/**\n * Returns a global singleton contained in the global `__SENTRY__` object.\n *\n * If the singleton doesn't already exist in `__SENTRY__`, it will be created using the given factory\n * function and added to the `__SENTRY__` object.\n *\n * @param name name of the global singleton on __SENTRY__\n * @param creator creator Factory function to create the singleton if it doesn't already exist on `__SENTRY__`\n * @param obj (Optional) The global object on which to look for `__SENTRY__`, if not `GLOBAL_OBJ`'s return value\n * @returns the singleton\n */ function getGlobalSingleton(name, creator, obj) {\n    const gbl = obj || GLOBAL_OBJ;\n    const __SENTRY__ = gbl.__SENTRY__ = gbl.__SENTRY__ || {};\n    const singleton = __SENTRY__[name] || (__SENTRY__[name] = creator());\n    return singleton;\n}\n //# sourceMappingURL=worldwide.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS91dGlscy9lc20vd29ybGR3aWRlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLGtFQUFrRSxHQUVsRSxnR0FBZ0c7QUFDaEcseUhBQXlIO0FBQ3pILHFDQUFxQztBQUNyQyxFQUFFO0FBQ0YsMENBQTBDO0FBQzFDLEVBQUU7QUFDRiwrRUFBK0U7QUFDL0UsZ0ZBQWdGO0FBQ2hGLCtFQUErRTtBQUMvRSw0RUFBNEU7QUFDNUUsd0VBQXdFO0FBQ3hFLDJEQUEyRDtBQUMzRCxFQUFFO0FBQ0YsNkVBQTZFO0FBQzdFLHNEQUFzRDtBQUN0RCxFQUFFO0FBQ0YsNkVBQTZFO0FBQzdFLDJFQUEyRTtBQUMzRSw4RUFBOEU7QUFDOUUseUVBQXlFO0FBQ3pFLGdGQUFnRjtBQUNoRiw0RUFBNEU7QUFDNUUsZ0JBQWdCO0FBRWhCLHlFQUF5RSxHQUN6RSxTQUFTQSxZQUFZQyxHQUFHO0lBQ3RCLE9BQU9BLE9BQU9BLElBQUlDLElBQUksSUFBSUEsT0FBT0QsTUFBTUU7QUFDekM7QUFFQSwrREFBK0QsR0FDL0QsTUFBTUMsYUFDSixPQUFRQyxjQUFjLFlBQVlMLFlBQVlLLGVBQzlDLGlEQUFpRDtBQUNoRCxNQUFpQixJQUFZTCxDQUFtQk0sSUFDaEQsT0FBT0MsUUFBUSxZQUFZUCxZQUFZTyxTQUN2QyxPQUFPQyxVQUFVLFlBQVlSLFlBQVlRLFdBQzFDO0lBQ0UsT0FBTyxJQUFJO0FBQ2IsT0FDQSxDQUFDO0FBRUg7O0NBRUMsR0FDRCxTQUFTQztJQUNQLE9BQU9MO0FBQ1Q7QUFFQTs7Ozs7Ozs7OztDQVVDLEdBQ0QsU0FBU00sbUJBQW1CQyxJQUFJLEVBQUVDLE9BQU8sRUFBRVgsR0FBRztJQUM1QyxNQUFNWSxNQUFPWixPQUFPRztJQUNwQixNQUFNVSxhQUFjRCxJQUFJQyxVQUFVLEdBQUdELElBQUlDLFVBQVUsSUFBSSxDQUFDO0lBQ3hELE1BQU1DLFlBQVlELFVBQVUsQ0FBQ0gsS0FBSyxJQUFLRyxDQUFBQSxVQUFVLENBQUNILEtBQUssR0FBR0MsU0FBUTtJQUNsRSxPQUFPRztBQUNUO0FBRTJELENBQzNELHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL29icmFsaW5rLXdlYi8uL25vZGVfbW9kdWxlcy9Ac2VudHJ5L3V0aWxzL2VzbS93b3JsZHdpZGUuanM/MDEwOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogSW50ZXJuYWwgZ2xvYmFsIHdpdGggY29tbW9uIHByb3BlcnRpZXMgYW5kIFNlbnRyeSBleHRlbnNpb25zICAqL1xuXG4vLyBUaGUgY29kZSBiZWxvdyBmb3IgJ2lzR2xvYmFsT2JqJyBhbmQgJ0dMT0JBTF9PQkonIHdhcyBjb3BpZWQgZnJvbSBjb3JlLWpzIGJlZm9yZSBtb2RpZmljYXRpb25cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2Jsb2IvMWI5NDRkZjU1MjgyY2RjOTljOTBkYjVmNDllYjBiNmVkYTJjYzBhMy9wYWNrYWdlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwuanNcbi8vIGNvcmUtanMgaGFzIHRoZSBmb2xsb3dpbmcgbGljZW5jZTpcbi8vXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTQtMjAyMiBEZW5pcyBQdXNoa2FyZXZcbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG4vKiogUmV0dXJucyAnb2JqJyBpZiBpdCdzIHRoZSBnbG9iYWwgb2JqZWN0LCBvdGhlcndpc2UgcmV0dXJucyB1bmRlZmluZWQgKi9cbmZ1bmN0aW9uIGlzR2xvYmFsT2JqKG9iaikge1xuICByZXR1cm4gb2JqICYmIG9iai5NYXRoID09IE1hdGggPyBvYmogOiB1bmRlZmluZWQ7XG59XG5cbi8qKiBHZXQncyB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgdGhlIGN1cnJlbnQgSmF2YVNjcmlwdCBydW50aW1lICovXG5jb25zdCBHTE9CQUxfT0JKID1cbiAgKHR5cGVvZiBnbG9iYWxUaGlzID09ICdvYmplY3QnICYmIGlzR2xvYmFsT2JqKGdsb2JhbFRoaXMpKSB8fFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXG4gICh0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIGlzR2xvYmFsT2JqKHdpbmRvdykpIHx8XG4gICh0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBpc0dsb2JhbE9iaihzZWxmKSkgfHxcbiAgKHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgaXNHbG9iYWxPYmooZ2xvYmFsKSkgfHxcbiAgKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSkoKSB8fFxuICB7fTtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2UgR0xPQkFMX09CSiBpbnN0ZWFkIG9yIFdJTkRPVyBmcm9tIEBzZW50cnkvYnJvd3Nlci4gVGhpcyB3aWxsIGJlIHJlbW92ZWQgaW4gdjhcbiAqL1xuZnVuY3Rpb24gZ2V0R2xvYmFsT2JqZWN0KCkge1xuICByZXR1cm4gR0xPQkFMX09CSiA7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGdsb2JhbCBzaW5nbGV0b24gY29udGFpbmVkIGluIHRoZSBnbG9iYWwgYF9fU0VOVFJZX19gIG9iamVjdC5cbiAqXG4gKiBJZiB0aGUgc2luZ2xldG9uIGRvZXNuJ3QgYWxyZWFkeSBleGlzdCBpbiBgX19TRU5UUllfX2AsIGl0IHdpbGwgYmUgY3JlYXRlZCB1c2luZyB0aGUgZ2l2ZW4gZmFjdG9yeVxuICogZnVuY3Rpb24gYW5kIGFkZGVkIHRvIHRoZSBgX19TRU5UUllfX2Agb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBuYW1lIG5hbWUgb2YgdGhlIGdsb2JhbCBzaW5nbGV0b24gb24gX19TRU5UUllfX1xuICogQHBhcmFtIGNyZWF0b3IgY3JlYXRvciBGYWN0b3J5IGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgc2luZ2xldG9uIGlmIGl0IGRvZXNuJ3QgYWxyZWFkeSBleGlzdCBvbiBgX19TRU5UUllfX2BcbiAqIEBwYXJhbSBvYmogKE9wdGlvbmFsKSBUaGUgZ2xvYmFsIG9iamVjdCBvbiB3aGljaCB0byBsb29rIGZvciBgX19TRU5UUllfX2AsIGlmIG5vdCBgR0xPQkFMX09CSmAncyByZXR1cm4gdmFsdWVcbiAqIEByZXR1cm5zIHRoZSBzaW5nbGV0b25cbiAqL1xuZnVuY3Rpb24gZ2V0R2xvYmFsU2luZ2xldG9uKG5hbWUsIGNyZWF0b3IsIG9iaikge1xuICBjb25zdCBnYmwgPSAob2JqIHx8IEdMT0JBTF9PQkopIDtcbiAgY29uc3QgX19TRU5UUllfXyA9IChnYmwuX19TRU5UUllfXyA9IGdibC5fX1NFTlRSWV9fIHx8IHt9KTtcbiAgY29uc3Qgc2luZ2xldG9uID0gX19TRU5UUllfX1tuYW1lXSB8fCAoX19TRU5UUllfX1tuYW1lXSA9IGNyZWF0b3IoKSk7XG4gIHJldHVybiBzaW5nbGV0b247XG59XG5cbmV4cG9ydCB7IEdMT0JBTF9PQkosIGdldEdsb2JhbE9iamVjdCwgZ2V0R2xvYmFsU2luZ2xldG9uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD13b3JsZHdpZGUuanMubWFwXG4iXSwibmFtZXMiOlsiaXNHbG9iYWxPYmoiLCJvYmoiLCJNYXRoIiwidW5kZWZpbmVkIiwiR0xPQkFMX09CSiIsImdsb2JhbFRoaXMiLCJ3aW5kb3ciLCJzZWxmIiwiZ2xvYmFsIiwiZ2V0R2xvYmFsT2JqZWN0IiwiZ2V0R2xvYmFsU2luZ2xldG9uIiwibmFtZSIsImNyZWF0b3IiLCJnYmwiLCJfX1NFTlRSWV9fIiwic2luZ2xldG9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry/utils/esm/worldwide.js\n");

/***/ })

};
;